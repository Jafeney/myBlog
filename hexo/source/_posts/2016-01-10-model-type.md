---
title: Javascript 设计模式类别
date: 2016-01-10 15:16:11
tags: [Javascript,"设计模式"]   
categories: 前端  
---


# 前言
命名、抽象、标识是通用设计结构的主要方面，这些设计结构能被用于构造可复用的面向对象设计。设计模式确定所包含的类和实例、它们的角色、协作方式以及职责分配。

每一种设计模式都重点关注一个特定的对象设计问题或者设计要点，描述何时使用它，在另一些约束条件下是否还能使用，以及使用的效果和利弊。由于我们最终要实现设计，设计模式还是提供了示例，代码来阐明其实现。

虽然设计模式描述的是面向对象设计，但是他们都是基于实际的解决方案。这些设计方案的实现语言是主流面向对象的编程语言。

<!--more-->

# 设计模式的分类
## **创建型设计模式**
创建型设计模式专注于处理对象创建机制，以适合给定情况下的方式来创建对象，创建对象的基本方法都可能导致项目复杂性增加。而这些模式旨在通过控制创建过程来解决这类问题。

常见的创建型设计模式包括：Constructor构造器模式、Factory工厂模式、Abstract抽象模式、Prototype原型模式、Singleton单例模式和Builder生成器模式。
## **结构型设计模式**
结构型设计模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。同时对于不适合因某一特定目的而改变的系统部分，这种模式也可以帮助它们完成重组。

常见的结构型设计模式有：Decorator装饰者模式、Facade外观模式、Flyweight享元模式、Adapter适配器模式和Proxy代理模式。

## **行为型设计模式**
行为型设计模式专注于改善或简化系统中不同对象之间的通信。

行为模式包括：Iterator迭代器模式、Mediator中介者模式、Observer观察者模式、Visitor访问者模式。

# Class
Javascript是一种无类语言，但可以用函数来模拟类，然后使用new关键字创建新的对象，使用this来定义对象的新属性和方法。

```
function Car(model){
	this.model=model;
	this.color="silver";
	this.year="2012";

	this.getInfo=function(){
		return this.model+" "+this.year;
	};
}
```
然后我们像这样我们使用上面定义的car构造函数来实例化该对象。
```
var myCar=new Car("ford");
myCar.year="2010";
console.log(myCar.getInfo());
```
<table>
		<tr>
			<td>创建型模式</td>
			<td>基于创建对象的概念</td>
		</tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">类</td>
		</tr>
		<tr><td>工厂方法</td><td>基于接口数据或者生成几个派生类的一个实例</td></tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">对象</td>
		</tr>
		<tr><td>抽象工厂</td><td>创建若干类系列的一个实例，无需描述具体的的类</td></tr>
		<tr><td>生成器</td><td>从表示中分离对象构建；总是创建相同类型的对象</td></tr>
		<tr><td>原型</td><td>用于复制或者克隆完全初始化的实例</td></tr>
		<tr><td>单例</td><td>一个类在全局访问点只有唯一一个实例</td></tr>
</table>
----------
<table>
		<tr>
			<td>结构型模式</td>
			<td>基于构建对象块的想法</td>
		</tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">类</td>
		</tr>
		<tr><td>适配器</td><td>匹配不同类的接口，因此可以在不兼容接口的情况下共同工作</td></tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">对象</td>
		</tr>
			<tr><td>适配器</td><td>匹配不同类的接口，因此可以在不兼容接口的情况下共同工作</td></tr>
		<tr><td>桥接</td><td>将对象接口从器实现中分离，因此它们可以独立进行变化</td></tr>
		<tr><td>组合</td><td>简单和复合对象的结构，使对象的总和不只是它们各部分的总和</td></tr>
		<tr><td>装饰</td><td>向对象动态添加备选的处理</td></tr>
		<tr><td>外观</td><td>隐藏整个子系统复杂性的唯一一个类</td></tr>
		<tr><td>享元</td><td>一个用于实现包含在别处信息的高效共享的细粒度实例</td></tr>

<tr><td>代理</td><td>占位符对象代表真正的对象 </td></tr>
</table>
----------
<table>
		<tr>
			<td>行为型模式</td>
			<td>基于对象在一起配合工作的方式</td>
		</tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">类</td>
		</tr>
		<tr><td>解释器</td><td>将语言元素包含在应用程序中的方法，以匹配预期语言的语法</td></tr>
		<tr><td>模板方法</td><td>在方法中创建算法的shell，然后将确切的步骤推到子类</td></tr>
		<tr>
			<td colspan="2" bgcolor="#f0f0f0">对象</td>
		</tr>
			<tr><td>职责链</td><td>在对象链之间传递请求的方法，以找到能够处理请求的对象</td></tr>
		<tr><td>命令</td><td>将命令执行从其调用程序中分离的方法</td></tr>
		<tr><td>迭代器</td><td>顺序访问一个集合中的元素，无需了解该集合内部的工作原理</td></tr>
		<tr><td>中介者</td><td>在类之间定义简化的通信，以防止一组类显式引用彼此</td></tr>
		<tr><td>备忘录</td><td>捕获对象的内部状态，已能够在以后恢复它</td></tr>
		<tr><td>观察者</td><td>向多个类通知改变的方式，以确保类之间的一致性</td></tr>

<tr><td>状态</td><td>状态改变时，更改对象的行为 </td></tr>
<tr><td>策略</td><td>在一个类中封装算法，将选择与实现分离 </td></tr>
<tr><td>访问者</td><td>向类添加一个新的操作，无需改变类</td></tr>
</table>
