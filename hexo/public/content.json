[{"title":"ReactNative接入微信API","date":"2016-11-18T09:57:15.000Z","path":"2016/11/18/2016-11-17-wechat/","text":"写在前面上一篇简单地讲了 ReactNative 如何接入支付宝支付，那么这一篇就介绍如何接入微信API吧。我们实际用到的一般有微信登录、微信分享、微信支付这三个功能。 准备工作微信的东西比较支付宝申请起来要略微麻烦点，步骤多，而且有些资质认证要给微信钱，心太黑。废话不多说，登录微信开放平台，创建你的App应用，改填的都填了，提交 —— 审核1～2天 —— 通过 —— 申请微信支付 —— 继续审核 … MD这步一次性通过是有多难 ! 商户平台微信支付申请通过了会收到一份邮件，里面有你的微信支付商户账号的信息（记得保存），然后用这个账号和密码登录微信商户平台。这里关键的一步是： 进入 账户中心 —&gt; API安全 —&gt; 设置一个32位的密钥 具体实现准备工作都做好了，我们就可以开始开发了。 安装模块感谢大react-native社区，为我们这种菜鸟提供了如此全面的微信三方模块react-native-wechat，完全能满足现阶段的所有微信API需求啊！ github地址 react-native-wechat交流群 336021910 支持npm安装： 1npm install react-native-wechat --save 让 ReactNative完全支持ES7async和await是ES7比较新的提案，让ReactNative完全支持stage-0，首先我们需要安装 babel-preset-react-native-stage-0 模块: 1npm install babel-preset-react-native-stage-0 --save-dev 并设置 .babelrc 123&#123; \"presets\": [ \"react-native-stage-0\" ],&#125; link和配置上一篇已经介绍了 react-native link 命令，可以把客户端所需的模块链接到IOS和Android目录里。 1react-native link react-native-wechat 当然，只执行上面的命令还不够。我们还需要手动添加一些配置 IOS端微信的配置和支付宝差别不大。 （1）添加下面几个framework和library： 12345SystemConfiguration.frameworkCoreTelephony.frameworklibsqlite3.0libc++libz 注意：CoreTelephony.framework、libc++z、libz，这三项和支付宝模块的重复，引一次就够了。 （2）添加 URL Schema ，值是你应用的微信appid （3）给 LSApplicationQueriesSchemes 添加三个值 alipay、weixin、wechat 或者直接编辑 Info.plist： 123456&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt; &lt;string&gt;alipay&lt;/string&gt; &lt;string&gt;weixin&lt;/string&gt; &lt;string&gt;wechat&lt;/string&gt;&lt;/array&gt; 注意：如果你不需要支付宝支付， alipay 可以不加 （4）修改 AppDelegate.m 如果你不需要支付宝支付，这个函数可以这么写： 12345678#import &quot;../Libraries/LinkingIOS/RCTLinkingManager.h&quot;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)urlsourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation];&#125; 如果你既要支付宝支付，也需要微信支付。那么应该这么写： 12345678910#import &quot;../Libraries/LinkingIOS/RCTLinkingManager.h&quot;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; if([[sourceApplication substringToIndex:10] isEqualToString:@&quot;com.alipay&quot;])&#123; [AlipayModule handleCallback:url]; &#125; return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation];&#125; Android端（1） 修改android/settings.gradle 12include ':RCTWeChat'project(':RCTWeChat').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-wechat/android') （2）修改android/app/build.gradle 123dependencies &#123; compile project(':RCTWeChat') // Add this line only.&#125; （3）修改MainActivity.java or MainApplication.java 1234567891011121314import com.theweflex.react.WeChatPackage; // Add this line before public class MainActivity.../** * A list of packages used by the app. If the app uses additional views * or modules besides the default ones, add more packages here. */@Overrideprotected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new WeChatPackage() // Add this line );&#125; （4）创建一个新的package 取名wxapi ，在里面创建class 取名WXEntryActivity 1234567891011121314package your.package.wxapi;import android.app.Activity;import android.os.Bundle;import com.theweflex.react.WeChatModule;public class WXEntryActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); WeChatModule.handleIntent(getIntent()); finish(); &#125;&#125; （5）修改AndroidManifest.xml 12345678910&lt;manifest&gt; &lt;application&gt; &lt;!-- 微信Activity --&gt; &lt;activity android:name=\".wxapi.WXEntryActivity\" android:label=\"@string/app_name\" android:exported=\"true\" /&gt; &lt;/application&gt;&lt;/manifest&gt; （6）修改 proguard-rules.pro 123-keep class com.tencent.mm.sdk.** &#123; *;&#125; 初始化模块react-native-wechat 使用前必须初始化一次（有且仅一次）。建议放在项目的入口文件里： 1234// ...省略componentDidMount() &#123; WeChat.registerApp('你的appid')&#125; 微信登录微信登录需要用到的是 WeChat.sendAuthRequest 这个方法。 获取微信CODE首先介绍一下它参数： scope (必需) 应用授权作用域，如获取用户个人信息则填写 snsapi_userinfo state (非必需) 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验 执行 WeChat.sendAuthRequest获取CODE： 1let code = await WeChat.sendAuthRequest(\"snsapi_userinfo\", \"123\"); 该方法会返回一个字符串，类似 0114sg4t1F1Rc90jSw6t1Cf44t14sg4- 一串CODE。 获取微信access_token包装一个 GET类型的fetch请求，URL如下： 1https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 这个接口会返回 access_token 和 用户的 openid。示例如下： 12345678&#123; \"access_token\": \"JWk5IxV5bFGOdTm2A4zhuGuIB_xGRM5cPbU5nYbkuEihHu6FClMn5zjVZ6QCTYrMv_oCMxW8szuNAOadYIYo6wiOObeesEeNgHeWNvkJolQ\", \"expires_in\": 7200, \"refresh_token\": \"WPhskoRBAmDyM1EbrPRvWSCU8LL3Ndn0Brong9ZG434L1Imkxugu2JKOghfIuP1P3JqcCyB2anxAwXRuFr7EMxP_rygeWy1Noi0zPJue_YU\", \"openid\": \"oDwRbw9zFEO36l3Vcq6bHXFWB13k\", \"scope\": \"snsapi_userinfo\", \"unionid\": \"o3KCIw-vFiuq0SBHe-3bhjbCQY3o\"&#125; 获取微信授权后的用户信息包装一个 GET类型的fetch请求，URL如下： 1https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID 这个接口会返回 授权用户的微信基本信息，示例如下： 123456789101112&#123; \"openid\": \"oDwRbw9zFEO36l3Vcq6bHXFWB13k\", \"nickname\": \"思^_^诚\", \"sex\": 1, \"language\": \"zh_CN\", \"city\": \"Hangzhou\", \"province\": \"Zhejiang\", \"country\": \"CN\", \"headimgurl\": \"http://wx.qlogo.cn/mmopen/PiajxSqBRaEKujUoq5z4PScxKqQESxMxj6VDYnIHT4ZibVDMmSb69dq6EbLPAUJ15mMH9pIxFNu9JZszyx1F6ibcw/0\", \"privilege\": [], \"unionid\": \"o3KCIw-vFiuq0SBHe-3bhjbCQY3o\"&#125; 微信分享微信分享用到的是 WeChat.shareToTimeline(opt)(分享到朋友圈) 和 WeChat.shareToSession(opt)（分享给微信好友或微信群)，这两个方法的入参是一样的。 为了方便，微信分享我做成了一个react-native组件, 感兴趣的可以点击看看 github地址 入参列表 thumbImage 分享出去的预览图 title 分享标题 webpageUrl 分享出去的网页地址 核心代码123456789101112131415161718192021222324252627282930313233343536373839/** * [分享到朋友圈] * @param &#123;[Object]&#125; opt 入参对象 * @example &#123; thumbImage:'', title: '', webpageUrl: '' &#125; */async handleShareWeixinCircle(opt) &#123; this.lock = true /* 异步操作锁 */ try &#123; let result = await WeChat.shareToTimeline(&#123; type: \"news\", ...opt, &#125;); &#125; catch (e) &#123; console.error(e) &#125; finally &#123; this.lock = false this.close() &#125;&#125;/** * [分享给微信好友或微信群] * @param &#123;[Object]&#125; opt 入参对象 * @example &#123; thumbImage:'', title: '', webpageUrl: '' &#125; */async handleShareWeixinFriend(opt) &#123; this.lock = true /* 异步操作锁 */ try &#123; let result = await WeChat.shareToSession(&#123; type: \"news\", ...opt, &#125;); &#125; catch (e) &#123; console.error(e) &#125; finally &#123; this.lock = false this.close() &#125;&#125; 我这里用到的是分享网页，更多分享功能参见 react-native-wechat 微信支付微信支付用到的是 WeChat.pay(opt) 方法 后端的工作后端需要为我们提供一个支付接口 去调取微信支付的 “统一下单” 接口，然后返回下面这些东西： 点击查看官方文档 123456789&#123; appid: '', //应用id partnerid: '', // 商家向财付通申请的商家id prepayid: '', // 预支付订单 noncestr: '', // 随机串，防重发 timestamp: '', // 时间戳，防重发 package: '', // 商家根据财付通文档填写的数据和签名 sign: '' // 商家根据微信开放平台文档对数据做的签名&#125; 注意：后端要严格区分大小写，这几个变量必须都小写。否则会报 “支付签名验证失败” 这类的错误 前端的工作有了react-native-wechat，微信支付其实也就调用一个方法的事情。类似支付宝支付的action，下面是最原始的实现代码（建议把fetch封装一下）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445export function weixinPay(opt) &#123; return (dispatch) =&gt; &#123; const uri = `http://$&#123;CONFIG.API_URI&#125;/wx/pay`; /*支付接口*/ const headers = &#123; ...CONFIG.HEADERS, 'Authorization': opt.token, &#125;; /*发起支付请求*/ fetch(uri, &#123; method: 'POST', headers: headers, body: JSON.stringify(opt.body)&#125;) .then((response) =&gt; &#123; if (response.status === 200) &#123; return response.json() &#125; else &#123; return &#123;code: response.status&#125; &#125; &#125;) .then((data) =&gt; &#123; if (String(data.code) == '0') &#123; /*打开微信进行支付*/ pay(data.result, opt.success, opt.fail) &#125; else &#123; /*预支付失败的后续操作*/ opt.error &amp;&amp; opt.error(data.error.message) &#125; &#125;) &#125;&#125;async function pay(res, success, fail) &#123; try &#123; let result = await WeChat.pay(&#123; partnerId: res.partnerid, /*商家向财付通申请的商家id*/ prepayId: res.prepayid, /*预支付订单*/ nonceStr: res.noncestr, /*随机串，防重发*/ timeStamp: res.timestamp, /*时间戳，防重发*/ package: res.package, /*商家根据财付通文档填写的数据和签名*/ sign: res.sign, /*商家根据微信开放平台文档对数据做的签名*/ &#125;); /*支付成功的后续操作*/ success &amp;&amp; success() &#125; catch (error) &#123; /*支付失败的后续操作*/ fail &amp;&amp; fail( error ===-2 ? \"用户取消\" : \"订单支付失败\") &#125;&#125; @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"ReactNative接入支付宝支付","date":"2016-11-16T08:14:54.000Z","path":"2016/11/16/2016-11-16-alipay/","text":"写在前面重申一下，ReactNative开发的App是NativeApp，不是WebApp或者HybridApp，所以我们需要开通的是支付宝的App支付功能，别申请错了。申请完成之后就可以接下去开发了。 支付宝支付接入支付宝支付前建议先查看 支付宝官方文档，先按照要求创建应用并完成配置。不过要注意以下两点： 第一，App支付不能在沙箱做测试，所以我们需要先 “上线” 应用，这个过程会有1天的审核时间。第二，调试时建议添加个一分钱的商品作为测试商品，开发免不了要支付几次。 安装模块支付宝支付我们使用了ReactNative社区推荐的 react-native-yunpeng-alipay 模块，可以使用 npm 安装 1npm install react-native-yunpeng-alipay --save link引用最新版 React Native (&gt;=0.31) 已经支持 link 命令，不需要再使用三方的 rnpm来 link 引用了。 1react-native link react-native-yunpeng-alipay 这个操作会把 react-native-yunpeng-alipay 模块下的客户端模块自动映射到 ReactNative工程的对应的 IOS和 Android目录里。 注意，自动link并不是万能的，有些模块我们需要再手动添加一些引用。 IOS端配置对于IOS端，除了上面的link操作之外，我们还需要手动做下面的三件事： 添加Frameworks和Libraries打开xcode，TARGET -&gt; General -&gt; Linked Frameworks and Libraries ，添加 CoreMotion.framework CoreTelephony.framework libc++ libz 添加 URL Schema打开 Info.plist，添加一项URL types： 触发回调打开 AppDelegate.m，添加一个函数来触发支付完成后的回调 1234567#import \"AlipayModule.h\"- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; [AlipayModule handleCallback:url]; return YES;&#125; Android端配置 Android端配置比较简单，除了上面的link操作外，我们还需要修改Manifest文件 修改Manifest在商户应用工程的AndroidManifest.xml文件里面添加声明：123456789101112&lt;activity android:name=\"com.alipay.sdk.app.H5PayActivity\" android:configChanges=\"orientation|keyboardHidden|navigation\" android:exported=\"false\" android:screenOrientation=\"behind\" &gt;&lt;/activity&gt;&lt;activity android:name=\"com.alipay.sdk.auth.AuthActivity\" android:configChanges=\"orientation|keyboardHidden|navigation\" android:exported=\"false\" android:screenOrientation=\"behind\" &gt; &lt;/activity&gt; 和权限声明： 12345678910111213141516171819202122&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;``` ---### 添加混淆规则在android应用工程的`proguard-project.txt`里添加以下相关规则：```Java-libraryjars libs/alipaySDK-20150602.jar-keep class com.alipay.android.app.IAlixPay&#123;*;&#125;-keep class com.alipay.android.app.IAlixPay$Stub&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback&#123;*;&#125;-keep class com.alipay.android.app.IRemoteServiceCallback$Stub&#123;*;&#125;-keep class com.alipay.sdk.app.PayTask&#123; public *;&#125;-keep class com.alipay.sdk.app.AuthTask&#123; public *;&#125; Action封装我们的App开发采用的是redux框架，为了方便使用，我把支付宝支付封装成了Action，你可以参考一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @desc 三方支付 * @author Jafeney * @detetime 2016-11-08 **/import Alipay from 'react-native-yunpeng-alipay'import * as CONFIG from '../config'export function alipay(opt) &#123; return (dispatch) =&gt; &#123; const uri = `http://$&#123; CONFIG.API_URI &#125;/alipay/pay`; /*支付接口*/ const headers = &#123; ...CONFIG.HEADERS, Authorization: opt.token &#125;; /*调用支付接口*/ fetch(uri, &#123;method: 'POST', headers: headers, body: JSON.stringify(opt.body)&#125;) .then((response) =&gt; &#123; if (response.status === 200) &#123; return response.json() &#125; else &#123; return &#123;code: response.status&#125; &#125; &#125;) .then((data) =&gt; &#123; if (String(data.code) == '0') &#123; /*打开支付宝进行支付*/ Alipay.pay(data.result).then((data) =&gt; &#123; if (data.length &amp;&amp; data[0].resultStatus) &#123; /*处理支付结果*/ switch (data[0].resultStatus) &#123; case \"9000\": opt.success &amp;&amp; opt.success(data) break; case \"8000\": opt.fail &amp;&amp; opt.fail('支付结果未知,请查询订单状态') break; case \"4000\": opt.fail &amp;&amp; opt.fail('订单支付失败') break; case \"5000\": opt.fail &amp;&amp; opt.fail('重复请求') break; case \"6001\": opt.fail &amp;&amp; opt.fail('用户中途取消') break; case \"6002\": opt.fail &amp;&amp; opt.fail('网络连接出错') break; case \"6004\": opt.fail &amp;&amp; opt.fail('支付结果未知,请查询订单状态') break; default: opt.fail &amp;&amp; opt.fail('其他失败原因') break; &#125; &#125; else &#123; opt.fail &amp;&amp; opt.fail('其他失败原因') &#125; &#125;, (err) =&gt; &#123; opt.fail &amp;&amp; opt.fail('支付失败，请重新支付') &#125; ) &#125; else &#123; opt.error &amp;&amp; opt.error('支付参数错误') &#125; &#125;) &#125;&#125; @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"ReactNative坑点——Date对象正确使用","date":"2016-11-16T03:28:33.000Z","path":"2016/11/16/2016-11-16-react-native/","text":"写在前面昨天遇到了一个非常诡异的场景，ReactNative写的倒计时组件线上版本无法运行，但本地测试却是正常的。我一度以为是ReactNative转换的时候出了问题，不知道从何下手。最后盘查了一圈，发现了一个不得了的事！——ReactNative的JS解析，当打开chrome进行Debug时，用的的确是chrome的内核，但对于转换好的版本，如IOS版本用的是safari的内核，Android版本也会随着操作系统的不同而存在差异。 定位出错点上面发现的问题有点类似以前经常碰到的浏览器兼容问题。Get到这层意思，马上就发现下面这种写法存在兼容问题： 1var date = new Date('2016-12-15 10:20') Chrome浏览器里当然是正确的，但是在Safari和Firefox里是date的值是 Invalid Date。 Chrome浏览器里的结果 Safari浏览器里的结果 Firefox浏览器的结果 解决办法介于上面的兼容性问题，需要对 Date()这个构造方法做处理： 123456789101112131415export function parseDate(date) &#123; var isoExp, parts; isoExp = /^\\s*(\\d&#123;4&#125;)-(\\d\\d)-(\\d\\d)\\s(\\d\\d):(\\d\\d):(\\d\\d)\\s*$/; try &#123; parts = isoExp.exec(date); &#125; catch(e) &#123; return null; &#125; if (parts) &#123; date = new Date(parts[1], parts[2] - 1, parts[3], parts[4], parts[5], parts[6]); &#125; else &#123; return null; &#125; return date;&#125; 上面用到了 export 关键字，你可以把它放到 mixins 里全局调用。 以后就用 parseDate 替代new Date()，就避开了兼容问题。 12345import &#123; parseDate &#125; from './mixins/helper'// ... 省略let date = parseDate('2016-11-15 10:20')","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"基于Redux的ReactNative项目开发总结（二）","date":"2016-09-20T02:45:39.000Z","path":"2016/09/20/2016-09-20-react-native/","text":"写在前面 自从上次写了此系列的一篇文章，公司App项目不幸被搁浅，我也转战到React组件库和Node后端项目的开发，本来的有些断章取义的想法没有很好地去整合，也就不丢出来献丑了。好在峰回路转，新的ReactNative项目袭来，重拾之前的架构，经过1个月的开发和思考，有丢弃也有创新。 版本更新带来的BUG修复faceBook对ReactNative版本的更新速度实在是太快，还记得我开发第一款App的时候，用的还是0.24，现在已经更新到0.33。甚至在这个项目init的时候还是0.31，短短一个月，项目丢到别的机子上跑的时候已经更新到了0.33。真是”三天不读书，赶不上刘少奇”，伴随着ReactNative版本快速的演进，的确是修复了很多的原先的不足（比如对原生组件功能的完善和部分跨平台BUG修复），但也带来了一些你不知道的问题和BUG。下面我先罗列几个我遇到的BUG和解决办法。 让Image组件加载http的网络图片这个问题出现在IOS里，xcode7以上的版本默认不支持http路径的网络图片，如果硬要使用，必须配置项目的info参数： 在NSAppTransportSecurity里添加属性NSAllowsArbitraryLoads为true，然后把NSExceptionDomains 下面的 NSTemporaryExceptionAllowsInsecureHTTPLoads也设为true 具体配置如下： 12345678910111213&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;localhost&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt;&lt;/dict&gt; 或者通过Xcode修改： 真机调试IP无法修改问题解决这个问题是0.29以后带来的，本来如果需要真机调试（以IOS为例），我们需要手动修改AppDelegate.m和RCTWebSocketExecutor.m这两个文件里的localhost为我们需要的IP地址。 可能是意识到这样繁琐操作的带来的麻烦，0.29以后faceBook为我们节省了这一步，自动去获取项目运行的IP地址，而不需要我们手动去修改。OK，他们确实做到了，但是不尽人意的是带来了新的问题： 电脑换一个网络，项目运行后无法开启debug模式，仔细察看发现运行的居然是pre-bundled版本，就是预构建的版本，而不是即时运行的版本。甚至更坑的是居然还会时不时地连不上本地的Node进程。 那怎么手动设定IP地址呢？查阅资料获悉： React Native iOS在0.29.0版本中BundleURL加载方法做了重大改变，新增了RCTBundleURLProvider单例类专门处理BundleURL，使用NSUserDefaults保存配置信息。 默认加载方式在Debug模式下，执行react-native-xcode.sh编译脚本会自动获取当前网卡en0的IP地址，并打入App包中一个配置文件ip.txt，App运行时会读取ip文件，自动生成Developer Server URL，通过这种加载方式，我们不再需要手动去把”localhost”改成Mac的IP了，每次编译都会读取当前最新的IP。 非Debug模式时，没有ip.txt文件，会直接读取本地jsbundle文件，和以前版本的Load from pre-bundled file on disk方式相同。但是我经过测试发现，en0是Wifi的网络，如果关闭Wifi，使用网线端口连接网络，en0默认就是inactive，没有对应的IP。 手动设置IPRCTBundleURLProvider在接口中暴露了jsLocation属性，可以通过setJsLocation手动设置IP。 1234567NSURL *jsCodeLocation;[[RCTBundleURLProvider sharedSettings] setDefaults];#if DEBUG[[RCTBundleURLProvider sharedSettings] setJsLocation:@&quot;192.168.1.101&quot;];#endifjsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil]; 另需要在Info设置NSAppTransportSecurity的NSAllowsArbitraryLoads为true即可（这一步同上图）。 XCode8项目运行报错解决前天升到Xcode8，莫名其妙地发现项目运行居然报错了： 1Code signing is required for product type 'Unit Test Bundle' in SDK 'iOS 10.0' 解决方法如下： 把Code Singing Identity设置为 IOS Developer 一些心得这个部分主要是一些项目的架构设计中觉得比较合理的地方。 Style运用技巧ReactNative里的style有点类似css，但又不是我们熟悉的css，可以理解为 “用JavaScript编写的阉割版CSS“ ，即每个组件支持的Style属性是固定的，不能把Web里的 “div化万物” 的理念拿过来用。比如，文本必须用 Text 组件包裹，其他组件如View、Image是没有和font相关的属性的。 所以我们要对常用组件的style属性了然于心。 然后说到技巧，因为这里style已经变成了一个JavaScript对象，那么我们就应该用对象的思想来处理它。 Global模块这个模块的作用和less里的全局变量是一样的，我们把项目使用的色调、字体大小、最细边框、窗口大小等变量暴露给全局的 container 调用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; PixelRatio, Dimensions &#125; from 'react-native'// 全局颜色export const Color = &#123; primary: '#f75a47', // App主色调 white: '#ffffff', // 白色 navBar: '#f9f9f9', // NavBar的背景颜色 text: &#123; // 给文本使用 grey1: '#494949', grey2: '#686868', grey3: '#9B9B9B', grey4: '#B5B5B5', red: '#FC4586', &#125;, bg: &#123; // 背景色 grey1: '#ddd', grey2: '#eee', grey3: '#f7f7f7', red: '#FC4586', pink: '#F984AD', &#125;, border: &#123; // 边框颜色 grey1: '#ddd', grey2: '#eee', grey3: '#f4f4f4', red: '#FC4586', &#125;,&#125;;// 全局字体大小export const Size = &#123; xxsmall: 10, xsmall: 12, small: 14, default: 16, large: 18, xlarge: 20, xxlarge: 24, pixel: 1/PixelRatio.get(), // 最细边框&#125;// 全局Window尺寸export const Window = &#123; width: Dimensions.get('window').width, height: Dimensions.get('window').height,&#125; 然后在 container里，我们可以直接引入。这样的好处是容易做到APP整体样式的统一 1import &#123; Size, Color, Window &#125; from &apos;./global&apos; 样式组合与覆盖以前写Web的时候，为了减少代码量，我们很习惯去编写组件或者单元，这些组件融入到页面里就需要组合特定的样式，或者覆盖一些样式。这一点 ReactNative里也可以做到。我们可以把多个样式对象放在一个数组里使用： 1&lt;View style=&#123;[style1, style2, style3]&#125;&gt;&lt;/View&gt; 看到这里，很多有洁癖的朋友估计会去纠结 应该编写多么小的单元，组合多少次比较合适。其实2次足矣，因为ReactNative天然的组件化特性，让我们可以把组件一层层剖开，我的建议也是多写子组件，合理使用同级之间的组合。 组件化设计技巧ReactNative组件化开发能力浑然天成，语言本身优势明显，至于技巧，我觉得可以体现在下面三个方面： 组件设计模版ReactNative组件其实就是React组件融入了原生App的Native能力。我们可以像写一个React组件一样去设计它，它完全支持ES6＋语法，这是我的书写模版，可供大家参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 导入React核心模块import React, &#123; Component, PropTypes, &#125; from 'react'// 导入组件使用到的Native依赖模块import &#123; View, StyleSheet, Text, TouchableOpacity, &#125; from 'react-native'// 定义并默认导出自己的componentexport default class myComp extends Component &#123; // 入参类型验证 static propTypes = &#123; // 如果类型是style containerStyle: View.propTypes.style, // 如果类型是bool selected: PropTypes.bool, // 如果类型是string text: PropTypes.string, // 如果类型是function onPress: PropTypes.func, // 如果类型是object options: PropTypes.object, // 如果类型是array source: PropTypes.array, // 如果类型是number num: PropTypes.number, &#125; // 入参默认值（不设置则为undefined） static defaultProps = &#123; selected: true, num: 5, &#125; // 构造函数 constructor(props) &#123; // 继承父类的this对象和传入的外部属性 super(props) // 设置初始状态 this.state = &#123; selected: props.selected, num: props.num, source: props.source, &#125; &#125; // 遍历的部分可以写成子渲染函数 _renderList(data) &#123; if (Array.isArray(data)) &#123; // 推荐这种写法 return data.map((item, i) =&gt; &#123; return (&lt;Text key=&#123;i&#125;&gt;&#123;item&#125;&lt;/Text&gt;) &#125;) &#125; &#125; // 事件处理句柄（触发处用匿名函数包裹以匹配当前的上下文对象） handlePress() &#123; // 组件外部传入的回调函数先验证再触发 this.props.onPress &amp;&amp; this.props.onPress() &#125; // 主渲染函数 render() &#123; // 推荐写法 let &#123; selected, num, source &#125; = this.state; let &#123; source, containerStyle &#125; = this.props; return ( &lt;View style=&#123;[styles.container, containerStyle]&#125;&gt; // 匿名函数方式触发回调，避免使用bind &lt;TouchableOpacity onPress=&#123;()=&gt;this.handlePress()&#125;&gt; &lt;Text&gt;Hello World&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;View&gt; &#123; this._renderList(source) &#125; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;// style写在最下面const styles = StyleSheet.create(&#123; container: &#123; flex: 1, &#125;,&#125;) 自成一体, 拒绝依赖在我的架构里，React组件分为components 和 containers。 containers顾名思义是页面的容器，每个App都有独立的一套containers，具有特定的样式和数据输入，无法迁移。 components下面组件都是相互独立的，除了Native和React的核心模块，拒绝任何外部依赖。对于icon素材、内部的子组件等建议用文件夹包裹成一个文件单元，相关的资源文件跟着组件走，让这些组件完全可以脱离具体的App项目独立存在，自成一体，可以随意迁移。（类似Node_module的设计思想） 大家知道，React的组件式开发就好比搭积木，如果我们不断积累并形成了一套完整的组件库，那么以后开发类似的App简直是如有神助。这是多么美妙的一件事！ 属性命名要贴近官方比如点击触发的回调函数，相信大家都有自己的命名习惯：callback、handlePress、cb、onPress……. 我的建议是沿用官方的onPress命名。遵循这条命名规范，是为了组件的推广和国际化做的考虑，建议平时查阅ReactNative官方文档的时候，记忆官方组件的属性命名方式，编写自己组件时候类似的属性名尽量和官方保持一致。 @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"JavaScript异步编程的终极演变","date":"2016-08-15T15:55:15.000Z","path":"2016/08/15/2016-08-15-async/","text":"写在前面有一个有趣的问题： 为什么Node.js约定回调函数的第一个参数必须是错误对象err(如果没有错误，该参数就是null)? 原因是执行回调函数对应的异步操作，它的执行分成两段，这两段之间抛出的错误程序无法捕获，所以只能作为参数传入第二段。大家知道，JavaScript只有一个线程，如果没有异步编辑，复杂的程序基本没法使用。在ES6诞生以前，异步编程的方式大概有下面四种： 回调函数 事件监听 发布/订阅 Promise对象 ES6将JavaScript异步编程带入了一个全新的阶段，ES7中的async函数更是给出了异步编程的终极解决方案。下面将具体讲解异步编程的原理和值得注意的地方，待我细细道来～ 异步编程的演变基本理解所谓异步，简单地说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好准备再回过头执行第二段。 举个例子读取一个文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫作同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数所谓回调函数，就是把任务的第二段单独写在一个函数中，等到重新执行该任务时直接调用这个函数。其英文名字 callback 直译过来就是 “重新调用”的意思。 拿上面的例子讲，读取文件操作是这样的： 123456789fs.readFile(fileA, (err, data) =&gt; &#123; if (err) throw err; console.log(data)&#125;)fs.readFile(fileB, (err, data) =&gt; &#123; if (err) throw err; console.log(data)&#125;) 注意：上面两段代码彼此是异步的，虽然开始执行的顺序是从上到下，但是第二段并不会等到第一段结束才执行，而是并发执行。 那么问题来了，如果想fileB等到fileA读取成功后再开始执行应该怎么处理呢？最简单的办法是通过 回调嵌套： 123456789fs.readFile(fileA, (err, data) =&gt; &#123; if (err) throw err; console.log(data) fs.readFile(fileB, (_err, _data) =&gt; &#123; if (_err) throw err; console.log(_data) &#125;)&#125;) 这种方式我只能容忍个位数字的嵌套，而且它使得代码横向发展，实在是丑的一笔，次数多了根本是没法看。试想万一要同步执行100个异步操作呢？疯掉算了吧！有没有更好的办法呢？ 使用Promise要澄清一点，Promise的概念并不是ES6新出的，而是ES6整合了一套新的写法。同样继续上面的例子，使用Promise代码就变成这样了： 12345678var readFile = require('fs-readfile-promise');readFile(fileA).then((data)=&gt;&#123;console.log(data)&#125;).then(()=&gt;&#123;return readFile(fileB)&#125;).then((data)=&gt;&#123;console.log(data)&#125;)// ... 读取n次.catch((err)=&gt;&#123;console.log(err)&#125;) 注意：上面代码使用了Node封装好的Promise版本的readFile函数，它的原理其实就是返回一个Promise对象，咱也简单地写一个： 123456789101112var fs = require('fs');var readFile = function(path) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;module.export = readFile 但是，Promise的写法只是回调函数的改进，使用then()之后，异步任务的两段执行看得更清楚，除此之外并无新意。撇开优点，Promise的最大问题就是代码冗余，原来的任务被Promise包装一下，不管什么操作，一眼看上去都是一堆then()，原本的语意变得很不清楚。 把酒问苍天，MD还有更好的办法吗？ 使用Generator在引入generator之前，先介绍一下什么叫 协程 “携程在手，说走就走”。哈哈，别混淆了， “协程“ 非 “携程“ 协程所谓 “协程” ，就是多个线程相互协作，完成异步任务。协程有点像函数，又有点像线程。其运行流程大致如下： 第一步： 协程A开始执行 第二步：协程A执行到一半，暂停，执行权转移到协程B 第三步：一段时间后，协程B交还执行权 第四步：协程A恢复执行 12345function asyncJob() &#123; // ... 其他代码 var f = yield readFile(fileA); // ... 其他代码&#125; 上面的aysncJob()就是一个协程，它的奥妙就在于其中的yield命令。它表示执行到此处执行权交给其他协程，换而言之，yield就是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点就是代码的写法非常像同步操作，如果除去 yield命令，简直一模一样。 Generator函数Generator函数是协程在ES6中的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。整个Generator函数就是一个封装的异步任务，或者说就是异步任务的容器。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next() // &#123; value: undefined, done: true &#125; 上面的代码中，调用Generator函数，会返回一个内部指针（即遍历器）g，这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next()方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句。 换而言之，next()方法的作用是分阶段执行Generator函数。每次调用next()方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有一个阶段。 Generator函数的数据交换和错误处理Generator函数可以暂停执行和恢复执行，这是它封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的解决方案：函数体内外的数据交换和错误处理机制。 next()方法返回值的value属性，是Generator函数向外输出的数据；next()方法还可以接受参数，向Generator函数体内输入数据。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125;var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; 上面的代码中，第一个next()方法的value属性，返回表达式x+2的值（3）。第二个next()方法带有参数2，这个参数可以传入Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收，因此这一步的value属性返回的就是2（变量y的值）。 Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 123456789101112function* gen(x) &#123; try &#123; var y = yield x + 2 &#125; catch(e) &#123; console.log(e) &#125; return y&#125;var g = gen(1);g.next();g.throw('出错了'); 上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装 下面看看如何使用Generator函数，执行一个真实的异步任务。 1234567var fetch = require(&apos;node-fetch&apos;)function* gen() &#123; var url = &apos;https://api.github.com/usrs/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125; 上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作。除了加上yield命令。 执行这段代码的方法如下： 12345678var g = gen();var result = g.next();result.value.then(function(data) &#123; return data.json()&#125;).then(function(data) &#123; g.next(data)&#125;); 上面代码中，首先执行Generator函数，获取遍历器对象。然后使用next()方法，执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此需要用then()方法调用下一个next()方法。 可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理却不方便（即合适执行第一阶段，何时执行第二阶段） 大Boss登场之 async函数所谓async函数，其实是Generator函数的语法糖。 继续我们异步读取文件的例子，使用Generator实现 1234567891011121314151617var fs = require('fs');var readFile = (path) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;var gen = function* () &#123; var f1 = yield readFile(fileA); var f2 = yield readFile(fileB); console.log(f1.toString()); console.log(f2.toString());&#125; 写成async函数，就是下面这样： 123456var asyncReadFile = async function() &#123; var f1 = await readFile(fileA); var f2 = await readFile(fileB); console.log(f1.toString()) console.log(f2.toString())&#125; 发现了吧，async函数就是将Generator函数的*替换成了async，将yield替换成await，除此之外，还对 Generator做了以下四点改进： （1）内置执行器。Generator函数的执行比如靠执行器，所以才有了co模块等异步执行器，而async函数是自带执行器的。也就是说：async函数的执行，与普通函数一模一样，只要一行： 1var result = asyncReadFile(); （2）上面的代码调用了asyncReadFile()，就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next()方法，或者使用co模块，才能得到真正执行，从而得到最终结果。 （3）更好的语义。async和await比起星号和yield，语义更清楚。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （4）更广的适用性。async函数的await命令后面可以是Promise对象和原始类型的值（数值、字符串和布尔值，而这是等同于同步操作）。 （5）返回值是Promise，这比Generator函数返回的是Iterator对象方便多了。你可以用then()指定下一步操作。 进一步说，async函数完全可以看作由多个异步操作包装成的一个Promise对象，而await命令就是内部then()命令的语法糖。 实现原理async函数的实现就是将Generator函数和自动执行器包装在一个函数中。如下代码： 1234567891011121314151617181920212223242526272829303132async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function*() &#123; // ... &#125;)&#125;// 自动执行器function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF(); function step(nextF) &#123; try &#123; var next = nextF() &#125; catch(e) &#123; return reject(e) &#125; if (next.done) &#123; return resolve(next.value) &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v) &#125;) &#125;,function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125;) &#125; step(function() &#123; return gen.next(undefined) &#125;) &#125;)&#125; async函数用法（1）async函数返回一个Promise对象，可以是then()方法添加回调函数。（2）当函数执行时，一旦遇到await()就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个延迟输出结果的例子： 12345678910111213function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncPrint(value, ms) &#123; await timeout(ms) console.log(value)&#125;// 延迟500ms后输出 \"Hello World!\"asyncPrint('Hello World!', 500) 注意事项（1）await命令后面的Promise对象，运行结果可能是reject，所以最好把await命令放在try...catch代码块中。 （2）await命令只能用在async函数中，用在普通函数中会报错。 （3）ES6将await增加为保留字。如果使用这个词作为标识符，在ES5中是合法的，但是ES6会抛出 SyntaxError（语法错误）。 终极一战“倚天不出谁与争锋”，上面介绍了一大堆，最后还是让我们通过一个例子来看看 async 函数和Promise、Generator到底谁才是真正的老大吧！ 需求：假定某个DOM元素上部署了一系列的动画，前一个动画结束才能开始后一个。如果当中又一个动画出错就不再往下执行，返回上一个成功执行动画的返回值。 用Promise实现1234567891011121314151617181920212223function chainAnimationsPromise(ele, animations) &#123; // 变量ret用来保存上一个动画的返回值 var ret = null; // 新建一个空的Promise var p = Promise.resolve(); // 使用then方法添加所有动画 for (var anim in animations) &#123; p = p.then(function(val) &#123; ret = val; return anim(ele); &#125;) &#125; // 返回一个部署了错误捕获机制的Promise return p.catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;).then(function() &#123; return ret; &#125;)&#125; 虽然Promise的写法比起回调函数的写法有很大的改进，但是操作本身的语义却变得不太明朗。 用Generator实现12345678910111213function chainAnimationsGenerator(ele, animations) &#123; return spawn(function*() &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = yield anim(ele) &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret; &#125;)&#125; 使用Generator虽然语义比Promise写法清晰不少，但是用户定义的操作全部出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器自动执行Generator函数，它返回一个Promise对象，而且保证yield语句后的表达式返回的是一个Promise。上面的spawn就扮演了这一角色。它的实现如下： 123456789101112131415161718192021function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF(); function step(nextF) &#123; try &#123; var next = nextF() &#125; catch(e) &#123; return reject(e) &#125; if (next.done) &#123; return resolve(next.value) &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v) &#125;) &#125;,function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125;) &#125; step(function() &#123; return gen.next(undefined) &#125;) &#125;)&#125; 使用async实现1234567891011async function chainAnimationAsync(ele, animations) &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = await anim(ele) &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; 好了，光从代码量上就看出优势了吧！简洁又符合语义，几乎没有不相关代码。完胜！ 注意一点：async属于ES7的提案，使用时请通过babel或者regenerator进行转码。 参考阮一峰 《ES6标准入门》 @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"基于Node的React图片上传组件实现","date":"2016-08-11T02:51:50.000Z","path":"2016/08/11/2016-08-11-upload/","text":"写在前面红旗不倒，誓把JavaScript进行到底！今天介绍我的开源项目 Royal 里的图片上传组件的前后端实现原理（React + Node），花了一些时间，希望对你有所帮助。 前端实现遵循React 组件化的思想，我把图片上传做成了一个独立的组件（没有其他依赖），直接import即可。 12345678910import React, &#123; Component &#125; from 'react'import Upload from '../../components/FormControls/Upload/'//......render() &#123; return ( &lt;div&gt;&lt;Upload uri=&#123;'http://jafeney.com:9999/upload'&#125; /&gt;&lt;/div&gt; )&#125; uri 参数是必须传的，是图片上传的后端接口地址，接口怎么写下面会讲到。 渲染页面组件render部分需要体现三个功能： 图片选取（dialog窗口） 可拖拽功能（拖拽容器） 可预览（预览列表） 上传按钮 （button） 上传完成图片地址和链接 （信息列表） 主render函数1234567891011121314151617181920212223242526272829303132333435363738394041render() &#123; return ( &lt;form action=&#123;this.state.uri&#125; method=\"post\" encType=\"multipart/form-data\"&gt; &lt;div className=\"ry-upload-box\"&gt; &lt;div className=\"upload-main\"&gt; &lt;div className=\"upload-choose\"&gt; &lt;input onChange=&#123;(v)=&gt;this.handleChange(v)&#125; type=\"file\" size=&#123;this.state.size&#125; name=\"fileSelect\" accept=\"image/*\" multiple=&#123;this.state.multiple&#125; /&gt; &lt;span ref=\"dragBox\" onDragOver=&#123;(e)=&gt;this.handleDragHover(e)&#125; onDragLeave=&#123;(e)=&gt;this.handleDragHover(e)&#125; onDrop=&#123;(e)=&gt;this.handleDrop(e)&#125; className=\"upload-drag-area\"&gt; 或者将图片拖到此处 &lt;/span&gt; &lt;/div&gt; &lt;div className=&#123;this.state.files.length? \"upload-preview\":\"upload-preview ry-hidden\"&#125;&gt; &#123; this._renderPreview(); // 渲染图片预览列表 &#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&#123;this.state.files.length? \"upload-submit\":\"upload-submit ry-hidden\"&#125;&gt; &lt;button type=\"button\" onClick=&#123;()=&gt;this.handleUpload()&#125; class=\"upload-submit-btn\"&gt; 确认上传图片 &lt;/button&gt; &lt;/div&gt; &lt;div className=\"upload-info\"&gt; &#123; this._renderUploadInfos(); // 渲染图片上传信息 &#125; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; )&#125; 渲染图片预览列表12345678910111213141516171819202122232425_renderPreview() &#123; if (this.state.files) &#123; return this.state.files.map((item, idx) =&gt; &#123; return ( &lt;div className=\"upload-append-list\"&gt; &lt;p&gt; &lt;strong&gt;&#123;item.name&#125;&lt;/strong&gt; &lt;a href=\"javascript:void(0)\" className=\"upload-delete\" title=\"删除\" index=&#123;idx&#125;&gt;&lt;/a&gt; &lt;br/&gt; &lt;img src=&#123;item.thumb&#125; className=\"upload-image\" /&gt; &lt;/p&gt; &lt;span className=&#123;this.state.progress[idx]? \"upload-progress\": \"upload-progress ry-hidden\"&#125;&gt; &#123;this.state.progress[idx]&#125; &lt;/span&gt; &lt;/div&gt; ) &#125;) &#125; else &#123; return null &#125;&#125; 渲染图片上传信息列表123456789101112131415_renderUploadInfos() &#123; if (this.state.uploadHistory) &#123; return this.state.uploadHistory.map((item, idx) =&gt; &#123; return ( &lt;p&gt; &lt;span&gt;上传成功，图片地址是：&lt;/span&gt; &lt;input type=\"text\" class=\"upload-url\" value=&#123;item.relPath&#125;/&gt; &lt;a href=&#123;item.relPath&#125; target=\"_blank\"&gt;查看&lt;/a&gt; &lt;/p&gt; ); &#125;) &#125; else &#123; return null; &#125;&#125; 文件上传前端要实现图片上传的原理就是通过构建FormData对象，把文件对象append()到该对象，然后挂载在XMLHttpRequest对象上 send() 到服务端。 获取文件对象获取文件对象需要借助 input 输入框的 change 事件来获取 句柄参数 e 1onChange=&#123;(e)=&gt;this.handleChange(e)&#125; 然后做以下处理： 12345678910111213e.preventDefault()let target = event.targetlet files = target.fileslet count = this.state.multiple ? files.length : 1for (let i = 0; i &lt; count; i++) &#123; files[i].thumb = URL.createObjectURL(files[i])&#125;// 转换为真正的数组files = Array.prototype.slice.call(files, 0)// 过滤非图片类型的文件files = files.filter(function (file) &#123; return /image/i.test(file.type)&#125;) 这时 files 就是 我们需要的文件对象组成的数组，把它 concat 到原有的 files里。 1this.setState(&#123;files: this.state.files.concat(files)&#125;) 如此，接下来的操作 就可以 通过 this.state.files 取到当前已选中的 图片文件。 利用Promise处理异步上传文件上传对于浏览器来说是异步的，为了处理 接下来的多图上传，这里引入了 Promise来处理异步操作： 1234567891011121314151617181920212223242526272829303132upload(file, idx) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr = new XMLHttpRequest() if (xhr.upload) &#123; // 上传中 xhr.upload.addEventListener(\"progress\", (e) =&gt; &#123; // 处理上传进度 this.handleProgress(file, e.loaded, e.total, idx); &#125;, false) // 文件上传成功或是失败 xhr.onreadystatechange = (e) =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; // 上传成功操作 this.handleSuccess(file, xhr.responseText) // 把该文件从上传队列中删除 this.handleDeleteFile(file) resolve(xhr.responseText); &#125; else &#123; // 上传出错处理 this.handleFailure(file, xhr.responseText) reject(xhr.responseText); &#125; &#125; &#125; // 开始上传 xhr.open(\"POST\", this.state.uri, true) let form = new FormData() form.append(\"filedata\", file) xhr.send(form) &#125;)&#125; 上传进度计算利用XMLHttpRequest对象发异步请求的好处是可以 计算请求处理的进度，这是fetch所不具备的。我们可以为 xhr.upload 对象的 progress 事件添加事件监听： 1234xhr.upload.addEventListener(\"progress\", (e) =&gt; &#123; // 处理上传进度 this.handleProgress(file, e.loaded, e.total, i);&#125;, false) 说明：idx参数是纪录多图上传队列的索引123456handleProgress(file, loaded, total, idx) &#123; let percent = (loaded / total * 100).toFixed(2) + '%'; let _progress = this.state.progress; _progress[idx] = percent; this.setState(&#123; progress: _progress &#125;) // 反馈到DOM里显示&#125; 拖拽上传拖拽文件对于HTML5来说其实非常简单，因为它自带的几个事件监听机制可以直接做这类处理。主要用到的是下面三个： 123onDragOver=&#123;(e)=&gt;this.handleDragHover(e)&#125;onDragLeave=&#123;(e)=&gt;this.handleDragHover(e)&#125;onDrop=&#123;(e)=&gt;this.handleDrop(e)&#125; 取消拖拽时的浏览器行为： 1234handleDragHover(e) &#123; e.stopPropagation() e.preventDefault()&#125; 处理拖拽进来的文件： 1234567891011121314151617handleDrop(e) &#123; this.setState(&#123;progress:[]&#125;) this.handleDragHover(e) // 获取文件列表对象 let files = e.target.files || e.dataTransfer.files let count = this.state.multiple ? files.length : 1 for (let i = 0; i &lt; count; i++) &#123; files[i].thumb = URL.createObjectURL(files[i]) &#125; // 转换为真正的数组 files = Array.prototype.slice.call(files, 0) // 过滤非图片类型的文件 files = files.filter(function (file) &#123; return /image/i.test(file.type) &#125;) this.setState(&#123;files: this.state.files.concat(files)&#125;)&#125; 多图同时上传支持多图上传我们需要在组件调用处设置属性： 12multiple = &#123; true &#125; // 开启多图上传size = &#123; 50 &#125; // 一次最大上传数量（虽没有上限，为保证服务端正常，建议50以下） 然后我们可以使用 Promise.all() 处理异步操作队列： 1234567handleUpload() &#123; let _promises = this.state.files.map((file, idx) =&gt; this.upload(file, idx)) Promise.all(_promises).then( (res) =&gt; &#123; // 全部上传完成 this.handleComplete() &#125;).catch( (err) =&gt; &#123; console.log(err) &#125;)&#125; 好了，前端工作已经完成，接下来就是Node的工作了。 后端实现为了方便，后端采用的是express框架来快速搭建Http服务和路由。具体项目见我的github node-image-upload。逻辑虽然简单，但还是有几个可圈可点的地方： 跨域调用本项目后端采用的是express，我们可以通过 res.header() 设置 请求的 “允许源” 来允许跨域调用： 1res.header('Access-Control-Allow-Origin', '*'); 设置为 * 说明允许任何 访问源，不太安全。建议设置成 你需要的 二级域名，如 jafeney.com。 除了 “允许源” ，其他还有 “允许头” 、”允许域”、 “允许方法”、”文本类型” 等。常用的设置如下： 1234567function allowCross(res) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); res.header(\"X-Powered-By\",' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\");&#125; ES6下的Ajax请求ES6风格下的Ajax请求和ES5不太一样，在正式的请求发出之前都会先发一个 类型为 OPTIONS的请求 作为试探，只有当该请求通过以后，正式的请求才能发向服务端。 所以服务端路由 我们还需要 处理这样一个 请求： 12345678router.options('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS'); res.header(\"X-Powered-By\",' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;); 注意：该请求同样需要设置跨域。 处理上传处理上传的图片引人了multiparty模块，用法很简单： 12345678910111213141516171819/*使用multiparty处理上传的图片*/router.post('/upload', function(req, res, next) &#123; // 生成multiparty对象，并配置上传目标路径 var form = new multiparty.Form(&#123;uploadDir: './public/file/'&#125;); // 上传完成后处理 form.parse(req, function(err, fields, files) &#123; var filesTmp = JSON.stringify(files, null, 2); var relPath = ''; if (err) &#123; // 保存失败 console.log('Parse error: ' + err); &#125; else &#123; // 图片保存成功！ console.log('Parse Files: ' + filesTmp); // 图片处理 processImg(files); &#125; &#125;);&#125;); 图片处理Node处理图片需要引入 gm 模块，它需要用 npm 来安装： 1npm install gm --save BUG说明注意：node的图形操作gm模块前使用必须 先安装 imagemagick 和 graphicsmagick，Linux (ubuntu)上使用apt-get 安装： 12sudo apt-get install imagemagicksudo apt-get install graphicsmagick --with-webp // 支持webp格式的图片 MacOS上可以用 Homebrew 直接安装： 12brew install imagemagickbrew install graphicsmagick --with-webp // 支持webp格式的图片 预设尺寸有些时候除了原图，我们可能需要把原图等比例缩小作为预览图或者缩略图。这个异步操作还是用Promise来实现： 12345678910111213141516function reSizeImage(paths, dstPath, size) &#123; return new Promise(function(resolve, reject) &#123; gm(dstPath) .noProfile() .resizeExact(size) .write('.' + paths[1] + '@' + size + '00.' + paths[2], function (err) &#123; if (!err) &#123; console.log('resize as ' + size + ' ok!') resolve() &#125; else &#123; reject(err) &#125;; &#125;); &#125;);&#125; 重命名图片为了方便排序和管理图片，我们按照 “年月日 ＋ 时间戳 + 尺寸” 来命名图片： 12var _dateSymbol = new Date().toLocaleDateString().split('-').join('');var _timeSymbol = new Date().getTime().toString(); 至于图片尺寸 使用 gm的 size() 方法来获取，处理方式如下： 1234567891011121314151617gm(uploadedPath).size(function(err, size) &#123; var dstPath = './public/file/' + _dateSymbol + _timeSymbol + '_' + size.width + 'x' + size.height + '.' + _img.originalFilename.split('.')[1]; var _port = process.env.PORT || '9999'; relPath = 'http://' + req.hostname + ( _port!==80 ? ':' + _port : '' ) + '/file/' + _dateSymbol + _timeSymbol + '_' + size.width + 'x' + size.height + '.' + _img.originalFilename.split('.')[1]; // 重命名 fs.rename(uploadedPath, dstPath, function(err) &#123; if (err) &#123; reject(err) &#125; else &#123; console.log('rename ok!'); &#125; &#125;);&#125;); 总结对于大前端的工作，理解图片上传的前后端原理仅仅是浅层的。我们的口号是 “把JavaScript进行到底！”，现在无论是 ReactNative的移动端开发，还是NodeJS的后端开发，前端工程师可以做的工作早已不仅仅是局限于web页面，它已经渗透到了互联网应用层面的方方面面，或许，叫 全栈工程师 更为贴切吧。 当然，全栈 两个字的分量很重，不积跬步，无以至千里，功力低下的我还需要不断修炼和实践！ 参考张鑫旭 《基于HTML5的可预览多图片Ajax上传》 @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"},{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"node","slug":"node","permalink":"http://jafeney.com/tags/node/"}]},{"title":"深入理解React中的上下文this","date":"2016-07-19T06:12:14.000Z","path":"2016/07/19/2016-07-19-this/","text":"写在前面JavaScript中的作用域scope 和上下文 context 是这门语言的独到之处，每个函数有不同的变量上下文和作用域。这些概念是JavaScript中一些强大的设计模式的后盾。在ES5规范里，我们可以遵循一个原则——每个function内的上下文this指向该function的调用方。比如： 1234567891011121314var Module = &#123; name: &apos;Jafeney&apos;, first: function() &#123; console.log(this); // this对象指向调用该方法的Module对象 var second = (function() &#123; console.log(this) // 由于变量提升，this对象指向Window对象 &#125;)() &#125;, init: function() &#123; this.first() &#125;&#125;Module.init() 但是，在ES6规范中，出现了一个逆天的箭头操作符 =&gt; ，它可以替代原先ES5里function的作用，快速声明函数。那么，在没有了function关键字，箭头函数内部的上下文this是怎样一种情况呢？ ES6中的箭头函数在阮一峰老师的《ECMAScript 6 入门》 中，对箭头函数的做了如下介绍： 箭头函数的基本介绍ES6允许使用“箭头”=&gt; 定义函数。12345var f = v =&gt; v;//上面的箭头函数等同于：var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 12345678var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回（重要） 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号（重要）。 1var getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 箭头函数可以与变量解构结合使用。 12345const full = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;// 等同于function full(person) &#123; return person.first + &apos; &apos; + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 箭头函数使用注意点（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 this指向固定化ES5规范中，this对象的指向是可变的，但是在ES6的箭头函数中，它却是固定的。 123456789function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // 输出 id: 42 注意：上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数的原理this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以，箭头函数转成ES5的代码如下： 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log(&apos;id:&apos;, _this.id); &#125;, 100);&#125; 上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 两道经典的面试题1234567891011121314151617// 请问下面有几个thisfunction foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // 输出 id: 1var t2 = f().call(&#123;id: 3&#125;)(); // 输出 id: 1var t3 = f()().call(&#123;id: 4&#125;); // 输出 id: 1 上面代码之中，其实只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。另外，由于箭头函数没有自己的this，所以也不能用call()、apply()、bind()这些方法去改变this的指向。 1234567// 请问下面代码执行输出什么(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;); 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。所以上面的代码最终输出 [&#39;outer&#39;]。 函数绑定 ::箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 1234567891011121314// 例一import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x));// 例二let &#123; find, html &#125; = jake;document.querySelectorAll(&quot;div.myClass&quot;)::find(&quot;p&quot;)::html(&quot;hahaha&quot;); React中的各种this目前React的编写风格已经全面地启用了ES6和部分ES7规范，所以很多ES6的坑在React里一个个浮现了。本篇重点介绍 this，也是近期跌得最疼的一个。 Component方法内部的this还是用具体的例子来解释吧，下面是我 Royal 项目里一个Table组件（Royal正在开发中，欢迎fork贡献代码 ^_^） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React, &#123; Component &#125; from &apos;react&apos;import Checkbox from &apos;../../FormControls/Checkbox/&apos;import &apos;./style.less&apos;class Table extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; dataSource: props.dataSource || [], columns: props.columns || [], wrapClass: props.wrapClass || null, wrapStyle: props.wrapStyle || null, style: props.style || null, className: props.className || null, &#125; this.renderRow = props.renderRow || null &#125; onSelectAll() &#123; for (let ref in this.refs) &#123; if (ref!==&apos;selectAll&apos;) &#123; this.refs[ref].setState(&#123;checked:true&#125;) &#125; &#125; &#125; offSelectAll() &#123; for (let ref in this.refs) &#123; if (ref!==&apos;selectAll&apos;) &#123; this.refs[ref].setState(&#123;checked:false&#125;) &#125; &#125; &#125; _renderHead() &#123; return this.state.columns.map((item,i) =&gt; &#123; return [&lt;th&gt;&#123;i===0?&lt;Checkbox ref=&quot;selectAll&quot; onConfirm=&#123;()=&gt;this.onSelectAll()&#125; onCancel=&#123;()=&gt;this.offSelectAll()&#125; /&gt;:&apos;&apos;&#125;&#123;item.title&#125;&lt;/th&gt;] &#125;) &#125; _renderBody() &#123; let _renderRow = this.renderRow; return this.state.dataSource.map((item) =&gt; &#123; return _renderRow &amp;&amp; _renderRow(item) &#125;) &#125; render() &#123; let state = this.state; return ( &lt;div className=&#123;state.wrapClass&#125; style=&#123;state.wrapStyle&#125;&gt; &lt;table border=&quot;0&quot; style=&#123;state.style&#125; className=&#123;&quot;ry-table &quot; + (state.className &amp;&amp; state.className : &quot;&quot;)&#125;&gt; &lt;thead&gt; &lt;tr&gt;&#123;this._renderHead()&#125;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;this._renderBody()&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; ) &#125;&#125;export default Table Component是React内的一个基类，用于继承和创建React自定义组件。ES6规范下的面向对象实现起来非常精简，class关键字 可以快速创建一个类，而Component类内的所有属性和方法均可以通过this访问。换而言之，在Component内的任意方法内，可以通过this.xxx的方式调用该Component的其他属性和方法。 接着分析上面的代码，寥寥几行实现的是对一个Table组件的封装，借鉴了ReactNative组件的设计思路，通过外部传递dataSource（数据源）、columns（表格的表头项）、renderRow（当行渲染的模板函数）来完成一个Table的构建，支持全选和取消全选的功能、允许外部传递className和style对象来修改样式。 从这个例子我们可以发现：只要不采用function定义函数，Component所有方法内部的this对象始终指向该类自身。 container调用component时传递的this还是继续上面的例子，下面在一个做为Demo的container里调用之前 的Table。 1import Table from &apos;../../components/Views/Table/&apos; 接着编写renderRow函数并传递给Table组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576_renderRow(row) &#123; // ------------ 注意：这里对callback函数的写法 ----------- let onEdit = (x)=&gt; &#123; console.log(x+x) &#125;, onDelete = (x)=&gt; &#123; console.log(x*x) &#125; // --------------------------------------------------- return ( &lt;tr&gt; &lt;td&gt;&lt;Checkbox ref=&#123;&quot;item_&quot; + row.key&#125; /&gt;&#123;row.key&#125;&lt;/td&gt; &lt;td&gt;&#123;row.name&#125;&lt;/td&gt; &lt;td&gt;&#123;row.age&#125;&lt;/td&gt; &lt;td&gt;&#123;row.birthday&#125;&lt;/td&gt; &lt;td&gt;&#123;row.job&#125;&lt;/td&gt; &lt;td&gt;&#123;row.address&#125;&lt;/td&gt; &lt;td&gt; &lt;Button type=&quot;primary&quot; callback=&#123;()=&gt;onEdit(row.key)&#125; text=&quot;编辑&quot; /&gt; &lt;Button type=&quot;secondary&quot; callback=&#123;()=&gt;onDelete(row.key)&#125; text=&quot;删除&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; ) &#125;//... 省略一大堆代码render() &#123; let dataSource = [&#123; key: &apos;1&apos;, name: &apos;胡彦斌&apos;, age: 32, birthday: &apos;2016-12-29&apos;, job: &apos;前端工程师&apos;, address: &apos;西湖区湖底公园1号&apos; &#125;, &#123; key: &apos;2&apos;, name: &apos;胡彦祖&apos;, age: 42, birthday: &apos;2016-12-29&apos;, job: &apos;前端工程师&apos;, address: &apos;西湖区湖底公园1号&apos; &#125;],columns = [&#123; title: &apos;编号&apos;, dataIndex: &apos;key&apos;, key: &apos;key&apos;, &#125;,&#123; title: &apos;姓名&apos;, dataIndex: &apos;name&apos;, key: &apos;name&apos;, &#125;, &#123; title: &apos;年龄&apos;, dataIndex: &apos;age&apos;, key: &apos;age&apos;, &#125;, &#123; title: &apos;生日&apos;, dataIndex: &apos;birthday&apos;, key: &apos;birthday&apos;, &#125;, &#123; title: &apos;职务&apos;, dataIndex: &apos;job&apos;, key: &apos;job&apos;, &#125;,&#123; title: &apos;住址&apos;, dataIndex: &apos;address&apos;, key: &apos;address&apos;, &#125;, &#123; title: &apos;操作&apos;, dataIndex: &apos;operate&apos;, key: &apos;operate&apos;, &#125;]; return ( &lt;div&gt; &lt;Table dataSource=&#123;dataSource&#125; columns=&#123;columns&#125; renderRow=&#123;this._renderRow&#125;/&gt; &lt;/div&gt; );&#125; 显示效果如下： 分析上面的代码，有几处容易出错的地方： （1）_renderRow 作为component的方法来定义，然后在对应的render函数内通过this来调用。很重要的一点，这里this._renderRow作为的是函数名方式传递。 （2）_renderRow 内部Button组件的callback是按钮点击后触发的回调，也是一个函数，但是这个函数没有像上面一样放在component的方法里定义，而是作为一个变量定义并通过匿名函数的方式传递给子组件： 123456let onEdit = (x)=&gt; &#123; console.log(x+x)&#125;// .....callback=&#123;()=&gt;onEdit(row.key)&#125; 这样就避开了使用this时上下文变化的问题。这一点是很讲究的，如果沿用上面的写法很容易这样写： 1234567onEdit(x) &#123; console.log(x+x)&#125;// ...callback=&#123;()=&gt;this.onEdit(row.key)&#125; 但是很遗憾，这样写this传递到子组件后会变成undefined，从而报错。 （3）父组件如要调用子组件的方法，有两种方式： 第一种 通过匿名函数的方式 1callback = &#123;()=&gt;this.modalShow()&#125; 第二种 使用 bind 1callback = &#123;this.modalShow.bind(this)&#125; 注意：如果要绑定的函数需要传参数，可以这么写： xxx.bind(this,arg1,arg2...) 参考 《ECMAScript 6 入门》 @欢迎关注我的 github 和 个人博客 －Jafeney","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"fetch和XMLHttpRequest讲解","date":"2016-07-17T06:47:41.000Z","path":"2016/07/17/2016-07-17-fetch/","text":"写在前面fetch 同 XMLHttpRequest 非常类似，都是用来做网络请求。但是同复杂的XMLHttpRequest的API相比，fetch使用了Promise，这让它使用起来更加简洁，从而避免陷入”回调地狱”。 两者比较比如，如果我们想要实现这样一个需求：请求一个URL地址，获取响应数据并将数据转换成JSON格式。使用fetch和XMLHttpRequest实现的方式是不同的。 使用XMLHttpRequest实现使用XMLHttpRequest来实现改功能需要设置两个监听函数，分别用来处理成功和失败的情况，同时还需要依次调用open()和send()方法才能实现请求。 1234567891011121314function reqListener() &#123; var data = JSON.parse(this.responseText); console.log(data);&#125;function reqError(err) &#123; console.log('Fetch Error : %S', err);&#125;var oReq = new XMLHttpRequest();oReq.onload = reqListener;oReq.onerror = reqError;oReq.open('get', './api/some.json', true);oReq.send(); 使用fetch实现使用fetch来实现是这样的： 123456789101112131415fetch('./api/some.json') .then(function(res) &#123; if (res.status !== 200) &#123; console.log('Looks like there was a problem. Status Code: ' + res.status); return; &#125; // 处理响应中的文本信息 res.json().then(function(data) &#123; console.log(data); &#125;); &#125;) .catch(function(err) &#123; console.log('Fetch Error : %S', err); &#125;) 在将响应的文本信息转换成JSON格式前，需要先确保响应的状态码为200。fetch()请求后返回的响应是一个stream对象，这就意味着我们在调用json()方法后会返回一个Promise，因为读取stream的过程是异步操作的。 响应中的元数据在上面的例子中，我们可以查看响应对象的状态码，也知道了如何将响应转换成JSON格式的数据。但其实我们可以访问的元数据还有以下这些： 123456789fetch(\"users.json\").then(function(res) &#123; console.log(res.headers.get('Content-Type')); console.log(res.headers.get('Data')); console.log(res.status); console.log(res.statusText); console.log(res.type); console.log(res.url);&#125;) 响应类型当我们发送fetch请求时，返回的res.type可能是basic、cors或opaque中的一种。这些类型可以告知我们资源从何而来，这样就能知道该如何处理响应对象。 当我们请求的是同一域下的资源时，响应返回的类型为basic，此时没有任何限制，我们可以查看响应中的任何数据。 如何请求的是跨域资源，那么会返回一个CORS类型的头部，并且响应类型为cors。这种类型跟上面的basic非常相似，只是它对响应头部的字段访问有限制，你只可以访问这些属性： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma Opaque 类型的响应也是访问跨域资源的时候产生的，只是响应头不是CORS类型的响应头而已。如果是这种类型的响应，那么我们就不能读取返回的数据，也不能查看请求的状态码，这就是意味着我们将无法确定请求是成功了还是失败了。目前在fetch()的实现中，无法请求跨域的资源。 我们可以为fetch请求定义mode属性，来保证只有符合条件的请求才会被处理。可以设置的mode属性值如下： same-origin 只有请求相同域下的资源才能成功，其他请求均被拒绝。 cors 允许请求同域或者跨域资源，但是跨域必须返回相应的跨域请求头部。 cors-with-forced-preflight 在发出实际请求前先做preflight检查。 no-cors 针对跨域资源做请求，但是不返回CORS的响应头，这是属于opaque类型的响应（window下无法使用） 在使用mode时，需要将fetch请求的第二个参数作为配置对象，并在其中配置具体的模式，如下代码： 12345678910fetch(\"http://some-site.com/cors-enabled/some.json\",&#123;mode: 'cors'&#125;) .then(function(res)&#123; return res.text(); &#125;) .then(function(text) &#123; console.log('Request successfully', text); &#125;) .catch(function(err) &#123; console.log('Request failed', error) &#125;) Promise 方法链Promise 的特性之一就是可以实现链式调用，fetch也可以使用该特性，同时，使用链式调用可以让请求的处理逻辑更加通用。 如果使用接口反馈的JSON格式数据，那么针对每次响应，我们都需要检查响应状态并做JSON格式转换。其实还能简化代码，那就是把状态监测和JSON转换的代码放到单独的函数中去。比如： 123456789101112131415161718192021function status(res) &#123; if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) &#123; return Promise.resolve(response) &#125; else &#123; return Promise.reject(new Error(res.statusText)) &#125;&#125;function json(res) &#123; return res.json()&#125;fetch('user.json') .then(status) .then(json) .then(function(data) &#123; console.log('Request succeeded with JSON response', data); &#125;) .catch(function(err) &#123; console.log('Request failed', error); &#125;) 在上面的代码中，我们定义了一个status方法来检查response.status 的状态，根据结果不同返回Promise.resolve() 或 Promise.reject() ，这是fetch()方法链中的第一个方法调用。如果返回resolve状态，我们会继续调用json()，从而返回response.json()的执行结果。经过这些处理完我们已经可以获取解析后的JSON对象。如果解析失败，Promise返回reject状态，执行catch里的代码进行错误处理。 这么编码更大的好处在于，你可以在所有的fetch请求中使用上面的逻辑代码，从而让代码变得更加容易阅读、维护和测试。 使用fetch 请求发送凭证信息如果我们想在fetch请求中带一些凭证信息，比如cookie等，我们应该将请求中的credentials设置为include： 123fetch(url, &#123; credentials: 'include'&#125;) 注意： 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 Response相关属性及方法bodyUsed 标记返回值是否被使用过 这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。 12345678910fetch('/test/content.json').then(function(res)&#123; console.log(res.bodyUsed); // false var data = res.json(); console.log(res.bodyUsed); //true return data;&#125;).then(function(data)&#123; console.log(data);&#125;).catch(function(error)&#123; console.log(error);&#125;); headers返回Headers对象，该对象实现了Iterator，可通过for…of遍历 123456789101112131415161718192021fetch('/test/content.json').then(function(res)&#123; var headers = res.headers; console.log(headers.get('Content-Type')); // application/json console.log(headers.has('Content-Type')); // true console.log(headers.getAll('Content-Type')); // [\"application/json\"] for(let key of headers.keys())&#123; console.log(key); // datelast-modified server accept-ranges etag content-length content-type &#125; for(let value of headers.values())&#123; console.log(value); &#125; headers.forEach(function(value, key, arr)&#123; console.log(value); // 对应values()的返回值 console.log(key); // 对应keys()的返回值 &#125;); return res.json();&#125;).then(function(data)&#123; console.log(data);&#125;).catch(function(error)&#123; console.log(error);&#125;); ok 是否正常返回 代表状态码在200-299之间 status状态码( 200表示 成功) statusText状态描述 (‘OK’表示 成功) type basic：正常的，同域的请求，包含所有的headers。排除Set-Cookie和Set-Cookie2。 cors：Response从一个合法的跨域请求获得，一部分header和body可读。 error：网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。 opaque： Response从&quot;no-cors&quot;请求了跨域资源。依靠Server端来做限制。 url返回完整的url字符串。如：’http://xxx.com/xx?a=1‘ arrayBuffer()返回ArrayBuffer类型的数据的Promise对象 blob()返回Blob类型的数据的Promise对象 clone() 生成一个Response的克隆 body只能被读取一次，但clone方法就可以得到body的一个备份 克隆体仍然具有bodyUsed属性，如果被使用过一次，依然会失效 1234567891011fetch('/test/content.json').then(function(data)&#123; var d = data.clone(); d.text().then(function(text)&#123; console.log(JSON.parse(text)); &#125;); return data.json();&#125;).then(function(data)&#123; console.log(data);&#125;).catch(function(error)&#123; console.log(error);&#125;); json()返回JSON类型的数据的Promise对象 text()返回Text类型的数据的Promise对象 formData()返回FormData类型的数据的Promise对象 fetch基本用法get方式1234567fetch('/test/content.json').then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; console.log(data);&#125;).catch(function(error)&#123; console.log(error);&#125;); post方式123456789101112131415fetch('/test/content.json', &#123; // url: fetch事实标准中可以通过Request相关api进行设置 method: 'POST', mode: 'same-origin', // same-origin|no-cors（默认）|cors credentials: 'include', // omit（默认，不带cookie）|same-origin(同源带cookie)|include(总是带cookie) headers: &#123; // headers: fetch事实标准中可以通过Header相关api进行设置 'Content-Type': 'application/x-www-form-urlencoded' // default: 'application/json' &#125;, body: 'a=1&amp;b=2' // body: fetch事实标准中可以通过Body相关api进行设置&#125;).then(function(res)&#123; res: fetch事实标准中可以通过Response相关api进行设置 return res.json();&#125;).then(function(data)&#123; console.log(data);&#125;).catch(function(error)&#123;&#125;); fetch不足之处无法监控读取进度和中断请求Promises缺少了一些重要的XMLHttpRequest的使用场景。例如， 使用标准的ES6 Promise你无法收集进入信息或中断请求。而Fetch的狂热开发者更是试图提供Promise API的扩展用于取消一个Promise。 这个提议有点自挖墙角的意思，因为将这将让Promise变得不符合标准。但这个提议或许会导致未来出现一个可取消的Promise标准。 但另一方面，使用XMLHttpRequest你可以模拟进度（监听progress事件），也可以取消请求（使用abort()方法）。 但是，如果有必要你也可以使用Promise来包裹它 浏览器支持目前Chrome 42+, Opera 29+, 和Firefox 39+都支持Fetch。微软也考虑在未来的版本中支持Fetch。 讽刺的是，当IE浏览器终于微响应实现了progress事件的时候，XMLHttpRequest也走到了尽头。 目前，如果你需要支持IE的话，你需要使用一个polyfill库。 @参考 深入浅出Fetch API","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"如何十倍提高你的webpack构建效率","date":"2016-07-10T09:28:38.000Z","path":"2016/07/10/2016-07-10-webpack/","text":"前言webpack 是个好东西，和 NPM 搭配起来使用管理模块实在非常方便。而 Babel 更是神一般的存在，让我们在这个浏览器尚未全面普及 ES6 语法的时代可以先一步体验到新的语法带来的便利和效率上的提升。在 React 项目架构中这两个东西基本成为了标配，但 commonjs 的模块必须在使用前经过 webpack 的构建(后文称为 build)才能在浏览器端使用，而每次修改也都需要重新构建（后文称为 rebuild）才能生效，如何提高 webpack 的构建效率成为了提高开发效率的关键之一。 Webpack 的构建流程在开始正式的优化之前，让我们先回顾一下 Webpack 的构建流程，有哪些关键步骤，只有了解了这些，我们才能分析出哪些地方有优化的可能性。 首先，我们来看看官方对于 Webpack 的理念阐释，webapck 把所有的静态资源都看做是一个 module，通过 webpack，将这些 module 组成到一个 bundle 中去，从而实现在页面上引入一个 bundle.js，来实现所有静态资源的加载。所以详细一点看，webpack 应该是这样的： 通过 loader，webpack 可以把各种非原生 js 的静态资源转换成 JavaScript，所以理论上任何一种静态资源都可以成为一个 module。当然 webpack 还有很多其他好玩的特性，但不是本文的重点因此不铺开进行说明了。了解了上述的过程，我们就可以根据这些过程的前后处理进行对应的优化，接下来我们会针对 build 和 rebuild 的过程给与相应的意见。 RESOLVE我们先从解析模块路径和分析依赖讲起，有人可能觉得这无所谓，但当项目应用依赖的模块越来越多，越来越重时，项目越来越大，文件和文件夹越来越多时，这个过程就变得越来越关乎性能。 减小 Webpack 覆盖的范围 build +, rebuild + webpack 默认会去寻找所有 resolve.root 下的模块，但是有些目录我们是可以明确告知 webpack 不要管这里，从而减轻 webpack 的工作量。这时会用到 module.noParse 参数。 Resolove.root VS Resolove.moduledirectories build +, rebuild + root 和 moduledirectories 如果只从用法上来看，似乎是可以互相替代的。但因为 moduledirectories 从设计上是取相对路径，所以比起 root ，所以会多 parse 很多路径。 123456789resolve: &#123; root: path.resolve(&apos;src&apos;), modulesDirectories: [&apos;node_modules&apos;], extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]&#125;,resolve: &#123; modulesDirectories: [&apos;node_modules&apos;, &apos;./src&apos;], extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]&#125;, 上面的配置，只会解析 : 1/some/src/other/folder/node_modules/a 而下面的配置会解析 : 12345678/some/folder/structure/node_modules/a/some/folder/structure/src/a/some/folder/node_modules/a/some/folder/src/a/some/node_modules/a/some/src/a/node_modules/a/src/a 大部分的情况下使用 root 即可，只有在有很复杂的路径下，才考虑使用 moduledirectories，这可以明显提高 webpack 的构建性能。这个 issue 也很详细地讨论了这个问题。 LOADERSwebpack 官方和社区为我们提供了各种各样 loader 来处理各种类型的文件，这些 loader 的配置也直接影响了构建的性能。 Babel-loader: 能者少劳 build ++, rebuild ++ 以 babel-loader 为例，我们在开发 React 项目时很可能会使用到了 ES6 或者 jsx 的语法，因此使用到 babel-loader 的情况很多，最简单的情况下我们可以这样配置，让所有的 js/jsx 通过 babel-loader： 1234567891011module: &#123; loaders: [ &#123; test: /\\.js(x)*$/, loader: &apos;babel-loader&apos;, query: &#123; presets: [&apos;react&apos;, &apos;es2015-ie&apos;, &apos;stage-1&apos;] &#125; &#125; ]&#125; 上面这样的做法当然是 ok 的，但是对于很多的 npm 包来说，他们完全没有经过 babel 的必要（成熟的 npm 包会在发布前将自己 es5，甚至 es3 化），让这些包通过 babel 会带来巨大的性能负担，毕竟 babel6 要经过几十个插件的处理，虽然 babel-loader 强大，但能者多劳的这种保守的想法却使得 babel-loader 成为了整个构建的性能瓶颈。所以我们可以使用 exclude，大胆地屏蔽掉 npm 里的包，从而使整包的构建效率飞速提高。 12345678910111213141516module: &#123; loaders: [ &#123; test: /\\.js(x)*$/, loader: &apos;babel-loader&apos;, exclude: function(path) &#123; // 路径中含有 node_modules 的就不去解析。 var isNpmModule = !!path.match(node_modules/); return isNpmModule; &#125;, query: &#123; presets: [&apos;react&apos;, &apos;es2015-ie&apos;, &apos;stage-1&apos;] &#125; &#125; ]&#125; 甚至，在我们十分确信的情况下，使用 include 来限定 babel 的使用范围，进一步提高效率。 12345678910111213141516171819var path = require(&apos;path&apos;); module.exports = &#123; module: &#123; loaders: [ &#123; test: /\\.js(x)*$/, loader: &apos;babel-loader&apos;, include: [ // 只去解析运行目录下的 src 和 demo 文件夹 path.join(process.cwd(), &apos;./src&apos;), path.join(process.cwd(), &apos;./demo&apos;) ], query: &#123; presets: [&apos;react&apos;, &apos;es2015-ie&apos;, &apos;stage-1&apos;] &#125; &#125; ] &#125;&#125; PLUGINSwebpack 官方和社区为我们提供了很多方便的插件，有些插件为我们开发和生产带来了很多的便利，但是不合适地使用插件也会拖慢 webpack 的构建效率，而有些插件虽然不会为我们的开发上直接提供便利，但使用他们却可以帮助我们提高 webpack 的构建效率，这也是本文会提到的。 SourceMaps build + SourceMaps 是一个非常实用的功能，可以让我们在 chrome debug 时可以不用直接看已经 bundle 过的 js，而是直接在源代码上进行查看和调试，但完美的 SourceMaps 是很慢的，webpack 官方提供了七种 sourceMap 模式共大家选择，性能对比如下： devtool build speed rebuild speed production supported quality eval +++ +++ no generated code cheap-eval-source-map + ++ no transformed code (lines only) cheap-source-map + o yes transformed code (lines only) cheap-module-eval-source-map o ++ no original source (lines only) cheap-module-source-map o - yes original source (lines only) eval-source-map – + no original source source-map – – yes original source 具体各自的区别请参考 https://github.com/webpack/docs/wiki/configuration#devtool ，我们这里推荐使用 cheap-source-map，也就是去掉了column mapping 和 loader-sourceMap（例如 jsx to js） 的 sourceMap，虽然带上 eval 参数的可以快更多，但是这种 sourceMap 只能看，不能调试，得不偿失。 OPTIMIZATION build ++，rebuild ++ webpack 提供了一些可以优化浏览器端性能的优化插件，如UglifyJsPlugin，OccurrenceOrderPlugin 和 DedupePlugin，都很实用，也都在消耗构建性能（UglifyJsPlugin 非常耗性能），如果你是在开发环境下，这些插件最好都不要使用，毕竟脚本大一些，跑的慢一些这些比起每次构建要耗费更多时间来说，显然还是后者更会消磨开发者的耐心，因此，只在正产环境中使用 OPTIMIZATION。 CommonsChunk rebuild + 当你的 webpack 构建任务中有多个入口文件，而这些文件都 require 了相同的模块，如果你不做任何事情，webpack 会为每个入口文件引入一份相同的模块，显然这样做，会使得相同模块变化时，所有引入的 entry 都需要一次 rebuild，造成了性能的浪费，CommonsChunkPlugin 可以将相同的模块提取出来单独打包，进而减小 rebuild 时的性能消耗。这里有一篇很通俗易懂的使用方法：http://webpack.toobug.net/zh-cn/chapter3/common-chunks-plugin.html ，感兴趣的朋友不妨一试。 DLL &amp; DllReference build +++, rebuild +++ 除了正在开发的源代码之外，通常还会引入很多第三方 NPM 包，这些包我们不会进行修改，但是仍然需要在每次 build 的过程中消耗构建性能，那有没有什么办法可以减少这些消耗呢？DLLPlugin 就是一个解决方案，他通过前置这些依赖包的构建，来提高真正的 build 和 rebuild 的构建效率。 鉴于现有的资料对于这两个插件的解释都不是很清楚，笔者这里翻译了一篇日本同学的文章，通过一个简单的例子来说明一下这两个插件的用法。我们举例，把 react 和 react-dom 打包成为 dll bundle。 首先，我们来写一个 DLLPlugin 的 config 文件。 webpack.dll.config.js 12345678910111213141516171819202122232425262728293031323334const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &#123; vendor: [&apos;react&apos;, &apos;react-dom&apos;] &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;[name].dll.js&apos;, /** * output.library * 将会定义为 window.$&#123;output.library&#125; * 在这次的例子中，将会定义为`window.vendor_library` */ library: &apos;[name]_library&apos; &#125;, plugins: [ new webpack.DllPlugin(&#123; /** * path * 定义 manifest 文件生成的位置 * [name]的部分由entry的名字替换 */ path: path.join(__dirname, &apos;dist&apos;, &apos;[name]-manifest.json&apos;), /** * name * dll bundle 输出到那个全局变量上 * 和 output.library 一样即可。 */ name: &apos;[name]_library&apos; &#125;) ]&#125;; 执行 webpack 后，就会在 dist 目录下生成 dll bundle 和对应的 manifest 文件 123456789101112$ ./node_modules/.bin/webpack --config webpack.dll.config.jsHash: 36187493b1d9a06b228d Version: webpack 1.13.1 Time: 860ms Asset Size Chunks Chunk Namesvendor.dll.js 699 kB 0 [emitted] vendor [0] dll vendor 12 bytes &#123;0&#125; [built] + 167 hidden modules$ ls dist./ vendor-manifest.json../ vendor.dll.js manifest 文件的格式大致如下，由包含的 module 和对应的 id 的键值对构成。 123456789101112cat dist/vendor-manifest.json &#123; &quot;name&quot;: &quot;vendor_library&quot;, &quot;content&quot;: &#123; &quot;./node_modules/react/react.js&quot;: 1, &quot;./node_modules/react/lib/React.js&quot;: 2, &quot;./node_modules/process/browser.js&quot;: 3, &quot;./node_modules/object-assign/index.js&quot;: 4, &quot;./node_modules/react/lib/ReactChildren.js&quot;: 5, &quot;./node_modules/react/lib/PooledClass.js&quot;: 6, &quot;./node_modules/fbjs/lib/invariant.js&quot;: 7,... 好，接下来我们通过 DLLReferencePlugin 来使用刚才生成的 DLL Bundle。 首先我们写一个只去 require react，并通过 console.log 吐出的 index.js。 1234var React = require(&apos;react&apos;); var ReactDOM = require(&apos;react-dom&apos;); console.log(&quot;dll&apos;s React:&quot;, React); console.log(&quot;dll&apos;s ReactDOM:&quot;, ReactDOM); 再写一个不参考 Dll Bundle 的普通 webpack config 文件。 webpack.conf.js 123456789101112const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &#123; &apos;dll-user&apos;: [&apos;./index.js&apos;] &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;&#125;; 执行 webpack，会在 dist 下生成 dll-user.bundle.js，约 700K，耗时 801ms。 123456789$ ./node_modules/.bin/webpackHash: d8cab39e58c13b9713a6 Version: webpack 1.13.1 Time: 801ms Asset Size Chunks Chunk Namesdll-user.bundle.js 700 kB 0 [emitted] dll-user [0] multi dll-user 28 bytes &#123;0&#125; [built] [1] ./index.js 145 bytes &#123;0&#125; [built] + 167 hidden modules 接下来，我们加入 DLLReferencePlugin webpack.conf.js 1234567891011121314151617181920212223const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &#123; &apos;dll-user&apos;: [&apos;./index.js&apos;] &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;, // ----在这里追加---- plugins: [ new webpack.DllReferencePlugin(&#123; context: __dirname, /** * 在这里引入 manifest 文件 */ manifest: require(&apos;./dist/vendor-manifest.json&apos;) &#125;) ] // ----在这里追加----&#125;; 123456789./node_modules/.bin/webpackHash: 3bc7bf760779b4ca8523 Version: webpack 1.13.1 Time: 70ms Asset Size Chunks Chunk Namesdll-user.bundle.js 2.01 kB 0 [emitted] dll-user [0] multi dll-user 28 bytes &#123;0&#125; [built] [1] ./index.js 145 bytes &#123;0&#125; [built] + 3 hidden modules 结果是非常惊人的，只有2.01K，耗时 70 ms，无疑大大提高了 build 和 rebuild 的效率。实际放到页面上看下是否可行。 1234&lt;body&gt; &lt;script src=&quot;dist/vendor.dll.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/dll-user.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 因为 Dll bundle 在依赖安装完毕后就可以进行了，我们可以在第一次执行 dev server 前执行一次 dll bundle 的 webapck 任务。 和 external 的比较有人会说，这个和 用 webpack 的 externals 配置把 require 的 module 指向全局变量有点像啊。 123456789101112131415161718const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &#123; &apos;ex&apos;: [&apos;./index.js&apos;] &#125;, output: &#123; path: path.join(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos; &#125;, externals: &#123; // require(&apos;react&apos;)はwindow.Reactを使う &apos;react&apos;: &apos;React&apos;, // require(&apos;react-dom&apos;)はwindow.ReactDOMを使う &apos;react-dom&apos;: &apos;ReactDOM&apos; &#125;&#125;; 12345&lt;body&gt; &lt;script src=&quot;dist/react.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/react-dom.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;dist/ex.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 这里有两个主要的区别： 像是 react 这种已经打好了生产包的使用 externals 很方便，但是也有很多 npm 包是没有提供的，这种情况下 DLLBundle 仍可以使用。 如果只是引入 npm 包一部分的功能，比如 require(&#39;react/lib/React&#39;) 或者 require(&#39;lodash/fp/extend&#39;) ，这种情况下 DLLBundle 仍可以使用。 当然如果只是引用了 react 这类的话，externals 因为配置简单所以也推荐使用。 HappyPack build +, rebuild + webpack 的长时间构建搞的大家都很 unhappy。于是 @amireh 想到了一个点子，既然 loader 默认都是一个进程在跑，那是否可以让 loader 多进程去处理文件呢？ happyPack 的文档写的很易懂，这里就不再赘述，happyPack 不仅利用了多进程，同时还利用缓存来使得 rebuild 更快。下面是插件作者给出的性能数据： For the main repository I tested on, which had around 3067 modules, the build time went down from 39 seconds to a whopping ~10 seconds when there was yet no cache. Successive builds now take between 6 and 7 seconds. Here’s a rundown of the various states the build was performed in: Elapsed (ms) Happy? Cache enabled? Cache present? Using DLLs? 39851 NO N/A N/A NO 37393 NO N/A N/A YES 14605 YES NO N/A NO 13925 YES YES NO NO 11877 YES YES YES NO 9228 YES NO N/A YES 9597 YES YES NO YES 6975 YES YES YES YES The builds above were run on Linux over a machine with 12 cores. 其他上面我们针对 webpack 的 resolve、loader 和 plugin 的过程给出了相应的优化意见，除了这些哪些优化点呢？其实有些优化贯穿在这个流程中，比如缓存和文件 IO。 Cache无论在何种性能优化中，缓存总是必不可少的一部分，毕竟每次变动都只影响很小的一部分，如果能够缓存住那些没有变动的部分，直接拿来使用，自然会事半功倍，在 webpack 的整个构建过程中，有多个地方提供了缓存的机会，如果我们打开了这些缓存，会大大加速我们的构建，尤其是 rebuild 的效率。 webpack.cache rebuild + webpack 自身就有 cache 的配置，并且在 watch 模式下自动开启，虽然效果不是最明显的，但却对所有的 module 都有效。 babel-loader.cacheDirectory rebuild ++ babel-loader 可以利用系统的临时文件夹缓存经过 babel 处理好的模块，对于 rebuild js 有着非常大的性能提升。 HappyPack.cache build +, rebuild + 上面提到的 happyPack 插件也同样提供了 cache 功能，默认是以 .happypack/cache--[id].json 的路径进行缓存。因为是缓存在当前目录下，所以他也可以辅助下次 build 时的效率。 FileSystem默认的情况下，构建好的目录一定要输出到某个目录下面才能使用，但 webpack 提供了一种很棒的读写机制，使得我们可以直接在内存中进行读写，从而极大地提高 IO 的效率，开启的方法也很简单。 12345678910var MemoryFS = require(&quot;memory-fs&quot;); var webpack = require(&quot;webpack&quot;);var fs = new MemoryFS(); var compiler = webpack(&#123; ... &#125;); compiler.outputFileSystem = fs; compiler.run(function(err, stats) &#123; // ... var fileContent = fs.readFileSync(&quot;...&quot;);&#125;); 当然，我们还可以通过 webpackDevMiddleware 更加无缝地就接入到 dev server 中，例如我们以 express 作为静态 server 的例子。 1234567891011121314151617181920var compiler = webpack(webpackCfg);var webpackDevMiddlewareInstance = webpackDevMiddleware(compiler, &#123; // webpackDevMiddleware 默认使用了 memory-fs publicPath: &apos;/dist&apos;, aggregateTimeout: 300, // wait so long for more changes poll: true, // use polling instead of native watchers stats: &#123; chunks: false &#125;&#125;);var app = express(); app.use(webpackDevMiddlewareInstance); app.listen(xxxx, function(err) &#123; console.log(colors.info(&quot;dev server start: listening at &quot; + xxxx)); if (err) &#123; console.error(err); &#125;&#125; 总结上面我们从 webpack 构建的各个部分，给出了相应的优化策略，如果你的项目中能够将其完全贯彻起来，10 倍提速不是梦想。这些优化也同样应用到了我们团队的 react 项目中，https://github.com/uxcore/uxcore ，欢迎一起来讨论 webpack 的效率优化方案。 参考文章 webpack build performance：http://webpack.github.io/docs/build-performance.html webpackのDLLバンドルを使ってビルドを速くする：http://qiita.com/pirosikick/items/c77db84dbed4c447a6fe#%E3%81%8A%E3%81%BE%E3%81%91cachedirectory How to make your Webpack builds 10x faster：http://www.slideshare.net/trueter/how-to-make-your-webpack-builds-10x-faster 本文作者 eternalsky，始发于团队微信公众号 猿猿相抱 和个人博客 空の屋敷，转载请保留作者信息。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jafeney.com/tags/模块化/"},{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"}]},{"title":"深入理解JavaScript的Promise","date":"2016-07-03T10:12:09.000Z","path":"2016/07/03/2016-07-03-promise/","text":"写在前面 对于没有见过的东西，人们会排斥，因为内心会恐惧。 —— 题记 对于JavaScript这门语言来说，带P开头的关键词总是给人一种莫名的恐惧感。在初学JavaScript时，对ProtoType 和 __proto__ 非常恐惧，因为初级应用里根本用不到这两位，但是面试官却总喜欢问这类的问题。后来随着工作经验积累，看问题和编程的层面提升后，觉得其实也很简单。而我对今天的主人公promise也是这样的，从起初的抵触、害怕，到后来的从容相处。其实对编程语言来说，新的东西不会是横空出世的，它的诞生一定是为了解决现有的某个问题，一种未知的必然。 对promise的理解promise单词的中文释义虽然是 “允许、许诺”，但我们不能用字面的意思去认知它，而是应该把它理解为 “先知” 。另外重要的一点是，promise 是一种形式，不要把它看成是某些方法、函数之类的。 JavaScript是单线程的，也就是一条线下来的，这是代码世界的一条规则，而人当下所经历的现实世界中，很多行为结果是未知的，不是即时呈现的。这i就类似于JavaScript中发送一个Ajax请求，不同的返回值造成不同的影响。promise则扮演了一个”先知”的角色。预先将你的未来告知，规划好你继续的路。你无需等待最终的结果出来，继续现在的生活。 如果你是一个先知，你是没有等待、异步这种感觉的。这就是promise的作用，一种先知的形式，好比上帝，已经在他的时间维度一瞬间规划好你的一生。而对于JavaScript代码而言，我们就是上帝，我们能够预先知道代码的方向，并规划了代码的人生。典型的就是React组件的生命周期： 123456789101112131415161718192021222324import React, &#123; Component &#125; from &apos;react&apos;class myComponent extend Component &#123; constructor() &#123; console.log(&apos;组件初始化&apos;); &#125; componentWillMount() &#123; console.log(&apos;组件将开始构建&apos;); &#125; render() &#123; console.log(&apos;组件渲染中&apos;); &#125; componentDidMount() &#123; console.log(&apos;组件完成构建&apos;); &#125; componentWillUnmount() &#123; console.log(&apos;组件将开始销毁&apos;); &#125; componentDidUnmount() &#123; console.log(&apos;组件完成销毁&apos;); &#125;&#125;export default myComponent 这里顺带延伸一下React组件的完整的生命周期： React组件生命周期getDefaultProps()作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 getInitialState()作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 componentWillMount()在完成首次渲染之前调用，此时仍可以修改组件的state。 render()必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只能出现一个顶级组件（不能返回数组） 不能改变组件的状态 不能修改DOM的输出 componentDidMount()真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。注意：在服务端中，该方法不会被调用。 componentWillReceiveProps()组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 1234567componentWillReceiveProps: function(nextProps) &#123; if (nextProps.bool) &#123; this.setState(&#123; bool: true &#125;); &#125;&#125; shouldComponentUpdate()组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 componentWillUpdate()接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 componentDidUpdate()完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 componentWillUnmount()组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。 解释在现实世界中大部分的操作都是非即时呈现的，如果用JavaScript表示我们的一生，那就会是一个超级无限长的嵌套。 我们写代码的时候是以上帝的身份来处理代码的，我们是造物主，而不是以代码中的角色身份。目前的JavaScript异步回调就是按代码的视角——随着时间推移，代码中的人和物会经历不同的过程。但如果使用了promise，我们可以把异步操作转换成更符合先知视角的形式来展现。 下面介绍一个 非常形象的 “男神求婚”的promise实现例子，来自 张鑫旭《ES6 JavaScript Promise的感性认知》： 具体的思路是： 买些好烟好酒登门拜访岳父大人，恳请岳父大人把女儿许配给自己；1日后，得到岳父答复，如果同意，攻略大伯；如果不同意，继续攻略1次，要是还不行，失败告终； 同上攻略大伯； 买上等化妆品，然后同上攻略大姑； 拿着满满的offer拿下女神。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @desc 男神求婚promise示例 **/var NanShen = &#123; &quot;身高&quot;: 180, &quot;体重&quot;: 80, &quot;年薪&quot;: 200000, request: function(obj) &#123; // 成功与否随机决定，执行成功的概率为80% if (Math.random() &gt; 0.2) &#123; obj.success(); &#125; else &#123; obj.error(); &#125; &#125;&#125;;var Request = function(names, success) &#123; var index = first = 0; var request = function() &#123; if (names[index]) &#123; NanShen.request(&#123; name: names[index], success: function() &#123; first = 0; console.log(&quot;成功拿下&quot; + names[index]); index ++; request(); &#125;, error: function() &#123; if (first === 1) &#123; console.log(&quot;依旧没能拿下&quot; + names[index] + &quot;，求婚失败&quot;); &#125; else &#123; console.log(&quot;没能拿下&quot; + names[index] + &quot;，再试一次&quot;); &#125; first = 1; request(); &#125; &#125;); &#125; else &#123; success(); &#125; &#125;; request();&#125;;Request([&apos;岳父&apos;, &apos;大伯&apos;, &apos;大姑&apos;], function() &#123; NanShen.request(&#123; name: &quot;女神&quot;, success: function() &#123; console.log(&quot;女神同意，求婚成功！&quot;); &#125;, error: function() &#123; console.log(&quot;女神不同意，求婚失败！&quot;); &#125; &#125;);&#125;); 然后会随机产生不同的结果： @参考：张鑫旭《ES6 JavaScript Promise的感性认知》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"前端框架设计理念","date":"2016-07-02T09:09:15.000Z","path":"2016/07/02/2016-07-02-design/","text":"写在前面接下去的一段时间要集中对React和ReactNative的项目做进一步的组件化。我这里也先吹个牛，虽然是小团队，但是我们也决心要搞出一套体系化的东西，暂且把它命名为Royal。动工之前为也做了些理论方面的调研，主要是阿里开发的那套ANT和Twitter的 Bootstrap，作为科学理论基础。 十大原则『好设计比差设计更难发现』，因为好设计是如此的自然，帮助用户轻松的完成目标，以至于用户根本意识不到好设计的存在。 注：设计原则是对具象设计的抽象和总结，然而产品是一个整体，用户对整个产品的认知也是从全局到局部，所以忽略全局，只在局部套用原则是不可取的。对于这些原则，『设计者』应当理性地学会它，而后勇敢地抛弃它。 亲密度 Proximity 如果信息之间关联性越高，它们之间的距离就应该越接近，也越像一个视觉单元；反之，则它们的距离就应该越远，也越像多个视觉单元。亲密性的根本目的是实现组织性，让用户对页面结构和信息层次一目了然。 纵向间距关系通过『小号间距』、『中号间距』、『大号间距』这三种规格来划分信息层次。比如： 纵向间距 在阿里的Ant Design 中，这三种规格分别为：8px（小号间距）、16px（中号间距）、24px（大号间距）。 在这三种规格不适用的情况下，可以通过加减『基础间距』的倍数，或者增加元素来拉开信息层次。 注：在 Ant Design 中，y=8+8*n。其中，n&gt;=0，y 是纵向间距，8 是『基础间距』。 增加元素 这里通过增加『分割线』来拉开层次。 横向间距关系为了适用不同尺寸的屏幕，在横向采用栅格布局来排布组件，从而保证布局的灵活性。 组合排布示例 复选框内示例 注意：在一个组件内部，元素的横向间距也应该有所不同。 对齐Alignment正如『格式塔学派』中的连续律（Law of Continuity）所描述的，在知觉过程中人们往往倾向于使知觉对象的直线继续成为直线，使曲线继续成为曲线。在界面设计中，将元素进行对齐，既符合用户的认知特性，也能引导视觉流向，让用户更流畅地接收信息。 格式塔学派（德语：Gestalttheorie） ：是心理学重要流派之一，兴起于 20 世纪初的德国，又称为完形心理学；主张人脑的运作原理是整体的，『整体不同于其部件的总和』。——摘自『维基百科』 文案类对齐如果页面的字段或段落较短、较散时，需要确定一个统一的视觉起点。 推荐示例 标题和正文左对齐，使用了一个视觉起点。 不推荐示例 标题和正文使用了两个视觉起点，不推荐该种对齐方式，除非刻意强调两者区别。 表单类对齐冒号对齐（右对齐）能让内容锁定在一定范围内，让用户眼球顺着冒号的视觉流，就能找到所有填写项，从而提高填写效率。 数字类对齐为了快速对比数值大小，建议所有数值取相同有效位数，并且右对齐。 正确示例 错误示例 对比Contrast对比是增加视觉效果最有效方法之一，同时也能在不同元素之间建立一种有组织的层次结构，让用户快速识别关键信息。 注：要实现有效的对比，对比就必须强烈，切不可畏畏缩缩。 主次关系对比为了让用户能在操作上（类似表单、弹出框等场景）快速做出判断， 来突出其中一项相对更重要或者更高频的操作。 注意：突出的方法，不局限于强化重点项，也可以是弱化其他项。 正确示例 错误示例 在一些需要用户慎重决策的场景中，系统应该保持中立，不能替用户或者诱导用户做出判断。 不区分主次 总分关系对比通过调整排版、字体、大小等方式来突出层次感，区分总分关系，使得页面更具张力和节奏感。 总分关系 状态关系对比通过改变颜色、增加辅助形状等方法来实现状态关系的对比，以便用户更好的区分信息。常见类型有『静态对比』、『动态对比』。 静态对比用不同颜色点，来表明不同状态。 动态对比鼠标悬停时，该项和其他项呈现出明显不同的视觉效果，响应用户操作。 重复Repetition相同的元素在整个界面中不断重复，不仅可以有效降低用户的学习成本，也可以帮助用户识别出这些元素之间的关联性。 重复元素重复元素可以是一条粗线、一种线框，某种相同的颜色、设计要素、设计风格，某种格式、空间关系等。 线框重复 设计要素重复 设计要素重复 直截了当Make it Direct 正如 Alan Cooper 所言：『需要在哪里输出，就要允许在哪里输入』。这就是直接操作的原理。eg：不要为了编辑内容而打开另一个页面，应该直接在上下文中实现编辑。 页内编辑单字段行内编辑 单击编辑当『易读性』远比『易编辑性』重要时，可以使用『单击编辑』。 状态一：普通的浏览模式，不区分可编辑行和不可编辑行； 状态二：鼠标悬停时，『指针』变为『手型』，编辑区域底色变黄，出现『Tooltips』提示单击编辑； 状态三：鼠标点击后，出现『输入框』、『确定』、『取消』表单元素，同时光标定位在『输入框』中。 文字链/图标编辑 状态一：在可编辑行附近出现文字链/图标； 状态二：鼠标点击『编辑』后，出现『输入框』、『确定』、『取消』表单元素，同时光标定位在『输入框』中。 多字段行内编辑 注：在『多字段行内编辑』的情况下，显示的内容和编辑时所需的字段会存在比较大的差异，所以更需要『巧用过渡』原则中的『解释刚刚发生了什么』来消除这种视觉影响。 编辑模式在不破坏整体性的前提下，可扩大空间，以便放下『输入框』等表单元素；其中，在 Table 中进行编辑模式切换时，需要保证每列的不跳动。 利用拖放只能限制在一个维度（上/下或者左/右）进行拖放。 拖放列表 状态一：鼠标悬停该行时，出现可移动的『图标』； 状态二：鼠标悬停在该『图标』时，指针变为『手型』，点击即可进行拖动； 状态三：拖动到可放置区块，出现蓝色描边，告知用户该区块可放置该对象。 拖放图片/文件 足不出户Stay on the Page能在这个页面解决的问题，就不要去其它页面解决，因为任何页面刷新和跳转都会引起变化盲视（Change Blindness），导致用户心流（Flow）被打断。频繁的页面刷新和跳转，就像在看戏时，演员说完一行台词就安排一次谢幕一样。 变换盲视（Change Blindness） ：指视觉场景中的某些变化并未被观察者注意到的心理现象。产生这种现象的原因包括场景中的障碍物，眼球运动、地点的变化，或者是缺乏注意力等。——摘自《维基百科》 心流（Flow） ：也有别名以化境 (Zone) 表示，亦有人翻译为神驰状态，定义是一种将个人精神力完全投注在某种活动上的感觉；心流产生时同时会有高度的兴奋及充实感。——摘自《维基百科》 覆盖层二次确认覆盖层：避免滥用 Modal 进行二次确认，应该勇敢的让用户去尝试，给用户机会『撤消』即可。 推荐示例用户点击『删除』后，直接操作；出现 Message 告知用户操作成功，并提供用户『撤消』的按钮；用户进行下一个操作或者 1 分钟内不进行任何操作， Message 消失，用户无法再『撤消』。 特例：在执行某些无法『撤消』的操作时，可以点击『删除』后，出现 Popconfirm 进行二次确认，在当前页面完成任务。 不推荐示例滥用 Modal 进行二次确认，就像『狼来了』一样，既打断用户心流（无法将上下文带到弹出框中），也无法避免失误的发生。 详情覆盖层一般在列表中，通过用户『悬停』/『点击』某个区块，在当前页加载该条列表项的更多详情信息。 注：使用『悬停』激活时，当鼠标移入时，需要设置 0.5 秒左右的延迟触发；当鼠标移出时，立刻关闭覆盖层 通过『点击』图标查看更多详情信息。 输入覆盖层在覆盖层上，让用户直接进行少量字段的输入。 鼠标『点击』图标触发；鼠标『点击』悬浮层以外的其他区块后，直接保存输入结果并退出。 嵌入层列表嵌入层：在列表中，显示某条列表项的详情信息，保持上下文不中断。 列表嵌入层 标签页将多个平级的信息进行整理和分类了，一次只显示一组信息。 虚拟页面在交互过程中，『覆盖层』可以在当前页面上方显示附加内容和交互链接；『嵌入层』可以在页面内部实现同样效果；而『虚拟页面』不局限机械时代的『页面』，可以利用信息时代的特点构建一种新型『页面』。 流程处理长期以来，Web 实现流程的方式就是把每个步骤放在一个单独的页面上。虽然这种做法是分解问题最简单的方式，但并不是最佳解决方案。对于某些『流程处理』而言，让用户始终待在同一个页面上则更有必要。 渐进式展现基于用户的操作/某种特定规则，渐进式展现不同的操作选项。 配置程序配置程序：通过提供一系列的配置项，帮助用户完成任务或者产品组装。 弹出框覆盖层虽然弹出框的出现会打断用户的心流，但是有时候在弹出框中使用『步骤条』来管理复杂流程也是可行的。 简化交互Keep it Lightweight根据费茨法则（Fitts’s Law）所描述的，如果用户鼠标移动距离越少、对象相对目标越大，那么用户越容易操作。通过运用上下文工具（即：放在内容中的操作工具），使内容和操作融合，从而简化交互。 费茨法则 ：到达目标的时间是到达目标的距离与目标大小的函数，具体：$T = a + blog_2(1 + D/W) $ 其中：1.设备当前位置和目标位置的距离（D）；2.目标的大小（W）。距离越长，所用时间越长；目标越大，所用时间越短。 实时可见工具如果某个操作非常重要，就应该把它放在界面中，并实时可见。 状态一：在文案中出现一个相对明显的点击区域； 状态二：鼠标悬停时，鼠标『指针』变为『手型』，底色发生变化，邀请用户点击。 状态三：鼠标点击后，和未点击前有明显的区分。 悬停即现工具如果某个操作不那么重要，或者使用『实时可见工具』过于啰嗦会影响用户阅读时，可以在悬停在该对象上时展示操作项。 鼠标悬停时，出现操作项。 开关显示工具如果某些操作只需要在特定模式时显示，可以通过开关来实现。 用户点击『修改』后，Table 中『文本』变成『输入框』，开启编辑功能。 交互中的工具如果操作不重要或者可以通过其他途径完成时，可以将工具放置在用户的操作流程中，减少界面元素，降低认知负担，给用户小惊喜。 推荐示例鼠标悬停时，出现 Tooltips 进行提示，用户点击内容直接复制。 鼠标滑选/双击时，系统自动复制该部分内容。通过大胆猜测用户的行为，并帮助完成，给用户小惊喜。 不推荐示例在可复制内容的附近出现『图标』，点击后复制。 可视区域 ≠ 可点击区域在使用 Table 时，文字链的点击范围受到文字长短影响，可以设置整个单元格为热区，以便用户触发。 文字链热区示例当悬浮在 ID 所在的文字链单元格时，鼠标『指针』随即变为『手型』，单击即可跳转。 按钮热区示例鼠标移入按钮附近，即可激活 Hover 状态。 当需要增强按钮的响应性时，可以通过增加用户点击热区的范围，而不是增大按钮形状，从而增强响应性，又不缺失美感。 注：在移动端尤其适用。 提供邀请Provide Invitation很多富交互模式（eg：『拖放』、『行内编辑』、『上下文工具』）都有一个共同问题，就是缺少易发现性。所以『提供邀请』是成功完成人机交互的关键所在。 邀请就是引导用户进入下一个交互层次的提醒和暗示，通常包括意符（eg：实时的提示信息）和可供性，以表明在下一个界面可以做什么。当可供性中可感知的部分（Perceived Affordance）表现为意符时，人机交互的过程往往更加自然、顺畅。 意符（Signifiers） ：一种额外的提示，告诉用户可以采取什么行为，以及应该怎么操作；必须是可感知（eg：视觉、听觉、触觉等）。——摘自《设计心理学 1 》 可供性（Affordance） ：也被翻译成『示能』，由 James J. Gibson 提出，定义为物品的特性与决定物品用途的主体能力之间的关系；其中部分可感知（此部分定义为 Perceived Affordance），部分不可感知。——摘自《设计心理学 1 》 静态邀请指通过可视化技术在页面上提供引导交互的邀请。 引导操作邀请一般以静态说明形式出现在页面上，不过它们在视觉上也可以表现出多种不同样式。 常见类型：『文本邀请』、『白板式邀请』、『未完成邀请』。 漫游探索邀请是向用户介绍新功能的好方法，尤其是对于那些设计优良的界面。但是它不是『创口贴』，仅通过它不能解决界面交互的真正问题。 注：保持漫游过程简单，让用户容易退出和重新启动；保持内容简明扼要，与功能密切相关。 在用户首次登陆时出现少量『探索点』，当用户点击『我知道了』，能快速切换到下一个探索点。 动态邀请指以响应用户在特定位置执行特定操作的方式，提供特定的邀请。 悬停邀请在鼠标悬停期间提供邀请。 鼠标『悬停』整个卡片时，可被点击部分变为蓝色的『文字链』。 鼠标『悬停』时，出现『选择此模板』的按钮。 推论邀请用于交互期间，合理推断用户可能产生的需求。 用户点击『赞』后，同时系统分析（既然用户喜欢这篇文章，那么可能对这一类文章都有兴趣）并提供开启『精打细算』的邀请。推论邀请：用于交互期间，合理推断用户可能产生的需求。 更多内容邀请用于邀请用户查看更多内容。 在 Modal 中会出现前后切换的箭头。 巧用过渡Use Transition人脑灰质（Gray Matter）会对动态的事物（eg：移动、形变、色变等）保持敏感。在界面中，适当的加入一些过渡效果，能让界面保持生动，同时也能增强用户和界面的沟通。 Adding: 新加入的信息元素应被告知如何使用，从页面转变的信息元素需被重新识别。 Receding: 与当前页无关的信息元素应采用适当方式移除。 Normal: 指那些从转场开始到结束都没有发生变化的信息元素。 在视图变化时保持上下文 滑入与滑出：可以有效构建虚拟空间。 传送带：可极大地扩展虚拟空间。 折叠窗口：在视图切换时，有助于保持上下文，同时也能拓展虚拟空间。 解释刚刚发生了什么 对象增加：在列表/表格中，新增了一个对象。 对象删除：在列表/表格中，删除了一个对象。 对象更改：在列表/表格中，更改了一个对象。 对象呼出：点击页面中元素，呼出一个新对象。 改善感知性能当无法有效提升『实际性能』时，可以考虑适当转移用户的注意力，来缩短某项操作的感知时间，改善感知性能。 即时反应React Immediately『提供邀请』的强大体现在交互之前给出反馈，解决易发现性问题；『巧用过渡』的有用体现在它能够在交互期间为用户提供视觉反馈；『即时反应』的重要性体现在交互之后立即给出反馈。就像『牛顿第三定律』所描述作用力和反作用一样，用户进行了操作或者内部数据发生了变化，系统就应该立即有一个对应的反馈，同时输入量级越大、重要性越高，那么反馈量级越大、重要性越高。虽然反馈太多（准确的说，错误的反馈太多）是一个问题，但是反馈太少甚至没有反馈的系统，则让人感觉迟钝和笨拙，用户体验更差。 牛顿第三定律 ：当两个物体互相作用时，彼此施加于对方的力，其大小相等、方向相反。——摘自《维基百科》 查询模式自动完成用户输入时，下拉列表会随着输入的关键词显示匹配项。 根据查询结果分类的多少，可以分为『确定类目』、『不确定类目』两种类型。 用户所查询的关键词，只会在『话题』、『问题』、『文章』这 3 种类目中出现。 用户所查询的关键词，其所属的类目数量不确定，可能 4 个，可能 5 个，可能更多。 实时搜索随着用户输入，实时显示搜索结果。『自动完成』、『实时建议』的近亲。 用户输入一个搜索值，系统随即显示查询结果。 微调搜索随着用户调整搜索条件，实时调整搜索结构。具体可见：『模式／高级搜索』。 反馈模式实时预览在用户提交输入之前，让他先行了解系统将如何处理他的输入。 注：解决错误最好的办法，就是不让错误发生。而『实时预览』就是有效避免错误的好设计。 根据用户的输入，提供关于密码强度和有效性的实时反馈。 渐进式展现在必要的时候提供必要的提示，而不是一股脑儿显示所有提示，导致界面混乱，增加认知负担。案例详见『足不出户／渐进式展现』。 进度指示当一个操作需要一定时间完成时，就需要即时告知进度，保持与用户的沟通。 常见的进度指示：『按钮加载』、『表格加载』、『富列表加载』、『页面加载』。可根据操作的量级和重要性，展示不同类型的进度指示。 点击刷新告知用户有新内容，并提供按钮等工具帮助用户查看新内容。 定时刷新无需用户介入，定时展示新内容。 新增的列表项『高亮』，持续几秒后恢复正常。 设计基础字体 Font跨平台的字体设定，力求在各个操作系统下都有最佳展示效果。 字体家族 中文字体族 英文文字体族 字体家族 css 代码如下 1font-family: &quot;Helvetica Neue&quot;,Helvetica,&quot;PingFang SC&quot;,&quot;Hiragino Sans GB&quot;,&quot;Microsoft YaHei&quot;,&quot;微软雅黑&quot;,Arial,sans-serif; 排版 Typography良好的排版规范能大大提升用户的视觉体验。 行高和段落考虑到阅读的舒适度和节奏感，句子和段落间需要合适的间距。行距決定了段落中各行文字的垂直距离，通过字体本身行高来控制，我们行高默认为字号的 1.5 倍。段落间距決定了段落上下的间距，一般为字号的一倍宽。 标点和空格 使用全角中文标点。 遇到完整的英文整句、特殊名词，其内容使用半角标点。 数字使用半角字符。 不重复使用标点符号。 空格规范 中文和英文间需要空格。 数字与单位之间需要增加空格。 例外：度、百分比与数字之间不需要增加空格。 中文链接之间增加空格。 文字背景当文字和背景明暗对比小于一定比值时，人眼识别文字信息将会变得吃力，尤其在明亮的室外或晃动的情况下。 方法：若彩色背景，可先将色彩去色转为黑白，分别吸取并查看背景和文字的 HSV 色值。 两者的 V 值的差额便是明暗对比差。这个明暗对比差建议不小于 40。 对齐中文/英文居左对齐 中文和英文均采用左对齐的方式，是因为文字的阅读顺序一般是从左到右的。 数字/小数点对齐 数字通常采用右对齐或小数点对齐，这样便于对个十百千位上的数字进行对比。 冒号对齐 以冒号对齐的方式在表单中尤其常见。主要是为了区分标题和内容区块，除了美观简洁外，让用户能迅速看清标题减少出错概率。 文案长度语言通常是越简单越明确，而提示性文字更需要简明扼要，让用户一目了然，减少操作失误。提示性句子长度视业务而定，建议一般不超过 16–18 个字。 保持简明准确的方法： 每个句子只包含一个观点； 使用明确的词； 尽可能使用主动语态少用被动语态； 层级引导我们通常使用对比的手法来区分出信息的层次感，信息主次分明能准确地将信息清晰地传达给用户，让用户第一眼获取所需资讯，提升阅读体验。 Squint test我们可以采用 模糊测试 的方法，即眯起眼睛从整体来检视结构上的合理与否。 色彩 Colors有意义的色彩色彩在界面设计中的使用应同时具备品牌识别性以及界面设计功能性。众所周知色彩是相当感性的东西，设计中对色彩的运用首要应考虑到品牌层面的表达，另外很重要的一点是色彩的运用应达到信息传递，动作指引，交互反馈，或是强化和凸现某一个元素的目的。任何颜色的选取和使用应该是有意义的。众所周知色彩是相当感性的东西，设计中对色彩的运用首要应考虑到品牌层面的表达，另外很重要的一点是色彩的运用应达到信息传递，动作指引，交互反馈，或是强化和凸现某一个元素的目的。任何颜色的选取和使用应该是有意义的。 Ant Design ColorsAnt Design 的色板由 9 种基本色彩组成，每种基本色又衍生出九宫格色板，在此基础上还可以通过黑白叠加的方式实现色彩明暗的效果。 色彩和交互设计元素本身由于交互行为会引发一系列细微的视觉变化，而元素本身的颜色变化有时也能很好的实现这一目的。在进行这类设计的同时，建议采取在颜色上添加黑色或者白色并按照 n+5% 的规律递增的方式来实现。以下图为例，当鼠标 hover 某个特定元素，就视为浮起，对应颜色就相应增加白色叠加，相反点击的行为可以理解为按下去，在颜色上就相应的增加黑色的叠加。 色彩识别合适的色彩对比为信息传达加分，同时也应放考虑到有颜色识别障碍人群的需求。我们将每种主色衍生出来的颜色进行了打标，在考虑对比颜色的选择时建议两种颜色对应标签数值的差要大于等于 5。 常用布局 Layout布局和导航是产品的骨架，是页面的重要构成模式之一，是作为后续展开页面设计的基础，可以为产品奠定交互和视觉风格。 Ant Design 的布局和导航设计规范如下： 尺寸规则一级导航项偏左靠近 logo 放置，辅助菜单偏右放置。 顶部导航（大部分系统）：一级导航高度 64px，二级导航 48px。 顶部导航（展示类页面）：一级导航高度 80px,二级导航 56px。 顶部导航高度的范围计算公式为：48+8n。 侧边导航宽度的范围计算公式：200+8n。 交互原则 一级导航和末级的导航需要在可视化的层面被强调出来； 当前项应该在呈现上优先级最高； 当导航收起的时候，当前项的样式自动赋予给它的上一个层级； 左侧导航栏的收放交互同时支持手风琴和全展开的样式，根据业务的要求进行适当的选择。 视觉原则 导航样式上需要根据信息层级合理的选择样式： 大色块强调建议用于底色为深色系时，当前页面父级的导航项。 高亮火柴棍当导航栏底色为浅色系时使用，可用于当前页面对应导航项，建议尽量在导航路径的最终项使用。 字体高亮变色从可视化层面，字体高亮的视觉强化力度低于大色块，通常在当前项的上一级使用。 字体放大12px、14px 是导航的标准字号，14 号字体用在一、二级导航中。字号可以考虑导航项的等级做相应选择。 在大中后台系统中，Ant Design 使用两种常见的布局形式，顶部导航布局和侧边导航布局，以下收集了使用 Ant Design 设计的中后台产品的基本布局。 组件动画 Motion组件动画 缓动函数 总结阿里ANT框架非常强大，几乎涵盖项目开发方方面面，但是有一个弊端。她非常臃肿，这是功能强大无可避免的问题。我有个单页应用的项目，webpack打包好之后大概500k，但是一旦引入ANT框架，大小达到了5M，暂且不提后续的优化，我并不需要用到ANT所有的东西，可能是某个component或是Layout，实际的利用率其实不到10％。对于自由的开发者来说，我更倾向于选择 各自独立且低耦合的组件。 相比而言， Bootstrap可定制的特性是非常优秀的一种设计理念。组件化工作做得越久，越觉得以前写的组件不够好。如果把一个web项目比喻成一杯水，它其实是由无数的水分子构成的，但是水分子又是由氢原子和氧原子构成，而原子又是由质子和中子构成….. 所以总是会纠结组件耦合度的问题。 因此什么是 好的组件库？没有最好，但是它一定是各自相对独立、可配置、可定制，可以像原子一样无处不在的。这里并不是说ANT不好，如果你希望用整套的ANT做开发，她一样会让你觉得省事和高大上，还是按需求来做选择吧。 @ 参考 《定制并下载 Bootstrap》@ 参考 《Ant Design》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"Immutable 详解及 React 中实践","date":"2016-06-26T11:19:36.000Z","path":"2016/06/26/2016-06-26-immutable/","text":"写在前面React开发中广泛使用了Immutable，会用但不是很懂，相信很多人有同样的困惑，今天分享一篇 知乎 的关于 Immutable 的好文章。 12Shared mutable state is the root of all evil（共享的可变状态是万恶之源）-- Pete Hunt 有人说 Immutable 可以给 React 应用带来数十倍的提升，也有人说 Immutable 的引入是近期 JavaScript 中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。 JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。 Immutable 可以很好地解决这些问题。 什么是 Immutable Data Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画： 目前流行的 Immutable 库有两个： immutable.jsFacebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 其中有 3 种最重要的数据结构说明一下：（Java 程序员应该最熟悉了） Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象 List：有序可重复的列表，对应于 Array Set：无序且不可重复的列表 seamless-immutable与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。 下面上代码来感受一下两者的不同： 1234567891011121314151617181920// 原来的写法let foo = &#123;a: &#123;b: 1&#125;&#125;;let bar = foo;bar.a.b = 2;console.log(foo.a.b); // 打印 2console.log(foo === bar); // 打印 true// 使用 immutable.js 后import Immutable from &apos;immutable&apos;;foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);bar = foo.setIn([&apos;a&apos;, &apos;b&apos;], 2); // 使用 setIn 赋值console.log(foo.getIn([&apos;a&apos;, &apos;b&apos;])); // 使用 getIn 取值，打印 1console.log(foo === bar); // 打印 false// 使用 seamless-immutable.js 后import SImmutable from &apos;seamless-immutable&apos;;foo = SImmutable(&#123;a: &#123;b: 1&#125;&#125;)bar = foo.merge(&#123;a: &#123; b: 2&#125;&#125;) // 使用 merge 赋值console.log(foo.a.b); // 像原生 Object 一样取值，打印 1console.log(foo === bar); // 打印 false Immutable 优点 降低了 Mutable 带来的复杂度可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。比如下面一段代码： 12345function touchAndLog(touchFn) &#123; let data = &#123; key: &apos;value&apos; &#125;; touchFn(data); console.log(data.key); // 猜猜会打印什么？&#125; 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。 节省内存Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。 123456789import &#123; Map&#125; from &apos;immutable&apos;;let a = Map(&#123; select: &apos;users&apos;, filter: Map(&#123; name: &apos;Cam&apos; &#125;)&#125;)let b = a.set(&apos;select&apos;, &apos;people&apos;);a === b; // falsea.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true 上面 a 和 b 共享了没有变化的 filter 节点。 Undo/Redo、Copy/Paste、时间旅行因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 并发安全传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。 然而现在并没什么卵用，因为 JavaScript 还是单线程运行的啊。但未来可能会加入，提前解决未来的问题不也挺好吗？ 拥抱函数式编程Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 像 ClojureScript，Elm 等函数式编程语言中的数据类型天生都是 Immutable 的，这也是为什么 ClojureScript 基于 React 的框架 — Om 性能比 React 还要好的原因。 Immutable 缺点 需要学习新的 API增加了资源文件大小容易与原生对象混淆这点是我们使用 Immutable.js 过程中遇到最大的问题。写代码要做思维上的转变。 虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。 Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get(&#39;key&#39;) 而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。 当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。 下面给出一些办法来避免类似问题发生： 使用 Flow 或 TypeScript 这类有静态类型检查的工具 约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。 使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。 更多认识 Immutable.is两个 immutable 对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回 false： 123let map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);let map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);map1 === map2; // false 为了直接比较对象的值，immutable.js 提供了 Immutable.is 来做『值比较』，结果如下： 1Immutable.is(map1, map2); // true Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。 后面会使用 Immutable.is 来减少 React 重复渲染，提高性能。 另外，还有 mori、cortex 等，因为类似就不再介绍。 与 Object.freeze、const 区别ES6 中新加入的 Object.freeze 和 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。 Cursor 的概念这个 Cursor 和数据库中的游标是完全不同的概念。 由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。 12345678910111213import Immutable from &apos;immutable&apos;;import Cursor from &apos;immutable/contrib/cursor&apos;;let data = Immutable.fromJS(&#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125;);// 让 cursor 指向 &#123; c: 1 &#125;let cursor = Cursor.from(data, [&apos;a&apos;, &apos;b&apos;], newData =&gt; &#123; // 当 cursor 或其子 cursor 执行 update 时调用 console.log(newData);&#125;);cursor.get(&apos;c&apos;); // 1cursor = cursor.update(&apos;c&apos;, x =&gt; x + 1);cursor.get(&apos;c&apos;); // 2 实践 与 React 搭配使用，Pure Render熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。 当然我们也可以在 shouldComponentUpdate() 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。 Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的： 12345import &#123; is &#125; from &apos;immutable&apos;;shouldComponentUpdate: (nextProps, nextState) =&gt; &#123; return !(this.props === nextProps || is(this.props, nextProps)) || !(this.state === nextState || is(this.state, nextState));&#125; 使用 Immutable 后，如下图，当红色节点的 state 变化后，不会再渲染树中的所有节点，而是只渲染图中绿色的部分： setState 的一个技巧React 建议把 this.state 当作 Immutable 的，因此修改前需要做一个 deepCopy，显得麻烦： 12345678910111213141516import &apos;_&apos; from &apos;lodash&apos;;const Component = React.createClass(&#123; getInitialState() &#123; return &#123; data: &#123; times: 0 &#125; &#125; &#125;, handleAdd() &#123; let data = _.cloneDeep(this.state.data); data.times = data.times + 1; this.setState(&#123; data: data &#125;); // 如果上面不做 cloneDeep，下面打印的结果会是已经加 1 后的值。 console.log(this.state.data.times); &#125;&#125; 使用 Immutable 后： 12345678910getInitialState() &#123; return &#123; data: Map(&#123; times: 0 &#125;) &#125;&#125;,handleAdd() &#123; this.setState(&#123; data: this.state.data.update(&apos;times&apos;, v =&gt; v + 1) &#125;); // 这时的 times 并不会改变 console.log(this.state.data.get(&apos;times&apos;));&#125; 上面的 handleAdd 可以简写成： 12345handleAdd() &#123; this.setState((&#123;data&#125;) =&gt; (&#123; data: data.update(&apos;times&apos;, v =&gt; v + 1) &#125;) &#125;);&#125; 与 Flux 搭配使用由于 Flux 并没有限定 Store 中数据的类型，使用 Immutable 非常简单。 现在是实现一个类似带有添加和撤销功能的 Store： 123456789101112131415161718192021222324252627import &#123; Map, OrderedMap &#125; from &apos;immutable&apos;;let todos = OrderedMap();let history = []; // 普通数组，存放每次操作后产生的数据let TodoStore = createStore(&#123; getAll() &#123; return todos; &#125;&#125;);Dispatcher.register(action =&gt; &#123; if (action.actionType === &apos;create&apos;) &#123; let id = createGUID(); history.push(todos); // 记录当前操作前的数据，便于撤销 todos = todos.set(id, Map(&#123; id: id, complete: false, text: action.text.trim() &#125;)); TodoStore.emitChange(); &#125; else if (action.actionType === &apos;undo&apos;) &#123; // 这里是撤销功能实现， // 只需从 history 数组中取前一次 todos 即可 if (history.length &gt; 0) &#123; todos = history.pop(); &#125; TodoStore.emitChange(); &#125;&#125;); 与 Redux 搭配使用Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。 由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。 幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。 上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。 总结 Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外接口中。 如果 JS 原生 Immutable 类型会不会太美，被称为 React API 终结者的 Sebastian Markbåge 有一个这样的提案，能否通过现在还不确定。不过可以肯定的是 Immutable 会被越来越多的项目使用。 资源 Lee Byron - Immutable Data and React Immutable Data Structures and JavaScript","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"},{"name":"Redux","slug":"Redux","permalink":"http://jafeney.com/tags/Redux/"}]},{"title":"基于Redux的ReactNative项目开发总结（一）","date":"2016-06-17T09:11:14.000Z","path":"2016/06/17/2016-06-17-react-native/","text":"写在前面 上周把基于Redux的单页应用开发完 紧接着就开始了ReactNative的开发。真的快得不可思议，只花了一周时间，我们两个人就分工把APP也开发完了，并且同时兼容IOS操作系统和Android操作系统。内部测试了一轮，流畅性和用户体验方面也都相当给力！ 接下去几篇依次介绍项目开发中领悟的技巧和遇到的坑。 项目架构和React开发的单页应用不同，ReactNative开发不需要依赖webpack，facebook已经提供的一套基于NodeJS的转换和运行工具，这里不多做介绍。项目的架构如下： 1234567891011121314151617|---- project |---- android // android外壳 |---- ios // ios外壳 |---- node_modules // 项目依赖的node模块 |---- app // 本项目的js代码 |---- actions // Redux的actions |---- assets // 项目使用的icon |---- components // 项目自定义的组件 |---- containers // 项目的容器页面 |---- mixins // 全局使用的工具方法 |---- modules // 全局使用的自定义模块 |---- reducers // Redux的reducers |---- configureStore.js // Redux的store配置 |---- index.js // APP入口页面 |---- index.ios.js // android入口 |---- index.android.js // ios入口 |---- packge.json // 项目包信息 对Redux不清楚的童鞋可以出门看我之前的《基于Redux的单页应用开发总结》 。其实除了路由，其他和单页应用的结构差别不大。 依赖的Node模块ReactNative开发离不开NodeJS的支持，相比单页应用，这里依赖的模块比较少，除了Redux相关的模块，其他都是项目中用到的三方组件。 123456789101112131415&quot;dependencies&quot;: &#123; &quot;@remobile/react-native-toast&quot;: &quot;^1.0.4&quot;, // 用于错误提示的小弹窗 &quot;base-64&quot;: &quot;^0.1.0&quot;, &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-native&quot;: &quot;^0.25.1&quot;, &quot;react-native-animatable&quot;: &quot;^0.6.0&quot;, // 动画库 &quot;react-native-communications&quot;: &quot;^2.0.0&quot;, // 调用手机通讯功能 &quot;react-native-image-picker&quot;: &quot;^0.18.17&quot;, // 图片选择 &quot;react-native-modalbox&quot;: &quot;^1.3.3&quot;, // 模态框 &quot;react-native-tab-navigator&quot;: &quot;^0.2.18&quot;, // 导航栏 &quot;react-native-viewpager&quot;: &quot;^0.2.1&quot;, // 图片轮播切换 &quot;react-redux&quot;: &quot;^4.4.5&quot;, &quot;redux&quot;: &quot;^3.5.2&quot;, &quot;redux-thunk&quot;: &quot;^2.0.1&quot; &#125; 错误提示App里错误提示和网站稍有不同，网站页面宽度大，错误提示信息一般出现在输入框的后面或者悬浮在右上角。但是在App里，需要考虑用户不同的屏幕尺寸，错误信息应该放在一个相对独立且不影响其他元素显示的位置，目前主流的展现形式是这样的：即悬浮放置在页面的中底部，并且定时自动关闭。这个玩意自己写一个也不难，不过为了省事和好的兼容性，就直接使用三方的@remobile/react-native-toast了。使用方法如下： 12345import Toast from &apos;@remobile/react-native-toast&apos;;// ...Toast.showShortBottom(&apos;用户名或密码不正确&apos;); 对外的API有以下几个，顾名思义： 12345678910111213141516171819202122232425262728293031Toast.showShortTop = function (message) &#123; showToast(message, &quot;short&quot;, &quot;top&quot;);&#125;;Toast.showShortCenter = function (message) &#123; showToast(message, &quot;short&quot;, &quot;center&quot;);&#125;;Toast.showShortBottom = function (message) &#123; showToast(message, &quot;short&quot;, &quot;bottom&quot;);&#125;;Toast.showLongTop = function (message) &#123; showToast(message, &quot;long&quot;, &quot;top&quot;);&#125;;Toast.showLongCenter = function (message) &#123; showToast(message, &quot;long&quot;, &quot;center&quot;);&#125;;Toast.showLongBottom = function (message) &#123; showToast(message, &quot;long&quot;, &quot;bottom&quot;);&#125;;Toast.show = function (message) &#123; showToast(message, &quot;short&quot;, &quot;bottom&quot;);&#125;;Toast.hide = function () &#123; RCTToast.hide();&#125;; 安装和使用方法请查看 官方文档 动画库之前花时间研究过CSS3的动画库，其实目前主流的动画类型和动画创意就那么些，感兴趣的可以 clone一下 myAnimate 这个项目。一句话，CSS3里使用的动画方案，ReactNative里也应有尽有。我这边使用的是 react-native-animatable 组件。使用方式如下： 1234567891011import * as Animatable from &apos;react-native-animatable&apos;;class ExampleView extends Component &#123; render() &#123; return ( &lt;TouchableOpacity onPress=&#123;() =&gt; this.setState(&#123;fontSize: (this.state.fontSize || 10) + 5 &#125;)&#125;&gt; &lt;Animatable.Text transition=&quot;fontSize&quot; style=&#123;&#123;fontSize: this.state.fontSize || 10&#125;&#125;&gt;Size me up, Scotty&lt;/Animatable.Text&gt; &lt;/TouchableOpacity&gt; ); &#125;&#125; 下面是官方的Demo 调用手机通讯功能在HybridApp里实现这个功能还是挺麻烦的，需要客户端封装好接口给H5调用，但是在ReactNative里，一个组件就能搞定—— react-native-communications，安装请查看官方文档 这个组件安装很简单，支持的功能有：拨号、发短信、发Email、打开网页 等 ，下面是官方一个综合的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Component &#125; from &apos;react&apos;;import &#123; AppRegistry, StyleSheet, Text, View, TouchableOpacity&#125; from &apos;react-native&apos;;import Communications from &apos;react-native-communications&apos;;class RNCommunications extends Component(&#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; Communications.phonecall(&apos;0123456789&apos;, true)&#125;&gt; &lt;View style=&#123;styles.holder&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Make phonecall&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; Communications.email([&apos;emailAddress1&apos;, &apos;emailAddress2&apos;],null,null,&apos;My Subject&apos;,&apos;My body text&apos;)&#125;&gt; &lt;View style=&#123;styles.holder&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Send an email&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; Communications.text(&apos;0123456789&apos;)&#125;&gt; &lt;View style=&#123;styles.holder&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Send a text/iMessage&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; Communications.web(&apos;https://github.com/facebook/react-native&apos;)&#125;&gt; &lt;View style=&#123;styles.holder&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Open react-native repo on Github&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;&#125;);const styles = StyleSheet.create(&#123; container: &#123; flex: 1, alignItems: &apos;center&apos;, backgroundColor: &apos;rgb(253,253,253)&apos;, &#125;, holder: &#123; flex: 0.25, justifyContent: &apos;center&apos;, &#125;, text: &#123; fontSize: 32, &#125;,&#125;);AppRegistry.registerComponent(&apos;RNCommunications&apos;, () =&gt; RNCommunications); 访问手机相册调取手机相册和上传图片是个老生常谈的问题，ReactNative里可以通过react-native-image-picker 来处理，安装请查看官方文档 拎一段代码片段： 12345678910111213141516171819202122232425262728293031323334import ImagePicker from &apos;react-native-image-picker&apos;const options = &#123; title: &apos;选择上传图片&apos;, // specify null or empty string to remove the title cancelButtonTitle: &apos;取消&apos;, takePhotoButtonTitle: &apos;拍照...&apos;, // specify null or empty string to remove this button chooseFromLibraryButtonTitle: &apos;从库中选择...&apos;, // specify null or empty string to remove this button //customButtons: &#123; // &apos;Choose Photo from Facebook&apos;: &apos;fb&apos;, // [Button Text] : [String returned upon selection] //&#125;, cameraType: &apos;back&apos;, // &apos;front&apos; or &apos;back&apos; mediaType: &apos;photo&apos;, //videoQuality: &apos;high&apos;, // &apos;low&apos;, &apos;medium&apos;, or &apos;high&apos; maxWidth: 200, // photos only maxHeight: 200, // photos only allowsEditing: true, noData: false,&#125;//...onUpload() &#123; ImagePicker.showImagePicker(options, (response) =&gt; &#123; if (response.didCancel) &#123; //console.log(&apos;User cancelled image picker&apos;); &#125; else if (response.error) &#123; //console.log(&apos;ImagePicker Error: &apos;, response.error); &#125; else &#123; let source = &#123;uri: response.uri.replace(&apos;file://&apos;, &apos;&apos;), isLocal: true, isStatic: true&#125;; this.setState(&#123; form: &#123;...this.state.form, avatar: source&#125; &#125;) &#125; &#125;) &#125; 模态框模态框在App里使用的也比较多，比如确认模态、加载模态、输入模态等，出于良好的用户体验和兼容性考虑，我这里底层采用react-native-modalbox，然后根据不同功能进行二次加工。 ConfirmModal很常见，不多做介绍，copy下面代码 直接可以使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Dimensions, StyleSheet, Text, TouchableOpacity, View,&#125; from &apos;react-native&apos;;import ModalBox from &apos;react-native-modalbox&apos;;const styles = StyleSheet.create(&#123; modal: &#123; borderRadius: 10, &#125;, modalContent: &#123; flex: 1, paddingLeft: 10, paddingRight: 10, &#125;, h2: &#123; marginTop: 15, fontSize: 20, color: &apos;#555&apos;, textAlign: &apos;center&apos;, &#125;, modalOption: &#123; flexDirection: &apos;row&apos;, borderTopWidth: 1, borderTopColor: &apos;#ddd&apos;, &#125;, modalCancel: &#123; flex: 1, padding: 15, &#125;, modalCancelText: &#123; fontSize: 16, textAlign: &apos;center&apos;, &#125;, modalConfirm: &#123; flex: 1, padding: 15, borderLeftWidth: 1, borderLeftColor: &apos;#ddd&apos;, &#125;, modalConfirmText: &#123; fontSize: 16, textAlign: &apos;center&apos;, &#125;, message: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, &#125;, messageText: &#123; color: &apos;#555&apos;, fontSize: 16, &#125;,&#125;);export default class ConfirmModal extends Component &#123; constructor(props) &#123; super(props); &#125; open() &#123; this.refs.modal.open() &#125; close() &#123; this.refs.modal.close() &#125; render() &#123; let &#123; width &#125; = Dimensions.get(&apos;window&apos;); return ( &lt;ModalBox ref=&#123;&quot;modal&quot;&#125; style=&#123;[styles.modal, &#123;width: this.props.width || (width-60), height: this.props.height || 200&#125;]&#125; backdropOpacity=&#123;0.3&#125; position=&#123;&quot;center&quot;&#125; isOpen=&#123;false&#125;&gt; &lt;View style=&#123;styles.modalContent&#125;&gt; &lt;Text style=&#123;styles.h2&#125;&gt;&#123; this.props.title || &apos;提示&apos; &#125;&lt;/Text&gt; &lt;View style=&#123;styles.message&#125;&gt;&lt;Text style=&#123;styles.messageText&#125;&gt;&#123; this.props.message &#125;&lt;/Text&gt;&lt;/View&gt; &lt;/View&gt; &lt;View style=&#123;styles.modalOption&#125;&gt; &lt;TouchableOpacity style=&#123;styles.modalCancel&#125; onPress=&#123;()=&gt; this.refs.modal.close() &#125;&gt; &lt;Text style=&#123;styles.modalCancelText&#125;&gt;取消&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;TouchableOpacity style=&#123;styles.modalConfirm&#125; onPress=&#123;()=&gt; this.props.onConfirm() &#125;&gt; &lt;Text style=&#123;styles.modalConfirmText&#125;&gt;确定&lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; &lt;/ModalBox&gt; ) &#125;&#125; LoadingModal这个也很常见，copy下面代码 直接可以使用123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; Component &#125; from &apos;react&apos;;import &#123; StyleSheet,&#125; from &apos;react-native&apos;;import ModalBox from &apos;react-native-modalbox&apos;;const styles = StyleSheet.create(&#123; modal: &#123; justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, backgroundColor: &apos;transparent&apos; &#125;,&#125;);export default class LoadingModal extends Component &#123; constructor(props) &#123; super(props); &#125; open() &#123; this.refs.modal.open() &#125; close() &#123; this.refs.modal.close() &#125; render() &#123; return ( &lt;ModalBox style=&#123;styles.modal&#125; ref=&quot;modal&quot; position=&#123;&quot;center&quot;&#125; backdrop=&#123;false&#125; isOpen=&#123;this.props.isOpen || false&#125; //backdropOpacity=&#123;.3&#125; backdropPressToClose=&#123;false&#125; animationDuration=&#123;10&#125; &gt; &lt;/ModalBox&gt; ); &#125;&#125; PickerModal这个特别讲解一下，PickerModal用于页面上的Picker的处理，显示效果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Dimensions, StyleSheet, Text, TouchableOpacity, Picker, View,&#125; from &apos;react-native&apos;;import ModalBox from &apos;react-native-modalbox&apos;import dismissKeyboard from &apos;../mixins/dismiss-keyboard&apos;const styles = StyleSheet.create(&#123; popup: &#123; &#125;, popupContent: &#123; flex: 1, paddingLeft: 10, paddingRight: 10, &#125;, h2: &#123; marginTop: 15, fontSize: 20, color: &apos;#555&apos;, textAlign: &apos;center&apos;, &#125;, popupOption: &#123; flexDirection: &apos;row&apos;, borderTopWidth: 1, borderTopColor: &apos;#ddd&apos;, &#125;, popupCancel: &#123; flex: 1, padding: 15, &#125;, popupCancelText: &#123; fontSize: 16, textAlign: &apos;center&apos;, &#125;, popupConfirm: &#123; flex: 1, padding: 15, borderLeftWidth: 1, borderLeftColor: &apos;#ddd&apos;, &#125;, popupConfirmText: &#123; fontSize: 16, textAlign: &apos;center&apos;, &#125;, message: &#123; flex: 1, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, &#125;, messageText: &#123; color: &apos;#555&apos;, fontSize: 16, &#125;,&#125;);export default class PickerModal extends Component &#123; constructor(props) &#123; super(props); &#125; open() &#123; dismissKeyboard() this.refs.modal.open() &#125; close() &#123; this.refs.modal.close() &#125; _renderPickerItems(data) &#123; data.map((item)=&gt;&#123; return [ &lt;Picker.Item label=&#123;item[0]&#125; value=&#123;item[1]&#125; /&gt; ] &#125;) &#125; render() &#123; let &#123; width &#125; = Dimensions.get(&apos;window&apos;); return ( &lt;ModalBox ref=&#123;&quot;modal&quot;&#125; style=&#123;[styles.popup, &#123;width: this.props.width || (width), height: this.props.height || 200&#125;]&#125; backdropOpacity=&#123;0.3&#125; position=&#123;&quot;bottom&quot;&#125; swipeToClose=&#123;false&#125; isOpen=&#123;false&#125;&gt; &lt;View style=&#123;styles.popupContent&#125;&gt; &lt;Picker &#123;...this.props&#125;&gt; &#123;this.props.dataSource.map((item,i)=&gt; &#123; if (item.length) return &lt;Picker.Item key=&#123;i&#125; label=&#123;item[0]&#125; value=&#123;item[1]&#125; /&gt; &#125;)&#125; &lt;/Picker&gt; &lt;/View&gt; &lt;/ModalBox&gt; ) &#125;&#125; 补充说明一下dismissKeyboard()这个方法，该方法用于关闭页面的keyboard(键盘)，ReactNative 默认没有这种方法，需要自己编写： 12345import &#123; TextInput &#125; from &apos;react-native&apos;;const &#123; State: TextInputState &#125; = TextInput;export default function dismissKeyboard() &#123; TextInputState.blurTextInput(TextInputState.currentlyFocusedField());&#125; 导航条这个组件其实ReactNative提供了原生版本的，但是样式和功能上不好控制，建议自己手写一个，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Image, Platform, StyleSheet, Text, TouchableOpacity, View,&#125; from &apos;react-native&apos;;const styles = StyleSheet.create(&#123; leftButton: &#123; marginLeft: 5, &#125;, rightButton: &#123; marginRight: 5, &#125;, button: &#123; width: 44, height: 44, justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, &#125;, nav: &#123; backgroundColor: &apos;#f9f9f9&apos;, flexDirection: &apos;row&apos;, alignItems: &apos;center&apos;, &#125;, title: &#123; flex: 1, height: 44, justifyContent: &apos;center&apos;, &#125;, btnText: &#123; fontSize: 16, color: &apos;#777&apos;, &#125;, marginForIOS: &#123; marginTop: 20, &#125;, titleText: &#123; fontSize: 20, textAlign: &apos;center&apos;, color: &apos;#555&apos; &#125;&#125;);export class RightButton extends Component &#123; render() &#123; return ( &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;this.props.onPress&#125;&gt; &#123; this.props.text ? &lt;Text style=&#123;styles.btnText&#125;&gt;&#123;this.props.text&#125;&lt;/Text&gt; : null &#125; &#123; this.props.icon ? &lt;Image source=&#123;this.props.icon&#125; style=&#123;styles.rightButton&#125; /&gt; : null &#125; &lt;/TouchableOpacity&gt; ); &#125;&#125;export class NavigatorBar extends Component &#123; _leftButton() &#123; if (this.props.navigator.getCurrentRoutes().length &gt; 1) return ( &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;()=&gt; this.props.navigator.pop() &#125;&gt; &lt;Image source=&#123;require(&apos;../assets/icon-nav-left.png&apos;)&#125; style=&#123;styles.leftButton&#125; /&gt; &lt;/TouchableOpacity&gt; ) &#125; _rightButton() &#123; if (this.props.rightButton) return ( &lt;RightButton &#123;...this.props.rightButton&#125; /&gt; ) &#125; render() &#123; return ( &lt;View style=&#123;styles.nav&#125;&gt; &lt;View style=&#123;[styles.button, Platform.OS==&apos;ios&apos; ? styles.marginForIOS : null]&#125;&gt; &#123;this._leftButton()&#125; &lt;/View&gt; &lt;View style=&#123;[styles.title, Platform.OS==&apos;ios&apos; ? styles.marginForIOS : null]&#125;&gt; &lt;Text style=&#123;styles.titleText&#125;&gt;&#123; this.props.name &#125;&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;[styles.button, Platform.OS==&apos;ios&apos; ? styles.marginForIOS : null]&#125;&gt; &#123;this._rightButton()&#125; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125; 然后在container里就可以使用了：12345678910import &#123; NavigatorBar &#125; from &apos;../components/navigator&apos;// 没有右侧按钮&lt;NavigatorBar name=&quot;登录&quot; navigator=&#123;this.props.navigator&#125; /&gt;// 右侧按钮为图标 &lt;NavigatorBar name=&quot;我的&quot; navigator=&#123;this.props.navigator&#125; rightButton=&#123;&#123;onPress: ()=&gt;&#123;this.props.navigator.push(&#123;component: Setting&#125;)&#125;, icon: require(&apos;../../assets/icon-set.png&apos;)&#125;&#125; /&gt;// 右侧按钮为文字&lt;NavigatorBar name=&quot;我的订单&quot; navigator=&#123;this.props.navigator&#125; rightButton=&#123;&#123;text: &apos;历史 &apos;, onPress: ()=&gt; this.props.navigator.push(&#123;component: OrderHitory&#125;) &#125;&#125; /&gt; 图片轮播建议使用三方的react-native-viewpager组件，安装请查看 官方文档 下面是一个demo： 1234567891011121314151617181920var ViewPager = require(&apos;react-native-viewpager&apos;);&lt;ViewPager dataSource=&#123;this.state.dataSource&#125; renderPage=&#123;this._renderPage&#125; animation = &#123;(animatedValue, toValue, gestureState) =&gt; &#123; // Use the horizontal velocity of the swipe gesture // to affect the length of the transition so the faster you swipe // the faster the pages will transition var velocity = Math.abs(gestureState.vx); var baseDuration = 300; var duration = (velocity &gt; 1) ? 1/velocity * baseDuration : baseDuration; return Animated.timing(animatedValue, &#123; toValue: toValue, duration: duration, easing: Easing.out(Easing.exp) &#125;); &#125;&#125;/&gt;","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"基于Redux架构的单页应用开发总结（三）","date":"2016-06-11T09:20:27.000Z","path":"2016/06/11/2016-06-12-redux/","text":"写在前面 这篇具体讲讲Redux使用的一些技巧 React式编程思维在没有遁入React之前，我是一个DOM操作控，不论是jQuery还是zepto，我在页面交互的实现上用的最多的就是DOM操作，把复杂的交互一步一步通过选择器和事件委托绑定到document上，然后逐个连贯起来。 12345678$(document).on(&apos;event&apos;, &apos;element&apos;, function(e)&#123; e.preventDefault(); var that = this; var parent = $(this).parent(); var siblings = $(this).siblings(); var children = $(this).children(); // .....&#125;); 这是jQuery式的编程思维，React和它截然不同。React的设计是基于组件化的，每个组件通过生命周期维护统一的state，state改变，组件便update，重新触发render，即重新渲染页面。而这个过程操作的其实是内存里的虚拟DOM，而不是真正的DOM节点，加上其内部的差异更新算法，所以性能上比传统的DOM操作要好。 举个简单的例子： 现在要实现一个模态组件，如果用jQuery式的编程思维，很习惯这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @desc 全局模态窗口 **/var $ = window.$;var modal = &#123; confirm: function(opts) &#123; var title = opts.title || &apos;提示&apos;, content = opts.content || &apos;提示内容&apos;, callback = opts.callback; var newNode = [ &apos;&lt;div class=&quot;mask&quot; id=&quot;J_mask&quot;&gt;&apos;, &apos;&lt;div class=&quot;modal-box&quot;&gt;&apos;, &apos;&lt;h2&gt;&apos;, title, &apos;&lt;/h2&gt;&apos;, &apos;&lt;p&gt;&apos;, content, &apos;&lt;/p&gt;&apos;, &apos;&lt;div class=&quot;mask-btns&quot;&gt;&apos;, &apos;&lt;span id=&quot;J_cancel&quot;&gt;取消&lt;/span&gt;&apos;, &apos;&lt;span id=&quot;J_confirm&quot;&gt;确定&lt;/span&gt;&apos;, &apos;&lt;/div&gt;&apos;, &apos;&lt;/div&gt;&apos;, &apos;&lt;/div&gt;&apos;, ].join(&apos;&apos;); $(&apos;#J_mask&apos;).remove(); $(&apos;body&apos;).append(newNode); $(&apos;#J_cancel&apos;).on(&apos;click&apos;, function() &#123; $(&apos;#J_mask&apos;).remove(); &#125;); $(&apos;#J_confirm&apos;).on(&apos;click&apos;, function() &#123; if (typeof callback === &apos;function&apos;) &#123; callback(); &#125; $(&apos;#J_mask&apos;).remove(); &#125;); &#125;&#125;;module.exports = modal; 然后在页面的JavaScript里通过选择器触发模态和传递参数。 12345678910111213141516171819var Modal = require(&apos;modal&apos;);var $ = window.$;var app = (function() &#123; var init = function() &#123; eventBind(); &#125;; var eventBind = function() &#123; $(document).on(&apos;click&apos;, &apos;#btnShowModal&apos;, function() &#123; Modal.confirm(&#123; title: &apos;提示&apos;, content: &apos;你好！世界&apos;, callback: function() &#123; console.log(&apos;Hello World&apos;); &#125; &#125;); &#125;); &#125;; init();&#125;)(); 如果采用React式的编程思维，它应该是这样的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @desc 全局模态组件 Component * @author Jafeney * @createDate 2016-05-17 * */import React, &#123; Component &#125; from &apos;react&apos;import &apos;./index.less&apos;class Modal extends Component &#123; constructor() &#123; super() this.state = &#123; jsMask: &apos;mask hidden&apos; &#125; &#125; show() &#123; this.setState(&#123; jsMask: &apos;mask&apos; &#125;) &#125; close() &#123; this.setState(&#123; jsMask: &apos;mask hidden&apos; &#125;) &#125; confirm() &#123; this.props.onConfirm &amp;&amp; this.props.onConfirm() &#125; render() &#123; return ( &lt;div className=&#123;this.state.jsMask&#125;&gt; &lt;div className=&quot;modal-box&quot; style=&#123;this.props.style&#125;&gt; &lt;div className=&quot;header&quot;&gt; &lt;h3&gt;&#123; this.props.title &#125;&lt;/h3&gt; &lt;span className=&quot;icon-remove closed-mask&quot; onClick=&#123;()=&gt;this.close()&#125;&gt;&lt;/span&gt; &lt;/div&gt; &lt;div className=&quot;content&quot;&gt; &#123; this.props.children &#125; &lt;/div&gt; &lt;div className=&quot;mask-btns&quot;&gt; &lt;span className=&quot;btn-full-danger&quot; onClick=&#123;()=&gt;this.confirm()&#125;&gt;&#123; this.props.confirmText || &apos;确定&apos; &#125;&lt;/span&gt; &#123; this.props.showCancel &amp;&amp; (&lt;span className=&quot;btn-border-danger&quot; onClick=&#123;()=&gt;this.close()&#125;&gt;取消&lt;/span&gt;) &#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Modal 然后在container的render()函数里通过标签的方式引入，并通过点击触发。 123456789101112131415161718import &#123;React, component&#125; from &apos;react&apos;;import Modal from &apos;Modal&apos;;class App extends Component &#123; render() &#123; &lt;div&gt; &lt;button onClick = &#123;()=&gt; &#123;this.refs.modal.show()&#125;&#125; &lt;Modal title=&#123;&quot;提示&quot;&#125; style=&#123;&#123;width: 420, height: 200&#125;&#125; ref=&#123;(ref)=&gt; this.modal = ref&#125; onConfirm=&#123;()=&gt;this.onModalConfirm()&#125;&gt; &lt;p className=&quot;tips&quot;&gt;Hello world!&lt;/p&gt; &lt;/Modal&gt; &lt;/div&gt; &#125;&#125;export default App 你会发现，上面的代码并没有刻意地操作某个DOM元素的样式，而是通过改变组件的state去触发自身的渲染函数。换句话说，我们不需要写繁琐的DOM操作，而是靠改变组件的state控制组件的交互和各种变化。这种思维方式的好处等你熟悉React之后自然会明白，可以大大地减少后期的代码量。 优化渲染前面提到组件的state改变即触发render()，React内部虽然做了一些算法上的优化，但是我们可以结合Immutable做进一步的渲染优化，让页面更新渲染速度变得更快。 12345678910111213141516171819/** * @desc PureRender 优化渲染 **/import React, &#123; Component &#125; from &apos;react&apos;import Immutable from &apos;immutable&apos;;export default &#123; // 深度比较 deepCompare: (self, nextProps, nextState) =&gt; &#123; return !Immutable.is(self.props, nextProps) || !Immutable.is(self.state, nextState) &#125;, // 阻止没必要的渲染 loadDetection: (reducers=[])=&gt; &#123; for (let r of reducers) &#123; if (!r.get(&apos;preload&apos;)) return (&lt;div /&gt;) &#125; &#125;&#125; 这样我们在container的render()函数里就可以调用它进行渲染优化 1234567891011121314151617import React, &#123; Component &#125; from &apos;react&apos;import PureRenderMixin from &apos;../../mixins/PureRender&apos;;class App extends Component &#123; render() &#123; let &#123; actions, account, accountLogs, bankBind &#125; = this.props； // 数据导入检测 let error = PureRenderMixin.loadDetection([account, accountLogs, bankBind]) // 如果和上次没有差异就阻止组件重新渲染 if (error) return error return ( &lt;div&gt; // something ... &lt;/div&gt; ); &#125;&#125; 全局模块的处理其实Redux最大的作用就是有效减少代码量，把繁琐的操作通过 action ----&gt; reducer ----&gt; store 进行抽象，最后维护统一的state。对于页面的全局模块，简单地封装成mixin来调用还是不够的，比如全局的request模块，下面介绍如何用Redux进行改造。 首先在types.js里进行声明：123456// requestexport const REQUEST_PEDDING = &apos;REQUEST_PEDDING&apos;;export const REQUEST_DONE = &apos;REQUEST_DONE&apos;;export const REQUEST_ERROR = &apos;REQUEST_ERROR&apos;;export const REQUEST_CLEAN = &apos;REQUEST_CLEAN&apos;;export const REQUEST_SUCCESS = &apos;REQUEST_SUCCESS&apos;; 然后编写action: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @desc 网络请求模块的actions **/// fetch 需要使用 Promise 的 polyfillimport &#123; pendingTask, // The action key for modifying loading state begin, // The action value if a &quot;long&quot; running task begun end // The action value if a &quot;long&quot; running task ended&#125; from &apos;react-redux-spinner&apos;;import &apos;babel-polyfill&apos;import fetch from &apos;isomorphic-fetch&apos;import Immutable from &apos;immutable&apos;import * as CONFIG from &apos;./config&apos;; //请求的配置文件import * as TYPES from &apos;./types&apos;;export function request(route, params, dispatch, success=null, error=null, &#123; method=&apos;GET&apos;, headers=&#123;&#125;, body=null &#125; = &#123;&#125;) &#123; dispatch(&#123;type: TYPES.REQUEST_PEDDING, [ pendingTask ]: begin&#125;) // 处理query const p = params ? &apos;?&apos; + Object.entries(params).map( (i)=&gt; `$&#123;i[0]&#125;=$&#123;encodeURI(i[1])&#125;` ).join(&apos;&amp;&apos;) : &apos;&apos; const uri = `$&#123; CONFIG.API_URI &#125;$&#123; route &#125;$&#123; p &#125;` let data = &#123;method: method, headers: headers&#125; if (method!=&apos;GET&apos;) data.body = body fetch(uri, data) .then((response) =&gt; &#123; dispatch(&#123;type: TYPES.REQUEST_DONE, [ pendingTask ]: end&#125;) return response.json() &#125;) .then((data) =&gt; &#123; if (String(data.code) == &apos;0&apos;) &#123; if (method !== &apos;GET&apos; ) dispatch(&#123;type: TYPES.REQUEST_SUCCESS&#125;); success &amp;&amp; success(data); &#125; else &#123; console.log(data.error) dispatch(&#123;type: TYPES.REQUEST_ERROR, ...data&#125;) error &amp;&amp; error(data) &#125; &#125;) .catch((error) =&gt; &#123; console.warn(error) &#125;)&#125;export function requestClean() &#123; return &#123; type: TYPES.REQUEST_CLEAN &#125;&#125; 然后编写对应的reducer操作state： 12345678910111213141516171819202122232425import Immutable from &apos;immutable&apos;;import * as TYPES from &apos;../actions/types&apos;;import &#123; createReducer &#125; from &apos;redux-immutablejs&apos;export default createReducer(Immutable.fromJS(&#123;status: null, error: null&#125;), &#123; [TYPES.REQUEST_ERROR]: (state, action) =&gt; &#123; return state.merge(&#123; status: &apos;error&apos;, code: action.code, error: Immutable.fromJS(action.error), &#125;) &#125;, [TYPES.REQUEST_CLEAN]: (state, action) =&gt; &#123; return state.merge(&#123; status: null, error: null, &#125;) &#125;, [TYPES.REQUEST_SUCCESS]: (state, action) =&gt; &#123; return state.merge(&#123; status: &apos;success&apos;, error: null, &#125;) &#125;&#125;) 然后在reducers的index.js里对外暴露接口1export request from &apos;./request&apos; 为什么要做这一步呢？因为我们需要在configureStore.js里利用combineReducers对所有的reducer进行进一步的结合处理： 12345678910111213141516171819202122232425import &#123; createStore, combineReducers, compose, applyMiddleware &#125; from &apos;redux&apos;import thunkMiddleware from &apos;redux-thunk&apos;import createLogger from &apos;redux-logger&apos;import * as reducers from &apos;./reducers&apos;import &#123; routerReducer, routerMiddleware &#125; from &apos;react-router-redux&apos;import &#123; pendingTasksReducer &#125; from &apos;react-redux-spinner&apos;export default function configureStore(history, initialState) &#123; const reducer = combineReducers(&#123; ...reducers, routing: routerReducer, pendingTasks: pendingTasksReducer, &#125;) const store = createStore( reducer, initialState, compose( applyMiddleware( thunkMiddleware, routerMiddleware(history) ) ) ) return store&#125; 接下来就可以在container里使用了，比如登录模块： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * @desc 登录模块 container * @createDate 2016-05-16 * @author Jafeney&lt;692270687@qq.com&gt; **/import React, &#123; Component &#125; from &apos;react&apos;import &#123; bindActionCreators &#125; from &apos;redux&apos;import &#123; connect &#125; from &apos;react-redux&apos;import &#123; replace &#125; from &apos;react-router-redux&apos;import &#123; login &#125; from &apos;../../actions/user&apos;import &#123; requestClean &#125; from &apos;../../actions/request&apos;import CheckUserMixin from &apos;../../mixins/CheckUser&apos;import PureRenderMixin from &apos;../../mixins/PureRender&apos;import &apos;../style.less&apos;;class Login extends Component &#123; constructor() &#123; super() &#125; shouldComponentUpdate(nextProps, nextState) &#123; // 如果已经登录不触发深度比较 if (nextProps.user.getIn([&apos;login&apos;, &apos;status&apos;])==&apos;logged&apos;) &#123; this.toMain() return true &#125; return PureRenderMixin.deepCompare(this, nextProps, nextState) &#125; // 检查登录态 componentDidMount() &#123; let &#123; user &#125; = this.props; if (CheckUserMixin.isLogged(user)) this.toMain() &#125; // 初始化页面 toMain() &#123; this.props.actions.replace(&apos;/&apos;) this.props.actions.requestClean() &#125; // 执行登录 login() &#123; const userName = this.refs[&apos;J_username&apos;].value, password = this.refs[&apos;J_password&apos;].value if (userName &amp;&amp; password) &#123; this.props.actions.login(&#123;username: userName, password: password&#125;) &#125; &#125; // 绑定回车事件 onEnter(event) &#123; var e = event || window.event || arguments.callee.caller.arguments[0]; if(e &amp;&amp; e.keyCode==13) &#123; // enter 键 this.login() &#125; &#125; render() &#123; let &#123; user &#125; = this.props return ( &lt;div className=&quot;wrapper&quot; onKeyPress=&#123;()=&gt;this.onEnter()&#125;&gt; &lt;div className=&quot;containers&quot;&gt; &lt;div className=&quot;logo&quot;&gt;&lt;/div&gt; &lt;div className=&quot;content&quot;&gt; &lt;div className=&quot;header&quot;&gt;会员登录&lt;/div&gt; &lt;div className=&quot;mainer&quot;&gt; &lt;div className=&quot;input-group&quot;&gt; &lt;input ref=&quot;J_username&quot; type=&quot;text&quot; placeholder=&quot;手机号码&quot; className=&quot;input&quot; /&gt; &lt;label className=&quot;check-info&quot; ref=&quot;J_username-check&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;div className=&quot;input-group&quot;&gt; &lt;input ref=&quot;J_password&quot; type=&quot;password&quot; placeholder=&quot;登录密码&quot; className=&quot;input&quot; /&gt; &lt;label className=&quot;check-info&quot; ref=&quot;J_password-check&quot;&gt;&lt;/label&gt; &lt;/div&gt; &lt;div className=&quot;input-group&quot;&gt; &lt;span ref=&quot;J_login&quot; onClick=&#123;()=&gt;this.login()&#125; className=&quot;login-btn&quot;&gt;登录&lt;/span&gt; &lt;span className=&quot;login-info&quot;&gt; &lt;a ref=&quot;J_register&quot; href=&quot;#/register&quot; className=&quot;register&quot;&gt;免费注册&lt;/a&gt; | &lt;a ref=&quot;J_forget&quot; href=&quot;#/password&quot; className=&quot;forget&quot;&gt;忘记密码 ?&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div className=&quot;form-error&quot;&gt; &#123; user.getIn([&apos;login&apos;, &apos;error&apos;, &apos;message&apos;]) &#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;// 下面是redux的核心方法function mapStateToProps(state) &#123; return &#123; user: state.user &#125;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(&#123; login, requestClean, replace &#125;, dispatch) &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(Login) 注意：通过以上方式，在组件内部actions里挂载的方法就可以通过this.props取得了。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"},{"name":"Redux","slug":"Redux","permalink":"http://jafeney.com/tags/Redux/"}]},{"title":"基于Redux架构的单页应用开发总结（二）","date":"2016-06-10T16:17:40.000Z","path":"2016/06/11/2016-06-11-redux/","text":"写在前面 这次重点介绍基于Redux架构的单页应用代码的组织方式 关于less的组织作为一个后端出身的前端工程师，写简单的css实在没有那种代码可配置和结构化的快感。所以引入less是个不错的选择，无论是针对代码后期的管理，还是提高代码的复用能力。 global.less这个是全局都可以调用的方法库，我习惯把 项目的配色、各种字号、用于引入混出的方法等写在这里，其他container页面通过@import方式引入它，就可以使用里面的东西。不过定义它时要注意以下两点： 第一，这个less里只能存放变量和方法，less编译时会忽略它们，只在调用它们的地方才编译成css。所以为了防止代码重复，请不要在这里直接定义样式，而是用一个方法把它们包起来，表示一个用途。 第二，这个less里的方法如果是针对某些具体标签定义样式的，只能初始化一次，建议在单页的入口container里做，这样好维护。比如reset()（页面标签样式初始化），这个方法放在入口container的 login.less里调用且全局只调用一次。 下面是我的global.less 常用的一些模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * @desc 一些全局的less * @createDate 2016-05-16 * @author Jafeney &lt;692270687@qq.com&gt; **/// 全局配色@g-color-active: #ff634d; //活跃状态的背景色（橘红色）@g-color-info: #53b2ea; //一般用途的背景色（浅蓝色）@g-color-primary: #459df5; //主要用途的背景色 (深蓝色)@g-color-warning: #f7cec8; //用于提示的背景色 (橘红色较浅)@g-color-success: #98cf07; //成功状态的背景色 (绿色)@g-color-fail: #c21f16; //失败状态的背景色 (红色)@g-color-danger: #ff634d; //用于警示的背景色 (橘红色)@g-color-light: #fde2e1; //高饱合度淡色的背景色(橘红)// 全局尺寸@g-text-default: 14px;@g-text-sm: 12px;@g-text-lg: 18px;// 全局使用的自定义icon（这样写的好处是webpack打包时自动转base64）@g-icon-logo: url(&quot;../images/logo.png&quot;);@g-icon-logoBlack: url(&quot;../images/logoBlack.png&quot;);@g-icon-phone: url(&quot;../images/phone.png&quot;);@g-icon-message: url(&quot;../images/message.png&quot;);@g-icon-help: url(&quot;../images/help.png&quot;);@g-icon-down: url(&quot;../images/down.png&quot;);@g-icon-top: url(&quot;../images/top.png&quot;);@g-icon-home: url(&quot;../images/home.png&quot;);@g-icon-order: url(&quot;../images/order.png&quot;);@g-icon-cart: url(&quot;../images/cart.png&quot;);@g-icon-source: url(&quot;../images/source.png&quot;);@g-icon-business: url(&quot;../images/business.png&quot;);@g-icon-finance: url(&quot;../images/finance.png&quot;);@g-icon-account: url(&quot;../images/account.png&quot;);// ....// 背景色@g-color-grey1: #2a2f33; //黑色@g-color-grey2: #363b3f; //深灰色@g-color-grey3: #e5e5e5; //灰色@g-color-grey4: #efefef; //浅灰色@g-color-grey5: #f9f9f9; //很浅@g-color-grey6: #ffffff; //白色// 全局边框@g-border-default: #e6eaed;@g-border-active: #53b2ea;@g-border-light: #f7dfde;// 常用的border-box盒子模型.border-box() &#123; box-sizing: border-box; -ms-box-sizing: border-box; -moz-box-sizing: border-box; -o-box-sizing: border-box; -webkit-box-sizing: border-box;&#125;// 模拟按钮效果.btn() &#123; cursor: pointer; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; &amp;:hover &#123; opacity: .8; &#125; &amp;.disabled &#123; &amp;:hover &#123; opacity: 1; cursor: not-allowed; &#125; &#125;&#125;// 超出部分处理.text-overflow() &#123; overflow: hidden; text-overflow: ellipsis; -o-text-overflow: ellipsis; -webkit-text-overflow: ellipsis; -moz-text-overflow: ellipsis; white-space: nowrap;&#125;// reset styles.reset() &#123;// ....&#125;// 一些原子class.atom() &#123; .cp &#123; cursor: pointer; &#125; .ml-5 &#123; margin-left: 5px; &#125; .mr-5 &#123; margin-right: 5px; &#125; .ml-5p &#123; margin-left: 5%; &#125; .mr-5p &#123; margin-right: 5%; &#125; .mt-5 &#123; margin-top: 5px; &#125; .txt-center &#123; text-align: center; &#125; .txt-left &#123; text-align: left; &#125; .txt-right &#123; text-align: right; &#125; .fr &#123; float: right; &#125; .fl &#123; float: left; &#125;&#125; component的less为了降低组件的耦合性，每个组件的less必须单独写，样式跟着组件走，一个组件一个less，不要有其他依赖，保证组件的高移植能力。而且组件应该针对用途提供几套样式方案，比如button组件，我们可以针对颜色提供不同的样式，以样式组合的方式提供给外部使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 下面的变量可以针对不同的需求进行配置@color-primary: #459df5;@color-warning: #f7cec8;@color-success: #98cf07;@color-fail: #c21f16; .btn &#123; cursor: pointer; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; display: inline-block; box-sizing: border-box; -webkit-box-sizing: border-box; -ms-box-sizing: border-box; -moz-box-sizing: border-box; -o-box-sizing: border-box; text-align: center; // 鼠标放上时 &amp;:hover &#123; opacity: .8; &#125; // 按钮不可用时 &amp;.disabled &#123; &amp;:hover &#123; opacity: 1; cursor: not-allowed; &#125; &#125; // 填充式按钮 &amp;.full &#123; color: #fff; &amp;.primary &#123; background-color: @color-primary; border: 1px solid @color-primary; &#125; // .... &#125; // 边框式按钮 &amp;.border &#123; background-color: #fff; &amp;.primary &#123; color: @color-primary; border: 1px solid @color-primary; &#125; // ... &#125;&#125; container的less同上，每个container一个less文件，可以复用的模块尽量封装成component，而不是偷懒复制几行样式过来，这样虽然方便一时，但随着项目的迭代，后期的冗余代码会多得超出你的想象。如果遵循组件化的设计思想，你会发现container里其实只有一些布局和尺寸定义相关的代码，非常容易维护。 这是大型项目的设计要领，除此之外就是大局观的培养，这点尤为重要，项目一拿来不要马上就动手写页面，而是应该多花些时间在代码的设计上，把全局的东西剥离出来，越细越好；把可复用的模块设计成组件，思考组件的拓展性和不同的用途，记住—— 结构上尽量减少依赖关系，保持组件的独立性，而用途上多考虑功能的聚合，即所谓的低耦合高聚合。 不过实际项目不可能每个组件都是独立存在的，有时我们为了进一步减少代码量，会把一些常用的组件整合成一个大组件来使用，即复合组件。所以每个项目实际上存在一级组件（独立）和二级组件（复合）。一级组件可以随意迁移，而二级组件是针对实际场景而生的，两者并没有好坏之分，一切都为了高效地生产代码，存在即合理。 关于React的组织本项目的React代码都用JavaScript的ES6风格编写，代码非常地优雅，而且语言自身支持模块化，再也不用依赖Browserify、RequireJS等工具了，非常爽。如果你不会ES6，建议去翻一翻阮一峰老师的《ES6标准入门》 入口入口模块index.js放在src的根目录，是外部调用的入口。1234567891011121314151617181920import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;// 引入reduximport &#123; Provider &#125; from &apos;react-redux&apos;// 引入routerimport &#123; Router, hashHistory &#125; from &apos;react-router&apos;import &#123; syncHistoryWithStore &#125; from &apos;react-router-redux&apos;import routes from &apos;./routes&apos;import configureStore from &apos;./configureStore&apos;const store = configureStore(hashHistory) // 路由的storeconst history = syncHistoryWithStore(hashHistory, store) // 路由的历史纪录（会写入到浏览器的历史纪录）render( ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt; &lt;/Provider&gt; ), document.getElementById(&apos;root&apos;)) 路由这里主要应用了react-route组件来制作哈希路由，使用方式很简单，和ReactNative里的Navigator组件类似。 1234567891011121314151617181920212223import React from &apos;react&apos;import &#123; Route &#125; from &apos;react-router&apos;import Manager from &apos;./containers/manager&apos;import Login from &apos;./containers/Login/&apos;import Register from &apos;./containers/Register/&apos;import Password from &apos;./containers/Password/&apos;import Dashboard from &apos;./containers/Dashboard/&apos;const routes = ( &lt;Route&gt; &lt;Route path=&quot;&quot; component=&#123;Manager&#125;&gt; // 主容器 &lt;Route path=&quot;/&quot; component=&#123;Dashboard&#125; /&gt; // 仪表盘 // .... 各模块的container &lt;/Route&gt; &lt;Route path=&quot;login&quot; component=&#123;Login&#125; /&gt; // 登录 &lt;Route path=&quot;register&quot; component=&#123;Register&#125; /&gt; // 注册 &lt;Route path=&quot;password&quot; component=&#123;Password&#125; /&gt; // 找回密码 &lt;/Route&gt;)export default routes 了解action、store、reducer从调用关系来看如下所示：1store.dispatch(action) --&gt; reducer(state, action) --&gt; final state 来个实际的例子： 123456789101112131415161718192021222324252627282930// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: &apos;xx&apos;&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case &apos;add_todo&apos;: return state.concat(action.text); default: return state; &#125;&#125;;// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log(&apos;state is: &apos; + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: &apos;add_todo&apos;, text: &apos;读书&apos;&#125;);// 打印出修改后的stateconsole.log(&apos;state is: &apos; + store.getState()); // state is: 读书store.dispatch(&#123;type: &apos;add_todo&apos;, text: &apos;写作&apos;&#125;);console.log(&apos;state is: &apos; + store.getState()); // state is: 读书,写作 store、reducer、action关联store：对flux有了解的同学应该有所了解，store在这里代表的是数据模型，内部维护了一个state变量，用例描述应用的状态。store有两个核心方法，分别是getState、dispatch。前者用来获取store的状态（state），后者用来修改store的状态。 123456789101112// 创建store, 传入两个参数// 参数1: reducer 用来修改state// 参数2(可选): [], 默认的state值,如果不传, 则为undefinedvar store = redux.createStore(reducer, []);// 通过 store.getState() 可以获取当前store的状态(state)// 默认的值是 createStore 传入的第二个参数console.log(&apos;state is: &apos; + store.getState()); // state is:// 通过 store.dispatch(action) 来达到修改 state 的目的// 注意: 在redux里,唯一能够修改state的方法,就是通过 store.dispatch(action)store.dispatch(&#123;type: &apos;add_todo&apos;, text: &apos;读书&apos;&#125;); action：对行为（如用户行为）的抽象，在redux里是一个普通的js对象。redux对action的约定比较弱，除了一点，action必须有一个type字段来标识这个行为的类型。所以，下面的都是合法的action 123&#123;type:&apos;add_todo&apos;, text:&apos;读书&apos;&#125;&#123;type:&apos;add_todo&apos;, text:&apos;写作&apos;&#125;&#123;type:&apos;add_todo&apos;, text:&apos;睡觉&apos;, time:&apos;晚上&apos;&#125; reducer：一个普通的函数，用来修改store的状态。传入两个参数 state、action。其中，state为当前的状态（可通过store.getState()获得），而action为当前触发的行为（通过store.dispatch(action)调用触发）。reducer(state, action) 返回的值，就是store最新的state值。 123456789101112// reducer方法, 传入的参数有两个// state: 当前的state// action: 当前触发的行为, &#123;type: &apos;xx&apos;&#125;// 返回值: 新的statevar reducer = function(state, action)&#123; switch (action.type) &#123; case &apos;add_todo&apos;: return state.concat(action.text); default: return state; &#125;&#125; @参考 《Redux系列01：从一个简单例子了解action、store、reducer》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"},{"name":"Redux","slug":"Redux","permalink":"http://jafeney.com/tags/Redux/"}]},{"title":"基于Redux架构的单页应用开发总结（一）","date":"2016-06-07T16:02:20.000Z","path":"2016/06/08/2016-06-07-redux/","text":"写在前面 “大学四年，细细回味。大一，面带稚嫩的面庞，一腔傻傻的热情。可爱帅气的小涵妹，带我认识时尚，好基友终生难忘。大二，踏上程序员之旅，曦点无缘，Smart不弃，恩师点拨学长提携，滴水之恩涌泉报。大三，有了自己的团队，乐雁老朱，编程游戏我们都在一起。项目经验，点点积累，低下小中探寻的是学以致用的真理。大四，杭州漂泊的一年，八爱到贝贝，小公司磨练，大公司学习，前端工程师之路，勇往直行！振哥、超哥，带我实践和探索，彰显、健芬，让我开眼和提升自己。你们是我的良师益友，感谢每一段的指点。现在，新的团队，可靠的后背，我们不畏惧任何艰辛，未来如何，乐意笑迎！” 好久没更新博客了，因为这段时间一直被项目进度和毕业的事情压的透不过气，公司学校之间来回奔波了许久。好在，顺利完成了毕业任务，公司的项目最后也按时交付，总算可以缓下来写写文章了。接下来我会分几篇把近期开发的基于Redux的单页应用来一次技术剖析。 系统架构介绍本项目开发基于 React + Redux + React-Route 框架，利用 webpack 进行模块化构建，前端编写语言是 JavaScript ES6，利用 babel进行转换。 123456789101112131415161718|--- project |--- build // 项目打包编译目录 |--- src // 项目开发的源代码 |--- actions // redux的动作 |--- components // redux的组件 |--- containers // redux的容器 |--- images // 静态图片 |--- mixins // 通用的函数库 |--- reducers // redux的store操作 |--- configureStore.js // redux的store映射 |--- index.js // 页面入口 |--- routes.js // 路由配置 |--- index.html // 入口文件 |--- .babelrc // babel配置 |--- main.js // webkit打包的壳子 |--- package.json // 包信息 |--- webpack.config.js // webpack配置文件 |--- readme.md 1234567891011121314151617181920212223242526272829303132333435&quot;dependencies&quot;: &#123; &quot;babel-polyfill&quot;: &quot;^6.7.4&quot;, &quot;base-64&quot;: &quot;^0.1.0&quot;, &quot;immutable&quot;: &quot;^3.7.6&quot;, &quot;isomorphic-fetch&quot;: &quot;^2.2.1&quot;, &quot;moment&quot;: &quot;^2.13.0&quot;, &quot;normalizr&quot;: &quot;^2.0.1&quot;, &quot;react&quot;: &quot;^0.14.8&quot;, &quot;react-datetimepicker&quot;: &quot;^2.0.0&quot;, &quot;react-dom&quot;: &quot;^0.14.8&quot;, &quot;react-redux&quot;: &quot;^4.4.1&quot;, &quot;react-redux-spinner&quot;: &quot;^0.4.0&quot;, &quot;react-router&quot;: &quot;^2.0.1&quot;, &quot;react-router-redux&quot;: &quot;^4.0.1&quot;, &quot;redux&quot;: &quot;^3.3.1&quot;, &quot;redux-immutablejs&quot;: &quot;0.0.8&quot;, &quot;redux-logger&quot;: &quot;^2.6.1&quot;, &quot;redux-thunk&quot;: &quot;^2.0.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.7.5&quot;, &quot;babel-loader&quot;: &quot;^6.2.4&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.5.0&quot;, &quot;babel-preset-stage-1&quot;: &quot;^6.5.0&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;file-loader&quot;: &quot;^0.8.5&quot;, &quot;img-loader&quot;: &quot;^1.2.2&quot;, &quot;less&quot;: &quot;^2.6.1&quot;, &quot;less-loader&quot;: &quot;^2.2.3&quot;, &quot;mocha&quot;: &quot;^2.4.5&quot;, &quot;style-loader&quot;: &quot;^0.13.1&quot;, &quot;url-loader&quot;: &quot;^0.5.7&quot;, &quot;webpack&quot;: &quot;^1.12.14&quot; &#125; webpack配置也算是实际体验了一把webpack，不得不说，论React最佳搭档，非此货莫属！真的很强大，很好用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var webpack = require(&apos;webpack&apos;); // 引入webpack模块var path = require(&apos;path&apos;); // 引入node的path模块var nodeModulesPath = path.join(__dirname, &apos;/node_modules&apos;); // 设置node_modules目录module.exports = &#123; // 配置入口（此处定义了双入口） entry: &#123; bundle: &apos;./src/index&apos;, vendor: [&apos;react&apos;, &apos;react-dom&apos;, &apos;redux&apos;] &#125;, // 配置输出目录 output: &#123; path: path.join(__dirname, &apos;/build&apos;), publicPath: &quot;/assets/&quot;, filename: &apos;bundle.js&apos; &#125;, module: &#123; noParse: [ path.join(nodeModulesPath, &apos;/react/dist/react.min&apos;), path.join(nodeModulesPath, &apos;/react-dom/dist/react-dom.min&apos;), path.join(nodeModulesPath, &apos;/redux/dist/redux.min&apos;), ], // 加载器 loaders: [ // less加载器 &#123; test: /\\.less$/, loader: &apos;style!css!less&apos; &#125;, // babel加载器 &#123; test: /\\.js$/, exclude: /node_modules/, loader: &apos;babel-loader&apos; &#125;, // 图片加载器（图片超过8k会自动转base64格式） &#123; test: /\\.(gif|jpg|png)$/, loader: &quot;url?limit=8192&amp;name=images/[name].[hash].[ext]&quot;&#125;, // 加载icon字体文件 &#123; test: /\\.(woff|svg|eot|ttf)$/, loader: &apos;url?limit=50000&amp;name=fonts/[name].[hash].[ext]&apos;&#125; ] &#125;, // 外部依赖（不会打包到bundle.js里） externals: &#123; &apos;citys&apos;: &apos;Citys&apos; &#125;, // 插件 plugins: [ //new webpack.HotModuleReplacementPlugin(), // 版本上线时开启 new webpack.DefinePlugin(&#123; // 定义生产环境 &quot;process.env&quot;: &#123; NODE_ENV: JSON.stringify(&quot;production&quot;) &#125; &#125;), //new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), // 版本上线时开启 // 公共部分会被抽离到vendor.js里 new webpack.optimize.CommonsChunkPlugin(&apos;vendor&apos;, &apos;vendor.js&apos;), // 比对id的使用频率和分布来得出最短的id分配给使用频率高的模块 new webpack.optimize.OccurenceOrderPlugin(), // 允许错误不打断程序 new webpack.NoErrorsPlugin() ],&#125;; 延伸－Webpack性能优化最小化为了瘦身你的js（还有你的css，如果你用到css-loader的话）webpack支持一个简单的配置项： 1new webpack.optimize.UglifyJsPlugin() 这是一种简单而有效的方法来优化你的webapp。而webpack还提供了modules 和 chunks ids 来区分他们俩。利用下面的配置项，webpack就能够比对id的使用频率和分布来得出最短的id分配给使用频率高的模块。 1new webpack.optimize.OccurenceOrderPlugin() 入口文件对于文件大小有较高的优先级（入口文件压缩优化率尽量的好） 去重如果你使用了一些有着很酷的依赖树的库，那么它可能存在一些文件是重复的。webpack可以找到这些文件并去重。这保证了重复的代码不被大包到bundle文件里面去，取而代之的是运行时请求一个封装的函数。不会影响语义 1new webpack.optimize.DedupePlugin() 这个功能可能会增加入口模块的一些花销 对于chunks的优化当coding的时候，你可能已经添加了许多分割点来按需加载。但编译完了之后你发现有太多细小的模块造成了很大的HTTP损耗。幸运的是Webpack可以处理这个问题，你可以做下面两件事情来合并一些请求： Limit the maximum chunk count with 1new webpack.optimize.LimitChunkCountPlugin(&#123;maxChunks: 15&#125;) Limit the minimum chunk size with 1new webpack.optimize.MinChunkSizePlugin(&#123;minChunkSize: 10000&#125;) Webpack通过合并来管理这些异步加载的模块(合并更多的时候发生在当前这个chunk有复用的地方)。文件只要在入口页面加载的时候没有被引入，那么就不会被合并到chunk里面去。 单页Webpack 是为单页应用量身定做的 你可以把app拆成很多chunk，这些chunk由路由来加载。入口模块仅仅包含路由和一些库，没有别的内容。这么做在用户通过导航浏览表现很好，但是初始化页面加载的时候你需要2个网络请求：一个是请求路由，一个是加载当前内容。 如果你利用HTML5的HistoryAPI 来让URL影响当前内容页的话。你的服务器可以知道那个内容页面将被客户端请求。为了节约请求数，服务端可以把要请求的内容模块放到响应头里面：以script标签的形式来添加，浏览器将并行的加载这俩请求。 12&lt;script src=&quot;entry-chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;script src=&quot;3.chunk.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 你可以从build stas里面提取出chunk的filename （stats-webpack-plugin ） 多页当编译一个多页面的app时，你想要在页面之间共享一些代码。这在webpack看来很简单的：只需要和多个入口文件一起编译就好 1webpack p1=./page1 p2=./page2 p3=./page3 [name].entry-chunk.js 12345678910module.exports = &#123; entry: &#123; p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot; &#125;, output: &#123; filename: &quot;[name].entry.chunk.js&quot; &#125;&#125; 由上面可以产出多个入口文件 1p1.entry.chunk.js, p2.entry.chunk.js and p3.entry.chunk.js 但是可以增加一个chunk来共享她们中的一些代码。 如果你的chunks有一些公用的modules，那我推荐一个很酷的插件CommonsChunkPlugin，它能辨别共用模块并把他们放倒一个文件里面去。你需要在你的页面里添加两个script标签来分别引入入口文件和共用模块文件。 1234567891011121314var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);module.exports = &#123; entry: &#123; p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot; &#125;, output: &#123; filename: &quot;[name].entry.chunk.js&quot; &#125;, plugins: [ new CommonsChunkPlugin(&quot;commons.chunk.js&quot;) ]&#125; 由上面可以产出入口文件 1p1.entry.chunk.js, p2.entry.chunk.js and p3.entry.chunk.js 和共用文件 1commons.chunk.js 在页面中要首先加载 commons.chunk.js 在加载xx.entry.chunk.js 你可以出实话很多个commons chunks ，通过选择不同的入口文件。并且你可以堆叠使用这些commons chunks。 1234567891011121314151617var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);module.exports = &#123; entry: &#123; p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, p3: &quot;./page3&quot;, ap1: &quot;./admin/page1&quot;, ap2: &quot;./admin/page2&quot; &#125;, output: &#123; filename: &quot;[name].js&quot; &#125;, plugins: [ new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]), new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;]) ]&#125;; 输出结果：12345page1.html: commons.js, p1.jspage2.html: commons.js, p2.jspage3.html: p3.jsadmin-page1.html: commons.js, admin-commons.js, ap1.jsadmin-page2.html: commons.js, admin-commons.js, ap2.js 另外你可以将多个共用文件打包到一个共用文件中。 1234567891011var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);module.exports = &#123; entry: &#123; p1: &quot;./page1&quot;, p2: &quot;./page2&quot;, commons: &quot;./entry-for-the-commons-chunk&quot; &#125;, plugins: [ new CommonsChunkPlugin(&quot;commons&quot;, &quot;commons.js&quot;) ]&#125;; ## @参考 赵飞 《webpack 性能优化》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"},{"name":"Redux","slug":"Redux","permalink":"http://jafeney.com/tags/Redux/"}]},{"title":"互联网公司如何管理研发团队","date":"2016-05-13T08:51:53.000Z","path":"2016/05/13/2016-05-13-manage/","text":"写在前面 之前在小公司当个小小的前端技术主管，就算带个2、3人的团队也觉得有很多问题需要沟通和调停，尤其是对下属的代码质量和开发进度把控上很是头疼。所以我更无法想象，像阿里、网易那样的大公司，尽千人甚至上万人的研发团队应该如何管理呢？带着学习和自我提高的心态，我放弃毕业前高薪的工资来到一家正处于上升热头的互联网公司，从一个实习生做起。放下所有架子，摈弃所谓的傲气，从零开始体验互联网公司的运转模式。下面分享一下我尽3个月来的感悟。 需求管理平台 Req在互联网公司，每天都会有不同的需求被反馈，可能是线上bug、可能是用户体验优化、也可能是新的项目需求等等。这些需求按类别可以分为三类：日常需求、缺陷需求、项目需求。与之对应的有3个管理池：需求池、缺陷池和项目池。 需求池需求池里可以建立简单的日常需求，这些需求一般是一对一可以指派的问题。比如运营提出的可以提高用户体验的一些优化建议、UI提出的视觉方面的修改和调整。这些问题一般不属于线上BUG，可以短期（1到2天）内修复上线的。日常需求的生命周期如下： 1建需求 －&gt; 拉分支 －&gt; 本地开发测试 －&gt; 代码评审 - &gt; 预发布验证 -&gt; 正式发布验证 缺陷池缺陷池是给测试部门使用的。无论是日常需求还是项目发布都会有测试工程师介入测试，测试过了才能发上线。测试过程中发现的一切问题都要如是记录在缺陷池里，指明对应的责任人和处理人，并跟踪此缺陷的生命周期。缺陷按照严重性可以分为P0～P5，P0最为严重，一般发生P0缺陷，整个网站或者系统将无法正常运行，责任人和处理人需要在1个小时之内解决，如果解决不了需要立即回滚代码。如果你造成P0缺陷，那么对不起，轻则季度考核不合格，重则直接劝退。而P级数字越大，缺陷严重程度越低。不过如果无法在规定时间内解决该缺陷，会自动上升一级。所以一旦出现缺陷，压力还是很大的，开发工程师应该在自测完全没问题之后才能申请测试工程师进行专业型测试。 项目池一般一个需求的生命周期超过8天的必须申请立项——即成为一个单一项目进行管理。一个项目完整的生命周期如下：1需求评审 -&gt; 产品出文档和交互 -&gt; UI 制作视觉稿、标注稿 -&gt; 后端给出Mock数据接口 --&gt; 前端编写页面，绑定数据 --&gt;视觉UI走查 --&gt; 前后端线下连调 --&gt; 后端接口上线 --&gt; 用例测试 ---&gt; 前端页面上线 --&gt; 用户反馈和优化 每个项目会有一个产品经理、项目经理整体跟进，如果项目成员多的会设立专门的项目室（所谓的“小黑屋“）进行开发和沟通，以提高沟通效率。 wiki文档管理平台 Doc每个研发团队都需要有一个统一的平台来管理一些文档，包括接口的API文档、代码规范、最佳实践和技术分享等东西。在互联网公司我们不会写一大堆的word文档或者整一些PPT，所有的文档都采用markdown语法编写，简约又易于分享。 接口API文档接口文档的作用是为了前后端解耦。现在前后端分离的开发模式已经深入人心的，如果你还发现你的公司仍然搞一大堆什么JSP、Smarty、Velocity、FreeMarker等所谓的后端模板引擎的，赶紧告诉他们已经Ou t了！前端模板引擎的性能和用户体验都远远高于后端。呵呵，可能这时远方飘飘然会传来一声不屑——胡扯，后端模板引擎的性能怎么会输给前端呢？会这么想你肯定不知道前端模板引擎强大的预编译功能——模板引擎再厉害还是会有编译过程，预编译则把编译事先做了。 好了回归主题，规范的接口API文档应该包含以下几个内容：第一：接口的用途第二：接口的类型、是否需要登录第三：接口的参数列表和字段说明第四：接口成功返回的数据字段说明第五：接口失败返回的数据字段说明第六：接口对应的mock数据入口 代码规范说到代码规范，各个团队有所不同。前端、后端、客户端、测试、大数据等各有各的代码规范。代码规范的作用是统一编码风格，提高代码复用能力。这个规范可以是长期开发经验积累整理的一套编码风格。前端的话应该包括：文件命名规范、HTML文档规范、less或Sass编写规范、JavaScript编码规范等。代码规范应该随着变成语言的升级而不断更新，并且每次更新后应该对每位开发人员进行代码规范 考试。 最佳实践最佳实践是指针对某个问题总结出的最佳的处理方式，可以是代码片段、设计模式或框架设计等。每次项目完成之后应该做这样的总结工作，梳理一下项目的脉络和技术实现，思考性能优化和用户体验细节提升的技巧，然后积土成山，并长期维护和更新，构建团队自己的技术栈。 技术分享技术分享应该以专题的方式进行，理论上团队每个成员定期都应该做特定专题的技术分享，并和各自的绩效挂钩。分享方式很简单，演示文稿和markdown文档，如果是技术实践应该还有配套的demo代码，最好在小组的周会上进行，鼓励讨论和反驳，一起进步。最后这些分享资料以期刊形式进行整理和出版，构建团队的技术栈。 开发管理平台开发管理平台主要用于开发过程中的所有流程的把控和个人质量统计。这个平台应该和需求管理平台以及代码管理平台联通，协同使用。 个人缺陷管理该模块可以反应开发者目前的代码质量水平，统计扣分情况。上面说了代码缺陷等级分为P0～P5，开发者一旦出现缺陷会被统计在缺陷池里，并以扣分的形式呈现在这里。并且扣分排名前30名会上榜，全公司的开发人员都可以看到，互相督促。 开发任务跟踪该模块里会呈现开发人员当前的任务队列，每个开发任务的生命周期只要没有走完，都可以申请发布计划或取消发布，任务一旦发布成功该任务就会从列表里隐藏。 发布计划开发任务一旦成功生成发布计划，会自动从trunk里产生新的分支，并给出新生成的分支号，然后开发者把代码切到该分支，在此分支上进行新的开发。 代码评审 codeReview开发者一旦完成本地开发并自测没有问题，申请发布前必须先经过上一级的代码评审。代码评审包括编码风格审查，代码执行效率、业务逻辑实现的性能等多方面的排查。评审通过了才允许继续发布。否则打回上一步，问题修改完成后继续提交评审。 代码发布代码评审通过后，会进入当天的发布队列。 发布队列平台管理员每天在规定时间把发布队列里的发布计划进行预发布操作，即把分支合并到trunk。 预发布代码正式发布前先进入预发布环境。预发布环境和正式环境一模一样，测试人员需要把本地的hosts配置成预发布的IP地址。然后进行预发布验证。验证如果不通过会被打回，开发人员需要在30分钟内进行修改，问题解决后管理员会重新合并代码，继续预发布验证。超时或无法解决问题，回滚代码。该发布计划失败。 正式发布预发布验证没问题了，发布队列里的任务会进入正式环境。测试人员需要把本地hosts配置成正式的IP地址。然后进行正式发布验证，一般不会再出现问题。 紧急发布每天进行发布的时间是规定的。过了规定的发布时间如果还需要发布代码的，需要走紧急发布。紧急发布每个开发人员都有次数限制，一般如果存在未知风险或涉及核心代码的，不允许紧急发布。 代码回滚如果正式环境出现问题，在规定时间内开发人员无法解决的，必须回滚到上一个版本。 代码管理平台 gitLab、SVN每个开发团队都需要一个代码管理工具，svn或者git 是目前常用的工具之一。如果使用svn则只需要提供两台svn服务器（正式和预发）。如果使用git则需要搭建gitLab作为代码的私有仓库。 分支管理开发统一拉分支进行开发，然后合并到trunk。并且trunk上一般开发人员没有写的权限，保护trunk的安全。 版本控制各分支之间允许合并和回滚，由开发人员自己管理。 团队管理平台 team每个小组应该成立一个team平台进行管理。在这个平台上可以查看队伍各个成员之间的工作情况（日报、周报、项目进度等） 日报每日一报，写一下今天做的日常需求，如果是项目，就写一下项目的进度。 周报每周一报。本周工作总结和下周工作计划。 项目进度开发管理平台各自的任务的生命周期应该同步到这里。方便你的leader进行查看和工作汇报。 员工管理平台 oa这个几乎每个公司都有，就不介绍了。 规章制度保密。 人事流程请假、考勤、打卡、离职、入职等。 场地申请会议场地、项目室申请。 会议通知会议开始前会定时通知与会人员。 组织架构研发团队是互联网公司强大的后盾，“养“着一群技术人员。这些人员不仅更具岗位职能进行划分。还有一个更重要的分法是根据工作性质进行分配。 业务部负责新业务开发和旧业务的维护。 基础部负责开发服务化工具和大数据分析。 系统部 负责系统架构设计和新技术研究。 运维部负责服务器管理和维护。 质量保证部 我们的测试工程师同胞们。 注意：本文不要随意转发哦 ^_^","categories":[{"name":"人生感悟","slug":"人生感悟","permalink":"http://jafeney.com/categories/人生感悟/"}],"tags":[{"name":"团队建设","slug":"团队建设","permalink":"http://jafeney.com/tags/团队建设/"}]},{"title":"Redux和Reflux研究","date":"2016-05-12T06:24:11.000Z","path":"2016/05/12/2016-05-12-redux/","text":"写在前面 在开始全新的React项目前，先好好研究一下React两个典型的“轮子”，Reflux和Redux。两者没有明确的优劣之分，只是对初学者来说Reflux容易理解，而Redux的单一state在项目开发中非常好用，所以你可能发现Github上Redux的星星比Reflux略多些吧。但是见智者见智，两者其实都是社区同仁智慧的结晶。 Redux先谈谈对Redux的理解。 独特性第一一个数据层的framework，类似于Baobab。比其好的一点，引入middleware体系，有几个现成的插件redux-thunk, redux-promise，不用但心异步请求的事。虽然说灵活、独立很重要，但全局设计也是 让人放心去用，而不用担心功能缺失和其它风险。 第二 应用了FP中数据不可变性（immutable），这让追踪数据改变过程有很大提升。也就是其宣扬的时间旅行。这对复杂问题定位是有好处的。 第三树形化数据存储，reducer的返回即是其新建，更新、删除过程，树形结构不需要预先定义。同时，reducer也是纯函数，与reactor的render是纯函数呼应。 第四强约束（约定），增加了内聚合性。Flux中的action, dispatcher, store比较散，在分层架构是需要的，但内聚性不佳，出现java的仪式感。而Redux是数据层很清晰，一个store，更新则dispatch到action，前半段自己想怎么搞就怎么搞(middleware），后半段reducer。reducer约束是不要改oldState，返回newStatew，做到immutable。 第五不一样的action：Redux中的action会切得很细，一个传统的Action被切成了三个Action：Loading, GetSuccess, GetError。所以，从这个方面来看Action服务于UI，而非业务逻辑单元。 第六Redux大量应用FP，经常遇到FP中的curry, trund, promise这些概念，学习成本较高。在middleware层实现，对没有FP经验的人讲不友好。 置Redux于上下文中Redux是一个比较薄的数据层。同时，把View同步刷新也做了（redux-react）。 在传统MVC中，还是有一个controller来做业务逻辑。但Redux硬生生的把一个controller切成二部分:action, reducer。 理论上，Redux还可以把React组件中的state的存储也拿过来，比如用户搜索的名称。这样，就可以把过滤算法放到selector中去。但这样好处并不是很大。 对比其他方案与Baobab对比，两者都是数据管理框架，Baobab提供cursor来方便你对很深层的数据结构进行update。而Redux是通过selector函数来做，这种方法会比较晦涩。但比Baobab好的地方，做数据fetch可以通过Redux的middleware来完成。 与Rails的controller, ActionRecord相比，Redux更多是一种约定，不提供路由级的controller，不提供数据访问cursor。 Redux接口不超过10个，代码也非常少，但是与之前的MVC框架完全不同。可能最大的问题是没有和react-route打通，在工程化时让人迷茫。 挑战Redux应用最大的挑战更多来自设计层面，如何设计action，设计state树形结构。我们只能通过非常少的线索（FP架构思想）去做，这对没有FP经验的团队是一个大挑战。 通过selector函数从stat树里取数据比较晦涩，并且这个selector里的代码认为是业务逻辑，单独放在selector，业务上不内聚。 middleware层设计：action是一个意图(intent），发送给middleware，让其来实现此意图。但这样做，action比有两义性，一会儿是对象，一会儿是函数。同时FP编程侵入性太大。 没有与Route结合起来设计，让人很不放心，也不知道如何在不同路由下来做数据与组件的connect。 OO与FP编程范式对决 react + redux是一种典型的FP编程范式实现，而其它框架大多是OO范式。是否选用react+redux开发，需要看是否对FP有掌握或者有一定的架构能力。但单独用react则没有这种要求，当个view来用。 FP优缺点FP的好处是没有OO的复杂仪式感，是沿着数据结构+算法的思路进行抽象和结构化。如果顶层设计做好，代码复用度极高，代码量少。比如要生成一颗树我用迭归算法直接生成，而OO的人往往会用一个Composite模式去定义一个晦涩的类接口。 FP的缺点也是也是面向过程编程的缺点，算法与数据全局化、并且互相耦合，这往往会导致一个强耦合的系统。如果没有做好顶层设计，是难以演进的。 通过约定和全局的理解，可以减少FP的一些缺点。“约定大于配置”也是框架的主要发展方向。 OO优缺点OO的好处是分而治之，增量演进。同时有自闭性，语义比较清晰。 缺点是在表达一些算法时，反而是很困难的。如command模式实现历史回滚就挺麻烦。也这是四人帮的设计模式大多比较难以理解的原因。另外，OO一直有一个对算法复用的问题，ruby语言解决比较好，用mixin很自然。而像C++就用多继承和泛型，个人感觉并不是最好的。 建议有FP经验的或者架构能力比较强，团队人员比较少、能力强，较强适合用react+redux。不然用react+angluar, 或直接用vue。而且过度的OO，搞太多java仪式感确实没有必要。通过架构设计，FP在生产力有着一定的优势。同时对付复杂系统，能更好调测、定位问题。在新时代下，值得尝试。 Reflux 和 Redux已经认识了Redux，而相比较Redux而言，Reflux没有reducer的概念，取而代之，和action做基友的是store。Reflux的功能流程如下： 组件就是用户界面，actions就是组件的动作，store用于执行actions的命令，并返回一个state对象给组件。组件通过state来更新界面。 而Redux的流程如下： state就是数据，组件就是数据的呈现形式，action是动作，action是通过reducer来更新state的。 Reflux没有把状态的一部分值绑定在组件的props上，而是将状态绑定在组件的state上，请看 react dev tool的截图: Reflux可以直接调用action的方法，而Redux必须将方法绑定在组件的props上，或者使用props的dispatch方法来执行actions的方法。 @参考 百草赵斌 《深入理解React、Redux》@参考 这里写代码片 《react＋relux入门教程》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"}]},{"title":"React在ES6中的用法","date":"2016-04-22T10:22:19.000Z","path":"2016/04/22/2016-04-22-react-ES6/","text":"写在前面 不管是多么不乐意待见这个不速之客，但ES6已经一点点渗透进了我的生活里，就连我最爱的React到React Native，默认都把ES6做为首选标准。这是FaceBook有计划、有声势地要把ES6推起来，请问还有谁有狗胆站住来堵着路不走。所以我毅然捧着阮一峰老师的《ES6标准入门》在一旁看了起来……那好，今天就谈谈如何把React用ES6愉快地跑起来。 入门级Demos先来几个简单的demo体验一把。注意，例子里ES5的require请通过browserfiy或webpack来实现，如果你还不会用这两样东西，请出门后往前看。 “Hello,XXX”输出ES5写法： 1234567891011121314151617var React = require(&apos;react&apos;);var HelloMessage = React.createClass(&#123; render: function() &#123; return (&lt;h1&gt;Hello,&#123;this.props.name&#125;!&lt;/h1&gt;); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;HelloMessage name = &quot;John&quot; /&gt; &lt;/div&gt; ); &#125;&#125;); ES6写法： 1234567891011121314151617181920212223import React,&#123;Component&#125; from &apos;react&apos;;class HelloMessage extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;class Output extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;HelloMessage name=&quot;John&quot; /&gt; &lt;/div&gt; ); &#125;&#125;export default Output; 数组遍历显示ES5写法： 1234567891011121314151617181920var React = require(&apos;react&apos;);var RepeatArray = React.createClass(&#123; render: function() &#123; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; var arrs = [ &lt;h1&gt;Hello World&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt; ]; return ( &lt;div&gt; &#123;arr&#125; &#123; names.map(function (name) &#123;return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt;;&#125;); &#125; &lt;/div&gt; ); &#125;&#125;);module.exports = RepeatArray; ES6写法： 12345678910111213141516171819202122import React,&#123;Component&#125; from &apos;react&apos;;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, ]; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; return ( &lt;div&gt; &#123;arr&#125; &#123; names.map((name) =&gt;&#123;return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt;;&#125; ) &#125; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; ol与li的实现ES5写法: 1234567891011121314151617181920212223242526var React = require(&apos;react&apos;);var RepeatLi = React.createClass(&#123; render: function() &#123; return( &lt;ol&gt; &#123; this.props.children.map(function(child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;); &#125; &lt;/ol&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;RepeatLi&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/RepeatLi&gt; &lt;/div&gt; ); &#125;&#125;); ES6写法： 123456789101112131415161718192021222324252627282930import React,&#123;Component&#125; from &apos;react&apos;;class RepeatLi extends Component&#123; render()&#123; return ( &lt;ol&gt; &#123; this.props.children.map((child)=&gt;&#123;return &lt;li&gt;&#123;child&#125;&lt;/li&gt;&#125;) &#125; &lt;/ol&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;RepeatLi&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/RepeatLi&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; Click事件ES5写法： 123456789101112131415161718192021222324var React = require(&apos;react&apos;);var MyComponent = React.createClass(&#123; handleClick: function() &#123; React.findDOMNode(this.refs.myTextInput).focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick= &#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;MyComponent /&gt; &lt;/div&gt; ); &#125;&#125;); ES6写法：123456789101112131415161718192021222324252627import React,&#123;Component&#125; from &apos;react&apos;;class FocusText extends Component&#123; handleClick()&#123; React.findDOMNode(this.refs.myText).focus(); &#125; render()&#123; return( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myText&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;focus the text input&quot; onClick=&#123;this.handleClick.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;FocusText /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; State的用法，以toggel显示文字为例ES5写法： 1234567891011121314151617181920212223var React = require(&apos;react&apos;);var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(e) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? &apos;like&apos; : &apos;haven\\&apos;t liked&apos;; return ( &lt;p onClick = &#123;this.handleClick&#125;&gt; You &#123;text&#125; this.Click to toggle. &lt;/p&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return (&lt;div&gt;&lt;LikeButton /&gt;&lt;/div&gt;); &#125;&#125;); ES6写法： 1234567891011121314151617181920212223242526272829303132333435import React,&#123;Component&#125; from &apos;react&apos;;class StateUse extends Component&#123; constructor()&#123; super(); this.state=&#123; like:true &#125; &#125; handleClick()&#123; this.setState(&#123;like:!this.state.like&#125;); &#125; render()&#123; var text = this.state.like?&apos;Like&apos;:&quot;Unlike&quot;; return( &lt;div&gt; &lt;p onClick=&#123;this.handleClick.bind(this)&#125;&gt; You &#123;text&#125; this.Click the toggle; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;StateUse /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; onChange事件，以及变量值的同步ES5写法： 1234567891011121314151617181920212223var React = require(&apos;react&apos;);var InputComponent = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: &apos;Hello!&apos;&#125;; &#125;, handleChange: function(e) &#123; this.setState(&#123;value: e.target.value&#125;) &#125;, render: function() &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChangle&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return (&lt;div&gt;&lt;InputComponent /&gt;&lt;/div&gt;) &#125;&#125;); ES6写法： 1234567891011121314151617181920212223242526272829303132333435import React,&#123;Component&#125; from &apos;react&apos;;class AsyncText extends Component&#123; constructor()&#123; super(); this.state=&#123; value:&apos;Hello!&apos; &#125; &#125; handleChange(e)&#123; this.setState(&#123;value:e.target.value&#125;); &#125; render()&#123; var value= this.state.value; return( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;p&gt; &#123;value&#125; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;AsyncText /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; 定时任务事件的嵌入ES5写法： 123456789101112131415161718192021222324252627282930313233var React = require(&apos;react&apos;);var Hello = React.createClass(&#123; getInitState: function() &#123; return &#123; opacity: 1.0 &#125;; &#125;, componentDidMount: function() &#123; this.timer = setInterval (function() &#123; var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) &#123; opacity = 1.0; &#125; this.setState(&#123; opacity: opacity &#125;); &#125;.bind(this), 100); &#125;, render: function() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return (&lt;div&gt;&lt;Hello name=&quot;world&quot; /&gt;&lt;/div&gt;); &#125;&#125;); ES6写法： 1234567891011121314151617181920212223242526272829303132333435363738394041import React,&#123;Component&#125; from &apos;react&apos;;class OpacityWord extends Component&#123; constructor()&#123; super(); this.state=&#123; opacity:1.0 &#125; &#125; componentWillMount()&#123; let time = setInterval(()=&gt;&#123; let opacity = this.state.opacity; opacity -= 0.5; if (opacity&lt;0.1) &#123; opacity=1.0; &#125; this.setState(&#123;opacity:opacity&#125;); &#125;.bind(this),100); &#125; render()&#123; return ( &lt;div style=&#123;&#123; opacity:this.state.opacity &#125;&#125;&gt; Hello, &#123;this.props.name&#125;! &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;OpacityWord /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; 从服务端获取数据ES5写法： 1234567891011121314151617181920212223242526272829303132333435var React = require(&apos;react&apos;);var UserGist = React.createClass(&#123; getInitState: function() &#123; return &#123; username: &apos;&apos;, lastGistUrl: &apos;&apos; &#125;; &#125;, componentDidMount: function() &#123; $.get(this.props.source, function(result) &#123; var lastGist = result[0]; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;); &#125;.bind(this)); &#125;, render: function() &#123; return ( &lt;div&gt; &#123;this.state.username&#125;s last gist is &lt;a href=&#123;this.state.lastGistUrl&#125;&gt; here &lt;/a&gt;. &lt;/div&gt; ); &#125;&#125;);module.exports = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt; &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt; &lt;/div&gt; ); &#125;&#125;); ES6写法： 123456789101112131415161718192021222324252627282930313233343536373839404142import React,&#123;Component&#125; from &apos;react&apos;;class UserGist extends Component&#123; constructor()&#123; super(); this.state=&#123; username:&apos;&apos;, lastGistUrl:&apos;&apos; &#125; &#125; componentWillMount()&#123; $.get(this.props.source, function(result) &#123; var lastGist = result[0]; //if (this.isMounted()) &#123; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;); //&#125; &#125;.bind(this)); &#125; render()&#123; return( &lt;div&gt; &#123;this.state.username&#125; .. &lt;a href=&#123;this.state.lastGistUrl&#125; &gt;here&lt;/a&gt; &lt;/div&gt; ); &#125;&#125;class RepeatArray extends Component&#123; constructor() &#123; super(); &#125; render()&#123; return ( &lt;div&gt; &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt; &lt;/div&gt; ); &#125;&#125;export default RepeatArray; React Native实战写一个简单的页面，支持输入关键字然后以列表形式呈现github里搜索出来的结果。效果如下： ES5写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&apos;use strict&apos;;var React = require(&apos;react-native&apos;);var &#123; Image, ListView, TextInput, AppRegistry, Component, StyleSheet, Text, View,&#125; = React;var BASE_URL = &quot;https://api.github.com/search/repositories?q=&quot;;var customView = React.createClass(&#123; getInitialState: function() &#123; return &#123; dataSource: new ListView.DataSource(&#123; rowHasChanged: (row1, row2) =&gt; row1 !== row2, &#125;), &#125;; &#125;, render: function() &#123; if (this.state.dataSource.getRowCount() === 0) &#123; console.log(&apos;YES&apos;); &#125; var content = this.state.dataSource.getRowCount() === 0 ? &lt;Text style=&#123;styles.blankText&#125;&gt; Please enter a search term to see results. &lt;/Text&gt; : &lt;ListView ref=&quot;listview&quot; dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderRow&#125; automaticallyAdjustContentInsets=&#123;false&#125; keyboardDismissMode=&quot;onDrag&quot; keyboardShouldPersistTaps=&#123;true&#125; showsVerticalScrollIndicator=&#123;false&#125; /&gt;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TextInput autoCapitalize=&quot;none&quot; autoCorrect=&#123;false&#125; placeholder=&quot;Search for a project...&quot; style=&#123;styles.searchBarInput&#125; onEndEditing=&#123;this.onSearchChange&#125;/&gt; &#123;content&#125; &lt;/View&gt; ); &#125;, onSearchChange: function(event: Object) &#123; var searchTerm = event.nativeEvent.text.toLowerCase(); var queryURL = BASE_URL + encodeURIComponent(searchTerm); fetch(queryURL) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; if (responseData.items) &#123; this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(responseData.items), &#125;); &#125; &#125;).done(); &#125;, renderRow: function(repo: Object) &#123; return ( &lt;View&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Image source=&#123;&#123;uri: repo.owner.avatar_url&#125;&#125; style=&#123;styles.profPic&#125;/&gt; &lt;View style=&#123;styles.textContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt; &#123;repo.name&#125; &lt;/Text&gt; &lt;Text style=&#123;styles.subTitle&#125;&gt; &#123;repo.owner.login&#125; &lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.cellBorder&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;,&#125;);var styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &apos;#ffffff&apos;, &#125;, searchBarInput: &#123; marginTop: 30, padding: 5, fontSize: 15, height: 30, backgroundColor: &apos;#EAEAEA&apos;, &#125;, row: &#123; alignItems: &apos;center&apos;, backgroundColor: &apos;white&apos;, flexDirection: &apos;row&apos;, padding: 5, &#125;, cellBorder: &#123; backgroundColor: &apos;rgba(0,0,0,0.1)&apos;, height: 1, marginLeft: 4, &#125;, profPic: &#123; width: 50, height: 50, &#125;, title: &#123; fontSize: 20, marginBottom: 8, fontWeight: &apos;bold&apos;, &#125;, subTitle: &#123; fontSize: 16, marginBottom: 8, &#125;, textContainer: &#123; paddingLeft: 10, &#125;, blankText: &#123; padding: 10, fontSize: 20, &#125;&#125;);AppRegistry.registerComponent(&apos;customView&apos;, () =&gt; customView); ES6写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import React, &#123; Image, ListView, TextInput, AppRegistry, Component, StyleSheet, Text, View,&#125;from &apos;react-native&apos;;const BASE_URL = &quot;https://api.github.com/search/repositories?q=&quot;;class customView extends Component &#123; constructor() &#123; super(); &#125; state = &#123; dataSource: new ListView.DataSource(&#123; rowHasChanged: (row1, row2) =&gt; row1 !== row2, &#125;), &#125; render() &#123; if (this.state.dataSource.getRowCount() === 0) &#123; console.log(&apos;YES&apos;); &#125; var content = this.state.dataSource.getRowCount() === 0 ? &lt;Text style=&#123;styles.blankText&#125;&gt; Please enter a search term to see results. &lt;/Text&gt; : &lt;ListView ref=&quot;listview&quot; dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;this.renderRow&#125; automaticallyAdjustContentInsets=&#123;false&#125; keyboardDismissMode=&quot;onDrag&quot; keyboardShouldPersistTaps=&#123;true&#125; showsVerticalScrollIndicator=&#123;false&#125; /&gt;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TextInput autoCapitalize=&quot;none&quot; autoCorrect=&#123;false&#125; placeholder=&quot;Search for a project...&quot; style=&#123;styles.searchBarInput&#125; onEndEditing=&#123;this.onSearchChange&#125;/&gt; &#123;content&#125; &lt;/View&gt; ); &#125; onSearchChange(event: Object) &#123; var searchTerm = event.nativeEvent.text.toLowerCase(); var queryURL = BASE_URL + encodeURIComponent(searchTerm); fetch(queryURL) .then((response) =&gt; response.json()) .then((responseData) =&gt; &#123; if (responseData.items) &#123; this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows(responseData.items), &#125;); &#125; &#125;).done(); &#125; renderRow(repo: Object) &#123; return ( &lt;View&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Image source=&#123;&#123;uri: repo.owner.avatar_url&#125;&#125; style=&#123;styles.profPic&#125;/&gt; &lt;View style=&#123;styles.textContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt; &#123;repo.name&#125; &lt;/Text&gt; &lt;Text style=&#123;styles.subTitle&#125;&gt; &#123;repo.owner.login&#125; &lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.cellBorder&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: &apos;#ffffff&apos;, &#125;, searchBarInput: &#123; marginTop: 30, padding: 5, fontSize: 15, height: 30, backgroundColor: &apos;#EAEAEA&apos;, &#125;, row: &#123; alignItems: &apos;center&apos;, backgroundColor: &apos;white&apos;, flexDirection: &apos;row&apos;, padding: 5, &#125;, cellBorder: &#123; backgroundColor: &apos;rgba(0,0,0,0.1)&apos;, height: 1, marginLeft: 4, &#125;, profPic: &#123; width: 50, height: 50, &#125;, title: &#123; fontSize: 20, marginBottom: 8, fontWeight: &apos;bold&apos;, &#125;, subTitle: &#123; fontSize: 16, marginBottom: 8, &#125;, textContainer: &#123; paddingLeft: 10, &#125;, blankText: &#123; padding: 10, fontSize: 20, &#125;&#125;);AppRegistry.registerComponent(&apos;customView&apos;, () =&gt; customView); 参考 ReactJS结合ES6入门Template","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"},{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"Flexbox布局技术研究","date":"2016-04-20T09:42:25.000Z","path":"2016/04/20/2016-04-20-flexbox/","text":"写在前面 Flexbox即弹性盒子模型，它在css中的定义和标记非常简单，通过媒体查询的方式就可适配和响应变化，不需要清除浮动，不需要使用额外的框架，也不需要使用大量冗余的代码来实现栅格布局。 Flexbox究竟是什么简单地说，我们可以在一个flex容器中标记一些flex子元素，通过css来定义布局。flexbox有很多属性来定义布局。 flex-direction: 通过这个属性,我们能指定flex容器的子元素是按行显示还是按列显示。 可以通过这个属性定义元素按升序显示还是按降序显示。 justify-content: 通过这个属性，可以声明浏览器如何分配元素以外的可用空间。比如有3个节点，它们组合起来一共占据了容器50%的空间，我们能够指定元素集中在左边、右边还是中间。或者是均匀地从左往右分布，或许其他的一些方式。 flex-wrap: 通过这个属性，我们能够指定当flex子元素的总宽度超出了容器的空间时，是否换行。 栅格系统目前，栅格系统在页面的布局管理中占据了很重要的地位。默认盒模型的行为导致在布局中通常会使用 float和inline-block等hacks方式来实现。而Flexbox能让我们仅仅是用很少的几行css代码就能轻松实现一套功能强大、可拓展的栅格系统。 简单的栅格布局在传统的栅格系统中，我们必须用某种方式说明在一行中包含多少个内容节点，然后给每个内容节点设置相应的宽度。通过Flexbox，我们可以在一行中放置任意数目的项目，而且这些项目的宽度可以根据容器的宽度自动分配。换句话说，在css中，我们可以通过一些标记来达到目的，而不用关心一行中放置多少个内容节点。代码如下：1234567891011121314151617&lt;div class=&quot;grid&quot;&gt; &lt;div class=&quot;grid-row&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;grid-row&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;grid-row&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对应的css代码如下（为了美观，添加了简单的样式）：12345678910111213141516.grid &#123; boder: solid 1px #e7e7e7;&#125;.grid-row &#123; display: flex;&#125;.grid-item &#123; flex: 1; padding: 12px; border: 1px solid #f7f7f7;&#125;.grid--row &#123; display: flex; flex-direction: column;&#125; 接着，我们就可以看到神奇的自适应栅格效果。 响应式栅格布局在上面的基础上，如果要实现类似bootstrap的响应式布局要怎么处理呢？使用Flexbox，我们同样不需要设置宽度节点，直接添加媒体查询即可。对上面的代码稍作修改： 1234567891011121314151617181920212223&lt;div class=&quot;grid&quot;&gt; &lt;h2&gt;列布局&lt;/h2&gt; &lt;div class=&quot;grid--row grid--row-sm&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;grid--row grid--row-md&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;7&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;grid--row grid--row-lg&quot;&gt; &lt;div class=&quot;grid-item&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;grid-item&quot;&gt;3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对应的css如下： 12345678910111213141516171819202122232425262728293031323334.grid &#123; boder: solid 1px #e7e7e7; &#125; .grid-row &#123; display: flex; &#125; .grid-item &#123; flex: 1; padding: 12px; border: 1px solid #f7f7f7; &#125; .grid--row &#123; display: flex; flex-direction: column; &#125; @media screen and (min-width:480px) &#123; .grid--row-sm &#123; display: flex; flex-direction: row; &#125; &#125; @media screen and (min-width:720px) &#123; .grid--row-md &#123; display: flex; flex-direction: row; &#125; &#125; @media screen and (min-width:960px) &#123; .grid--row-lg &#123; display: flex; flex-direction: row; &#125; &#125; 这样响应式的栅格布局就完成了。下图： 有了这样的栅格系统，我们就可以自由地进行嵌套使用了，它的适应性非常强。 垂直居中在传统的css中，垂直对齐的实现非常糟糕。有时候我们可以给节点设置inline-box能解决这个问题，也有人使用绝对定位的hack来实现，还有人使用过时的table布局（在语意化的今天，这是不符合要求的）。而Flexbox能够轻松地处理这个问题。 第一个例子：左侧是用户头像，右侧是用户的名字和一些信息。我们将使用Flexbox来使得用户头像在区域中垂直居中。 123456789101112131415161718&lt;div class=&quot;user&quot;&gt; &lt;div class=&quot;user-avatar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;user-desc&quot;&gt; &lt;h2 class=&quot;user-username&quot;&gt;John Doe&lt;/h2&gt; &lt;p class=&quot;user-excerpt&quot;&gt; Hello! I&apos;m John Doe. Nice to meet you! &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;user&quot;&gt; &lt;div class=&quot;user-avatar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;user-desc&quot;&gt; &lt;h2 class=&quot;user-username&quot;&gt;John Doe&lt;/h2&gt; &lt;p class=&quot;user-excerpt&quot;&gt; Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you!Hello! I&apos;m John Doe. Nice to meet you! &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 对应的css如下： 1234567891011121314151617181920212223.user &#123; display: flex; align-items: center; margin-bottom: 20px; &#125; .user:last-child &#123; margin-bottom: 0; &#125; .user-avatar &#123; flex: 0 0 96px; width: 96px; height: 96px; background-color: #e7e7e7; &#125; .user-desc &#123; flex: 1; margin-left: 24px; padding: 12px; border: solid 1px #e7e7e7; &#125; 注意：align-items这个属性能够让flex项目垂直于flex基准线方向队列显示。换句话说，如果flex基准线沿着水平方向，我们能够让每个项目基于这个水平线排列。因此这里我们只要设置了align-items:center 就可以了。然后我们见证奇迹的一刻： 第二个例子：在一个宽度固定、高度可变的容器中，如何实现元素始终处于容器中心（水平和垂直都居中） 让我们想象一下，在所有的节点标记中最上面的是banner，这个banner中有一些标题文本。在小屏幕中，banner的高度是180px，它将通过设置两个端点将高度变为480px。每次变化后，我们都希望标题文本仍处在banner的中心，无论是水平方向还是垂直方向。下面是标记节点： 123456&lt;div class=&quot;banner&quot;&gt; &lt;div class=&quot;banner-content&quot;&gt; &lt;h2 class=&quot;banner-title&quot;&gt;Sysmetrical Perfection&lt;/h2&gt; &lt;span class=&quot;banner-sub&quot;&gt;A beautiful sight, achieved with flexbox.&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 这次我们使用 justify-content 属性。这个属性的作用是定义项目周围沿着flex基准线的空间如何显示。下面是css代码： 1234567891011121314151617181920212223242526272829303132333435.banner &#123; display: flex; align-items: center; justify-content: space-around; height: 180px; background-color: #e7e7e7; &#125; .banner-content &#123; text-align: center; &#125; .banner-title, .banner-sub &#123; margin: 0; padding: 0; line-height: 1.5; &#125; @media screen and (min-width:480px) &#123; .banner &#123; height: 240px; &#125; &#125; @media screen and (min-width:720px) &#123; .banner &#123; height: 360px; &#125; &#125; @media screen and (min-width:960px) &#123; .banner &#123; height: 480px; &#125; &#125; 这样一来，无论banner的高度是多少，内容总会保持在水平和垂直方向的中心位置，这就是Flexbox的强大之处！ 在React Native中使用Flexbox下面以栅格系统为例，简单介绍一下如何把Web中的布局 转换到 React Native上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @desc 将web中的布局转换到React Native上**/import React, &#123; AppRegistry, StyleSheet, Component, Text, View&#125; from &apos;react-native&apos;;const styles = StyleSheet.create(&#123; grid: &#123; padding: 30, marginTop: 65, borderColor: &apos;#e7e7e7&apos;, &#125;, grid_row: &#123; flex: 1, flexDirection: &apos;row&apos;, padding: 5, &#125;, grid_item: &#123; flex: 1, backgroundColor: &apos;#e7e7e7&apos;, height: 30, textAlign: &apos;center&apos;, &#125;&#125;);class SimpleApp extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.grid&#125;&gt; &lt;View style=&#123;styles.grid_row&#125;&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;1&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;2&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.grid_row&#125;&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;1&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;2&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;3&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.grid_row&#125;&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;1&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;2&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;3&lt;/Text&gt; &lt;Text style=&#123;styles.grid_item&#125;&gt;4&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125;AppRegistry.registerComponent(&apos;SimpleApp&apos;, () =&gt; SimpleApp); 推荐一个详细的教程 http://caibaojian.com/flexbox-guide.html","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://jafeney.com/tags/react-native/"}]},{"title":"［转］使用简单的JavaScript，我们为什么应该抵制ES6","date":"2016-04-08T11:43:11.000Z","path":"2016/04/08/2016-04-08-es6/","text":"作为一名专职的JavaScript开发者，我会密切关注有关JS最新动态，不过最近看过ECMAScript 6的一些新的语法后。我认为ES委员会已经偏离正确的轨道，正在将JavaScript引向错误的方向，很可能又在重复ES4的老路。 JavaScript的简单长久以来，我一直认为当今JavaScript的广泛应用一部分原因是源于她的“简单”。 一定程度上也可以叫作“简陋”，因为她并不能让程序员很“舒服”的写代码。我曾经从事过很长时间的C#和Java的开发，一度认为JavaScript的讲法极其糟糕，跟很多人一样对这种语言非常不屑，甚至觉得她并不能称之为语言，到处都是坑：浏览器兼容，异步回调，继承机制，域，类型转换…… 《JavaScript就是一种垃圾语言 》《Javascript诞生记-C和Self语言一夜情的产物》 但自从Node.JS的横空出世，重新审视这门语言，你会发现这种简陋却可以让解释器很“舒服”地运行代码。在各种评测中，看到JavaScript虚拟机比Java虚拟机快个一两倍，甚至几倍已经不是什么新鲜事了。 这种性能的提升正是源自于她的简单，没有线程对CPU和内存的额外消耗，远小于各种主流编程语言的关键字的数量，以及灵活的闭包而形成的多样的代码组织形式，都决定了JavaScript是一种灵活高效的语言。 《Web服务性能测试：Node完胜Java 》 JavaScript的开放目前JS被Node及其他平台采用的另一个原因是因为她的开放，目前JS引擎多达4，5种，这种局面也将长期持续下去，这些引擎相互之间在不断竞争，终究会不断提升JS的运行速度。 不光是Node，Java也早已内置了JavaScript的运行环境；最新的QT和Gnome也准备将JavaScript视为首选开发语言；微软在Win8也采用了WinJS技术；SAP最新推出的基于内存的数据库HANA，其中的XSEngine也正是由JS驱动的，与NodeJS的异步单线程不同，由于写法过于灵活，且程序流并不是很容易控制，XSEngine将其改造成同步多线程的形式，这一点其实已经有些违背JS的核心特性，但可以尽可能地保证ERP软件的正确性，降低ERP实施过程中的风险。 JS标准不是由一家公司制定的，也不存在专利问题。相对于使用Oracle的Java，微软的.NET，JavaScript的成本和风险似乎要低的多，这也是这些大公司选择基于JS技术，构建自己的JS平台的原因。 为什么要抵制ECMAScript6我们都知道ECMAScript4，是一个著名的失败的标准。坊间传闻其最初由Adobe撰写，后被ECMAScript委员会采纳，这其中有多少故事我们暂且不表。我曾经也从事过一段时间的AS3的开发，一度被其优美，严谨的语法所迷住，其实当实并没有意识到，这样全新的语法体系对于浏览器来说可能过于复杂了，可能也正因为如此，其并没有在一款浏览器上真正实施过，同样这也可能是导致Flash Player越来越不稳定的原因。 现在翻开ES6的新特性，这些被遗弃的部分似乎又回来了，而且似乎更多了。 以下特性，部分截自此幻灯片： ECMAScript 6 需翻墙。 看上去很美的类继承123456789class MetaLanguage extends Language &#123; constructor(x, y, z, version) &#123; super(x, y, z); this.version = version; &#125; summary() &#123; return version; &#125;&#125; 看这段是不是觉得有点眼熟？为嘛这段跟微软的TypeScript的长得这么像？我们暂不去揣测标准制定者跟微软有何关系，但一下子用了这么多关键字，浏览器知道吗？ 新的function表达形式12345678let empty = -&gt;;let square = (x) -&gt; x * x;$(&quot;#shopping-chart&quot;).on(&apos;click&apos;, (event)=&gt; this.customer.purchase(this.chart););[1, 2, 3].map&#123;|x| x * x&#125;; //[1, 4, 9] 照抄Ruby/Python的表达式，似乎还有Lambda的影子。 再来点Java和Node的模块管理12345678module DBLayer &#123; export function query(s) &#123; ... &#125; export function connection(..args) &#123; ... &#125;&#125;import DBLayer.*;module CanvasLib = require(&apos;http://../canvas.js&apos;);import CanvasLib.&#123;Triangle, rotate&#125;; 看到这儿我彻底混乱了，前端能用这样的模块加载方式吗？而且还是同步的，知道这会给性能带来多么大的损失吗？ 结论我一度以为我只是为数不多反ES6的程序员，其实有些国外程度员很早就已经提出异议了，参见 Thoughts on ECMAScript 6 and new syntax 观其评论，反对ES6者居多。 总而言之，最新的ES6似乎“借鉴”了一点Java，一点.Net，一点TypeScript，一点CoffeeScript，一点Ruby/Python，一点Node.JS…… 我不是很明白他们要制定出一个什么东西，我们应该欢迎那些简单，实用的新特性，但标准并不应该让语言变得更复杂，尤其是一个四不像的东西。但幸亏JavaScript是一个公开，开放的，由大家共同维护的平台，这些样标准可能会再次重蹈ES4的覆辙，可能会再次被遗弃。 原文链接： http://ourjs.com/detail/530b64f23b73342e03000012 看了不爽的 敬请吐槽吧！ ^_^","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"深入理解gulp自动化","date":"2016-03-06T12:25:10.000Z","path":"2016/03/06/2016-03-06-gulp/","text":"写在前面gulp使用了有一段时间，公司好几个项目自动化就是用它构建的。不过对这个简单粗暴的工具我常常是又爱又怕。啥意思呢？大牛们写的gulp任务我看得懂，也能依样画葫芦运用到自己的项目，但是如果撇开doc，让我自己写我还真写不好。纸上得来终觉浅啊，考验对一门技术的掌握程度，光看得懂、会套用还是停留在浅层，在理解的基础上自己能写出漂亮又高效的代码那才是真正掌握了。 详解gulp的API要运行gulp任务，只需切换到存放gulpfile.js文件的目录(windows平台请使用cmd或者Power Shell等工具)，然后在命令行中执行gulp命令就行了，gulp后面可以加上要执行的任务名，例如gulp task1，如果没有指定任务名，则会执行任务名为default的默认任务。 使用gulp，仅需知道4个API即可：gulp.task(),gulp.src(),gulp.dest(),gulp.watch()，所以很容易就能掌握，但有几个地方需理解透彻才行。往下看… gulp.src()获取文件流。注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流(Vinyl files)，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，基本语法为： 1gulp.src([globs],options) globs参数是文件匹配模式(类似正则表达式)，用来匹配文件路径(包括文件名)，当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。options为可选参数。通常情况下我们不需要用到。 下面重点介绍gulp常用的glob匹配规则和技巧： * 匹配文件路径中的0个或多个字符，但不会匹配路径分隔符，除非路径分隔符出现在末尾 ** 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。 ? 匹配文件路径中的一个字符(不会匹配路径分隔符) [...] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似js正则表达式中的用法 !(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的 ?(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或1次，类似于js正则中的 (pattern|pattern|pattern)? +(pattern|pattern|pattern) 匹配括号中给定的任一模式至少1次，类似于js正则中的(pattern|pattern|pattern)+ *(pattern|pattern|pattern) 匹配括号中给定的任一模式0次或多次，类似于js正则中的(pattern|pattern|pattern)* @(pattern|pattern|pattern) 匹配括号中给定的任一模式1次，类似于js正则中的(pattern|pattern|pattern) 语法看起来太枯燥，我们还是结合实际场景看看： * 能匹配 a.js, x.y, abc, abc/,但不能匹配a/b.js *.* 能匹配 a.js, style.css, a.b,x.y */*/*.js 能匹配 a/b/c.js, x/y/z.js,不能匹配a/b.js, a/b/c/d.js ** 能匹配 abc, a/b.js, a/b/c.js, x/y/z, x/y/z/a.b,能用来匹配所有的目录和文件 **/*.js 能匹配 foo.js, a/foo.js, a/b/foo.js, a/b/c/foo.js a/**/z 能匹配 a/z, a/b/z, a/b/c/z, a/d/g/h/j/k/z a/**b/z 能匹配 a/b/z, a/sb/z,但不能匹配a/x/sb/z,因为只有单**单独出现才能匹配多级目录 ?.js 能匹配 a.js, b.js, c.js a?? 能匹配 a.b, abc,但不能匹配ab/,因为它不会匹配路径分隔符 [xyz].js 只能匹配 x.js, y.js, z.js,不会匹配 xy.js, xyz.js等,整个中括号只代表一个字符 [^xyz].js 能匹配 a.js, b.js, c.js等,不能匹配 x.js, y.js, z.js 当有多种匹配模式时可以使用数组： 1gulp.src([&apos;js/*.js&apos;,&apos;css/*.css&apos;,&apos;*.html&apos;]) 使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上!即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式。 12gulp.src([*.js,&apos;!b*.js&apos;]) //匹配所有js文件，但排除掉以b开头的js文件gulp.src([&apos;!b*.js&apos;,*.js]) //不会排除任何文件，因为排除模式不能出现在数组的第一个元素中 此外，还可以使用展开模式。 展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式相加起来得到的结果。展开的例子如下： a{b,c}d 会展开为 abd, acd a{b,}c 会展开为 abc, ac a{0..3}d 会展开为 a0d, a1d, a2d, a3d a{b,c{d,e}f}g 会展开为 abg, acdfg, acefg a{b,c}d{e,f}g 会展开为 abdeg, acdeg, abdeg, abdfg gulp.dest()写文件。基本语法为： 1gulp.dest([path],options) path为写入文件的路径，options为一个可选的参数对象，通常我们不需要用到。 要想使用好gulp.dest()这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。 gulp的使用流程一般是这样子的：首先通过gulp.src()方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如： 1234var gulp = require(&apos;gulp&apos;);gulp.src(&apos;script/jquery.js&apos;) .pipe(gulp.dest(&apos;dist/foo.js&apos;));//最终生成的文件路径为 dist/foo.js/jquery.js,而不是dist/foo.js 要想改变文件名，可以使用插件 gulp-rename 下面说说生成的文件路径与我们给gulp.dest() 方法传入的路径参数之间的关系。gulp.dest(path) 生成的文件路径是我们传入的path参数后面再加上gulp.src()中有通配符开始出现的那部分路径。例如： 12345var gulp = reruire(&apos;gulp&apos;);//有通配符开始出现的那部分路径为 **/*.jsgulp.src(&apos;script/**/*.js&apos;) .pipe(gulp.dest(&apos;dist&apos;)); //最后生成的文件路径为 dist/**/*.js//如果 **/*.js 匹配到的文件为 jquery/jquery.js ,则生成的文件路径为 dist/jquery/jquery.js 再举更多一点的例子 1234567891011gulp.src(&apos;script/avalon/avalon.js&apos;) //没有通配符出现的情况 .pipe(gulp.dest(&apos;dist&apos;)); //最后生成的文件路径为 dist/avalon.js//有通配符开始出现的那部分路径为 **/underscore.jsgulp.src(&apos;script/**/underscore.js&apos;) //假设匹配到的文件为script/util/underscore.js .pipe(gulp.dest(&apos;dist&apos;)); //则最后生成的文件路径为 dist/util/underscore.jsgulp.src(&apos;script/*&apos;) //有通配符出现的那部分路径为 * //假设匹配到的文件为script/zepto.js .pipe(gulp.dest(&apos;dist&apos;)); //则最后生成的文件路径为 dist/zepto.js 通过指定gulp.src()方法配置参数中的base属性，我们可以更灵活的来改变gulp.dest()生成的文件路径。当我们没有在gulp.src()方法中配置base属性时，base的默认值为通配符开始出现之前那部分路径，例如： 1gulp.src(&apos;app/src/**/*.css&apos;) //此时base的值为 app/src 上面我们说的gulp.dest()所生成的文件路径的规则，其实也可以理解成，用我们给gulp.dest()传入的路径替换掉gulp.src()中的base路径，最终得到生成文件的路径。 123gulp.src(&apos;app/src/**/*.css&apos;) /*此时base的值为app/src,也就是说它的base路径为app/src*/ /*设该模式匹配到了文件 app/src/css/normal.css*/ .pipe(gulp.dest(&apos;dist&apos;)) /*用dist替换掉base路径，最终得到 dist/css/normal.css*/ 所以改变base路径后，gulp.dest()生成的文件路径也会改变 1234567gulp.src(script/lib/*.js) //没有配置base参数，此时默认的base路径为script/lib //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest(&apos;build&apos;)) //生成的文件路径为 build/jquery.jsgulp.src(script/lib/*.js, &#123;base:&apos;script&apos;&#125;) //配置了base参数，此时base路径为script //假设匹配到的文件为script/lib/jquery.js .pipe(gulp.dest(&apos;build&apos;)) //此时生成的文件路径为 build/lib/jquery.js 用gulp.dest()把文件流写入文件后，文件流仍然可以继续使用。 gulp.task()gulp.task方法用来定义任务，内部使用的是Orchestrator，其语法为： 1gulp.task([name],[deps], fn) name 为任务名。deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 123gulp.task(&apos;mytask&apos;, [&apos;array&apos;, &apos;of&apos;, &apos;task&apos;, &apos;names&apos;], function() &#123; //定义一个有依赖的任务 // Do something&#125;); gulp.task()这个API没什么好讲的，但需要知道执行多个任务时怎么来控制任务执行的顺序。gulp中执行多个任务，可以通过任务依赖来实现。例如我想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了： 12//只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task(&apos;default&apos;,[&apos;one&apos;,&apos;two&apos;,&apos;three&apos;]); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如： 1234567891011gulp.task(&apos;one&apos;,function()&#123; //one是一个异步执行的任务 setTimeout(function()&#123; console.log(&apos;one is done&apos;) &#125;,5000);&#125;);//two任务虽然依赖于one任务,但并不会等到one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？有三种方法可以实现： 第一：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。 123456789101112gulp.task(&apos;one&apos;,function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log(&apos;one is done&apos;); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 第二：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。 12345678910gulp.task(&apos;one&apos;,function(cb)&#123; var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest(&apos;build&apos;)); return stream;&#125;);gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 第三：返回一个promise对象，例如 12345678910111213var Q = require(&apos;q&apos;); //一个著名的异步处理的库 https://github.com/kriskowal/qgulp.task(&apos;one&apos;,function(cb)&#123; var deferred = Q.defer(); // 做一些异步操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 5000); return deferred.promise;&#125;);gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); gulp.task()就这些了，主要是要知道当依赖是异步任务时的处理。 gulp.watch()监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为： 1gulp.watch([glob], [opts], [tasks]) glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到。tasks 为文件变化后要执行的任务，为一个数组。 1234567gulp.task(&apos;uglify&apos;,function()&#123; //do something&#125;);gulp.task(&apos;reload&apos;,function()&#123; //do something&#125;);gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); gulp.watch() 还有另外一种使用方式： 1gulp.watch([glob], [opts], cb) glob和opts参数与第一种用法相同。cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径。 1234gulp.watch(&apos;js/**/*.js&apos;, function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); 常用的gulp插件自动加载插件使用 gulp-load-plugins安装：npm install --save-dev gulp-load-plugins要使用gulp的插件，首先得用require来把插件加载进来，如果我们要使用的插件非常多，那我们的gulpfile.js文件开头可能就会是这个样子的： 1234567891011var gulp = require(&apos;gulp&apos;), //一些gulp插件,abcd这些命名只是用来举个例子 a = require(&apos;gulp-a&apos;), b = require(&apos;gulp-b&apos;), c = require(&apos;gulp-c&apos;), d = require(&apos;gulp-d&apos;), e = require(&apos;gulp-e&apos;), f = require(&apos;gulp-f&apos;), g = require(&apos;gulp-g&apos;), //更多的插件... z = require(&apos;gulp-z&apos;); 虽然这没什么问题，但会使我们的gulpfile.js文件变得很冗长，看上去不那么舒服。gulp-load-plugins插件正是用来解决这个问题。gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。例如假设你的package.json文件里的依赖是这样的： 12345678&#123; &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;~3.6.0&quot;, &quot;gulp-rename&quot;: &quot;~1.2.0&quot;, &quot;gulp-ruby-sass&quot;: &quot;~0.4.3&quot;, &quot;gulp-load-plugins&quot;: &quot;~0.5.1&quot; &#125;&#125; 然后我们可以在gulpfile.js中使用gulp-load-plugins来帮我们加载插件： 123var gulp = require(&apos;gulp&apos;);//加载gulp-load-plugins插件，并马上运行它var plugins = require(&apos;gulp-load-plugins&apos;)(); 然后我们要使用gulp-rename和gulp-ruby-sass这两个插件的时候，就可以使用plugins.rename和plugins.rubySass来代替了,也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名。实质上gulp-load-plugins是为我们做了如下的转换： 12plugins.rename = require(&apos;gulp-rename&apos;);plugins.rubySass = require(&apos;gulp-ruby-sass&apos;); gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件。最后要提醒的一点是，因为gulp-load-plugins是通过你的package.json文件来加载插件的，所以必须要保证你需要自动加载的插件已经写入到了package.json文件里，并且这些插件都是已经安装好了的。 重命名使用 gulp-rename安装：npm install --save-dev gulp-rename用来重命名文件流中的文件。用gulp.dest()方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用gulp-rename插件来改变文件流中的文件名。 1234567891011var gulp = require(&apos;gulp&apos;), rename = require(&apos;gulp-rename&apos;), uglify = require(&quot;gulp-uglify&quot;);gulp.task(&apos;rename&apos;, function () &#123; gulp.src(&apos;js/jquery.js&apos;) .pipe(uglify()) //压缩 .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest(&apos;js&apos;)); //关于gulp-rename的更多强大的用法请参考https://www.npmjs.com/package/gulp-rename&#125;); js文件压缩使用 gulp-uglify安装：npm install --save-dev gulp-uglify用来压缩js文件，使用的是uglify引擎 12345678var gulp = require(&apos;gulp&apos;), uglify = require(&quot;gulp-uglify&quot;);gulp.task(&apos;minify-js&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径&#125;); js模块化构建使用 gulp-browserify安装：npm install --save-dev gulp-browserify 前端js代码的模块化一直是前端工程师之痛，因为JS在ES6之前不支持 import 或者 require 这类的模块加载能力，需要借助 一些工具，比如 requireJS、seaJS等。但是 有了 browserify，js代码代码只要编译之后，你可以大胆地 使用require()，就像在node环境里一样，而且它既支持commonJS规范，也支持非commonJS规范，但是为了提高准确率，还是自觉遵守commonJS规范吧！ 123456789var gulp = require(&apos;gulp&apos;);var browserify = require(&apos;gulp-browserify&apos;);// 处理javascriptgulp.task(&apos;scripts&apos;, [&apos;clean&apos;], function() &#123; return gulp.src(&apos;src/js/**/*.js&apos;) .pipe(browserify()) .pipe(gulp.dest(JS_DEST));&#125;); css文件压缩使用 gulp-minify-css安装：npm install --save-dev gulp-minify-css要压缩css文件时可以使用该插件 12345678var gulp = require(&apos;gulp&apos;), minifyCss = require(&quot;gulp-minify-css&quot;);gulp.task(&apos;minify-css&apos;, function () &#123; gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); html文件压缩使用 gulp-minify-html安装：npm install --save-dev gulp-minify-html用来压缩html文件 12345678var gulp = require(&apos;gulp&apos;), minifyHtml = require(&quot;gulp-minify-html&quot;);gulp.task(&apos;minify-html&apos;, function () &#123; gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest(&apos;dist/html&apos;));&#125;); js代码检查使用 gulp-jshint安装：npm install --save-dev gulp-jshint用来检查js代码 12345678var gulp = require(&apos;gulp&apos;), jshint = require(&quot;gulp-jshint&quot;);gulp.task(&apos;jsLint&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 文件合并使用 gulp-concat安装：npm install --save-dev gulp-concat用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了 12345678var gulp = require(&apos;gulp&apos;), concat = require(&quot;gulp-concat&quot;);gulp.task(&apos;concat&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) //要合并的文件 .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot; .pipe(gulp.dest(&apos;dist/js&apos;));&#125;); less和sass的编译less使用 gulp-less安装：npm install --save-dev gulp-less 12345678var gulp = require(&apos;gulp&apos;), less = require(&quot;gulp-less&quot;);gulp.task(&apos;compile-less&apos;, function () &#123; gulp.src(&apos;less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); sass使用 gulp-sass安装：npm install --save-dev gulp-sass 12345678var gulp = require(&apos;gulp&apos;), sass = require(&quot;gulp-sass&quot;);gulp.task(&apos;compile-sass&apos;, function () &#123; gulp.src(&apos;sass/*.sass&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); 图片压缩可以使用 gulp-imagemin插件来压缩jpg、png、gif等图片。安装：npm install --save-dev gulp-imagemin 1234567891011121314151617var gulp = require(&apos;gulp&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);var pngquant = require(&apos;imagemin-pngquant&apos;); //png图片压缩插件var cache = require(&apos;gulp-cache&apos;); //只压缩修改的图片，没有修改的图片直接从缓存文件读取gulp.task(&apos;default&apos;, function () &#123; return gulp.src(&apos;src/images/*&apos;) .pipe(cache(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true, //类型：Boolean 默认：false 多次优化svg直到完全优化 svgoPlugins: [&#123;removeViewBox: false&#125;], //不要移除svg的viewbox属性 use: [pngquant()] //使用pngquant来压缩png图片 &#125;))) .pipe(gulp.dest(&apos;dist&apos;));&#125;); gulp-imagemin的使用比较复杂一点，而且它本身也有很多插件，建议去它的项目主页看看文档 自动刷新使用gulp-livereload插件，安装: npm install --save-dev gulp-livereload当代码变化时，它可以帮我们自动刷新页面该插件最好配合谷歌浏览器来使用，且要安装 livereload chrome extension 扩展插件,不能下载的请自行FQ。 123456789101112131415var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), livereload = require(&apos;gulp-livereload&apos;);gulp.task(&apos;less&apos;, function() &#123; gulp.src(&apos;less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;css&apos;)) .pipe(livereload());&#125;);gulp.task(&apos;watch&apos;, function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch(&apos;less/*.less&apos;, [&apos;less&apos;]);&#125;); 清理编译环境使用 gulp-clean安装 npm install gulp-clean --save-dev提交代码之前我们需要把本地的编译环境清理干净。1234var clean = require(&apos;gulp-clean&apos;);gulp.task(&apos;clean&apos;,function()&#123; return gulp.src([&apos;dist/assets/css&apos;,&apos;dist/assets/js&apos;,&apos;dist/assets/img&apos;],&#123;read: false&#125;).pipe(clean());&#125;); 我们可以传入一个目录（或档案）阵列到gulp.src()。因为我们不需要读取已经被删除的档案，我们可以加入read:false 选项来防止gulp读取档案内容让它快一些。 我的gulpfile.js下面的是我花了一下午研究出来的gulp前端自动化管理的最佳实践的gulpfile.js这个文件的代码，想看整体代码的请戳这里 gulp-best-practice 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;), // gulp核心模块 DEST = &apos;build&apos;, // 编译目录 CSS_DEST = &apos;build/css&apos;, // css编译目录 JS_DEST = &apos;build/js&apos;, // js编译目录 IMG_DEST = &apos;build/img&apos;, // img编译目录 HTML_DEST = &apos;build/html&apos;, // html编译目录 WEB_PORT = 9000, // 服务器监听的端口 $ = require(&apos;gulp-load-plugins&apos;)(); // gulp插件加载模块 /** * －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－ * 注意：下面注释的这些代码可以删除，插件用$加载 * 但是用这种方式加载的插件必须在 package.json里 */ // less = require(&apos;gulp-less&apos;), // less与编译模块 // autoprefixer = require(&apos;gulp-autoprefixer&apos;), // 浏览器前缀自动补全 // minifyCss = require(&apos;gulp-minify-css&apos;), // 压缩css // minifyHtml = require(&quot;gulp-minify-html&quot;), // 压缩html // jshint = require(&apos;gulp-jshint&apos;), // js语法校验 // browserify = require(&apos;gulp-browserify&apos;), // js模块化构建工具 // uglify = require(&apos;gulp-uglify&apos;), // 压缩js // imagemin = require(&apos;gulp-imagemin&apos;), // 压缩图片 // rename = require(&apos;gulp-rename&apos;), // 文件重命名 // clean = require(&apos;gulp-clean&apos;), // 文件清理 // notify = require(&apos;gulp-notify&apos;), // 消息通知 // cache = require(&apos;gulp-cache&apos;), // 缓存 // sequence = require(&apos;gulp-sequence&apos;), // gulp任务执行队列 // connect = require(&apos;gulp-connect&apos;), // node本地服务器 // livereload = require(&apos;gulp-livereload&apos;); // 浏览器即时刷新 //－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－// 处理lessgulp.task(&apos;styles&apos;, function() &#123; return gulp.src(&apos;src/less/**/*.less&apos;) .pipe($.less()) .pipe($.autoprefixer(&apos;last 2 version&apos;,&apos;safari 5&apos;,&apos;ie 8&apos;,&apos;ie 9&apos;,&apos;opera 12.1&apos;,&apos;ios 6&apos;,&apos;android 4&apos;)) .pipe(gulp.dest(CSS_DEST)) .pipe($.rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe($.minifyCss()) .pipe(gulp.dest(CSS_DEST)) .pipe($.livereload()) .pipe($.notify(&#123; message: &apos;Styles task complete&apos; &#125;));&#125;);// 处理javascriptgulp.task(&apos;scripts&apos;, function() &#123; return gulp.src(&apos;src/js/**/*.js&apos;) .pipe($.jshint(&apos;.jshintrc&apos;)) .pipe($.jshint.reporter(&apos;default&apos;)) .pipe($.browserify()) .pipe(gulp.dest(JS_DEST)) .pipe($.rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe($.uglify()) .pipe(gulp.dest(JS_DEST)) .pipe($.livereload()) .pipe($.notify(&#123; message: &apos;Scripts task complete&apos; &#125;));&#125;);// 处理图片gulp.task(&apos;images&apos;, function() &#123; return gulp.src(&apos;src/img/**/*&apos;) .pipe($.cache($.imagemin(&#123; optimizationLevel: 3, progressive: true, interlaced: true &#125;))) .pipe(gulp.dest(IMG_DEST)) .pipe($.livereload()) .pipe($.notify(&#123; message: &apos;Images task complete&apos; &#125;))&#125;);// 处理htmlgulp.task(&apos;htmls&apos;, function() &#123; return gulp.src(&apos;src/html/**/*.html&apos;) .pipe($.rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe($.minifyHtml()) .pipe(gulp.dest(HTML_DEST)) .pipe($.livereload()) .pipe($.notify(&#123; message: &apos;Htmls task complete&apos; &#125;))&#125;);// 清理build目录gulp.task(&apos;clean&apos;, function() &#123; return gulp.src([HTML_DEST,JS_DEST,CSS_DEST,IMG_DEST], &#123; read: false &#125;) .pipe($.clean()) .pipe($.notify(&#123; message: &apos;Clean task complete&apos; &#125;));&#125;);// 设置服务器gulp.task(&apos;http&apos;, function() &#123; $.connect.server(&#123; root: DEST, port: WEB_PORT, livereload: true &#125;);&#125;);// 监听文件变化gulp.task(&apos;watch&apos;, function() &#123; // 监听livereload $.livereload.listen(); // 监听less gulp.watch(&apos;src/less/**/*.less&apos;, [&apos;styles&apos;]); // 监听js gulp.watch(&apos;src/js/**/*.js&apos;, [&apos;scripts&apos;]); // 监听图片 gulp.watch(&apos;src/img/**/*&apos;, [&apos;images&apos;]); // 监听html gulp.watch(&apos;src/html/**/*.html&apos;, [&apos;htmls&apos;]);&#125;);// build任务gulp.task(&apos;build&apos;, function(cb)&#123; $.sequence(&apos;clean&apos;,[&apos;styles&apos;,&apos;scripts&apos;,&apos;images&apos;,&apos;htmls&apos;,&apos;watch&apos;])(cb)&#125;);// 主任务gulp.task(&apos;main&apos;, function(cb)&#123; $.sequence(&apos;build&apos;, [&apos;http&apos;])(cb)&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;main&apos;]); 重构gulpfile.js重构迭代1: 拆分任务最先是按照 https://github.com/gulpjs/gulp/blob/master/docs/recipes/split-tasks-ac… 此文档中的架构进行迭代的。 文件结构12345gulpfile.jstasks/├── xxxx.js├── xxxx.js└── image.js image.js1234567891011var imagemin = require(&apos;gulp-imagemin&apos;);gulp.task(&apos;img&apos;, function() &#123; return gulp.src(&apos;./images/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 2, progressive: true &#125;)) .pipe(gulp.dest(&apos;./imagemini&apos;))&#125;); gulpfile.js12var requireDir = require(&apos;require-dir&apos;) , tasks = requireDir(&apos;./tasks&apos;); 这种文件架构让任务按照类型分成子任务放在单独的文件中，顿时感觉干净了很多，这时可以自由的添加子任务，而不用管 gulpfile.js, 此时子任务好比插件，需要就添加，没用就删除，相当方便。 重构迭代2: 避免模块和插件重复依赖随着时间的推移，发现这种组织架构还是有些不方便，不方便在哪里呢，每一个任务文件中，我都要写 var xxx = require(‘xxx’), 如果你是用上面的架构，任务多的时候，估计也会抓狂，因为你会发现 插件和模块依赖被重复的引入进来，这样就提高了成本。 我不想在子任务文件中重复的引入 插件或模块依赖，有没有上面好方法，stackoverflow 是个好老师，老师告知： 使用 gulp-load-plugins 插件 地址：https://www.npmjs.com/package/gulp-load-plugins 把子任务封装成模块 代码结构12345gulpfile.jstasks/├── xxxx.js├── xxxx.js└── image.js gulpfile.js123456var gulp = require(&apos;gulp&apos;), gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;);// 这里请查看文档gulpLoadPlugins.imagemin = require(&apos;gulp-imagemin&apos;);require(&apos;./tasks/image&apos;)(gulp, gulpLoadPlugins); image.js1234567891011module.exports = function (gulp, Plugin) &#123; gulp.task(&apos;img&apos;, function() &#123; return gulp.src(&apos;./images/**/*.*&apos;) .pipe(Plugin.imagemin(&#123; optimizationLevel: 2, progressive: true &#125;)) .pipe(gulp.dest(&apos;./imagemini&apos;)) &#125;);&#125;; 运行任务 一切正常，此时一个文件测试已经ok。 但是 ./tasks 下面是有很多的子任务，所以需要一个迭代加载，修改 gulpfile.js 如下 123456789101112var gulp = require(&apos;gulp&apos;) , gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;) // 这里获取子任务文件列表 使用了 fs 模块 , gulpTaskList = require(&apos;fs&apos;).readdirSync(&apos;./tasks/&apos;) ;// 这里请查看文档gulpLoadPlugins.imagemin = require(&apos;gulp-imagemin&apos;);gulpTaskList.forEach(function(taskfile) &#123; require(&apos;./tasks/&apos; + taskfile)(gulp, gulpLoadPlugins);&#125;); 这一次迭代避免了重复依赖的问题，但是你会发现，所有的依赖都声明在 gulpTaskList 命名空间下，如果你依赖很多插件或模块，gulpfile.js 也是相当长，鱼和熊掌不可兼得，在现在情况下，只能寻找最佳的解决方案。 重构迭代3: 参数配置全局化其实第二部迭代之后，就可以满足大部分需求，但还是有小伙伴抱怨，有些子任务有相同的参数，能不能抽取出来，放到一个单独的文件中，so 继续翻阅文档。 参考文档 https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-external… 代码结构1234567gulpfile.jsgulp├── config.json ├── tasks/ ├── xxxx.js ├── xxxx.js └── image.js 注意：文件夹层次变了 config.json123&#123; &quot;pnglevel&quot;: 2&#125; gulpfile.js1234567891011var gulp = require(&apos;gulp&apos;) , config = require(&apos;./gulp/config.json&apos;); , gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;) , gulpTaskList = require(&apos;fs&apos;).readdirSync(&apos;./gulp/tasks/&apos;) ;gulpLoadPlugins.imagemin = require(&apos;gulp-imagemin&apos;);gulpTaskList.forEach(function(taskfile) &#123; require(&apos;./gulp/tasks/&apos; + taskfile)(gulp, gulpLoadPlugins, config);&#125;); image.js1234567891011module.exports = function (gulp, Plugin, config) &#123; gulp.task(&apos;img&apos;, function() &#123; return gulp.src(&apos;./images/**/*.*&apos;) .pipe(Plugin.imagemin(&#123; optimizationLevel: config.pnglevel, progressive: true &#125;)) .pipe(gulp.dest(&apos;./imagemini&apos;)) &#125;);&#125;; 此次迭代结束后，我把子任务中通用的配置都写到 ./gulp/config.json 中，全局配置。 重构迭代4: 参数配置模块化此次迭代紧跟迭代3，json 不够完美，不想每次去写 “”, 这里我把配置文件封装成一个模块即迭代3 中的 config.json 变成了 config.js config.js123456module.exports = function () &#123; var config = &#123; pnglevel: 2 &#125;; return config;&#125;; gulpfile.js 加载1var config = require(&apos;./gulp/gulp.config&apos;)(); 其他不变，当封装成一个模块的时候，你就发现好处多多了，可以在模块中添加函数，你也可以把配置拆分，根据你的业务需要，自由调整。通过4步的迭代，整个代码组织架构就清晰多了。 注意： 子任务中注意文件夹的层次，子任务中的文件夹是以 gulpfile.js 为基准，因为 gulpfile.js 把子任务都包含进来了。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jafeney.com/tags/模块化/"},{"name":"自动化","slug":"自动化","permalink":"http://jafeney.com/tags/自动化/"}]},{"title":"推荐给大家的css书写规范和顺序","date":"2016-03-03T06:17:19.000Z","path":"2016/03/03/2016-03-03-css-coding/","text":"写在前面写了这么久的CSS，但大部分前端er都没有按照良好的CSS书写规范来写CSS代码，这样会影响代码的阅读体验，这里设计达人网总结一个CSS书写规范、CSS书写顺序供大家参考，这些是参考了国外一些文章以及我的个人经验总结出来，我想对写CSS的前端用户来说是值得学习的。 css书写顺序 位置属性(position, top, right, z-index, display, float等) 大小(width, height, padding, margin) 文字系列(font, line-height, letter-spacing, color- text-align等) 背景(background, border等) 其他(animation, transition等) CSS书写规范使用CSS缩写属性 CSS有些属性是可以缩写的，比如padding,margin,font等等，这样精简代码同时又能提高用户的阅读体验。 去掉小数点前的“0” 简写命名 很多用户都喜欢简写类名，但前提是要让人看懂你的命名才能简写哦！ 16进制颜色代码缩写 有些颜色代码是可以缩写的，我们就尽量缩写吧，提高用户体验为主。 连字符CSS选择器命名规范 长名称或词组可以使用中横线来为选择器命名。 不建议使用“_”下划线来命名CSS选择器，为什么呢？ 输入的时候少按一个shift键； 浏览器兼容问题 （比如使用_tips的选择器命名，在IE6是无效的） 能良好区分JavaScript变量命名（JS变量命名是用“_”） 不要随意使用Id id在JS是唯一的，不能多次使用，而使用class类选择器却可以重复使用，另外id的优先级优先与class，所以id应该按需使用，而不能滥用。 为选择器添加状态前缀 有时候可以给选择器添加一个表示状态的前缀，让语义更明了，比如下图是添加了“.is-”前缀。 CSS命名规范（规则）常用的CSS命名规则 头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签：tags 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner 注释的写法/ Header /内容区/ End Header / Id的命名页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标籤页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright 注意事项 1.一律小写; 2.尽量用英文; 3.不加中槓和下划线; 4.尽量不缩写，除非一看就明白的单词。 CSS样式表文件命名 主要的 master.css 模块 module.css 基本共用 base.css 布局、版面 layout.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 补丁 mend.css 打印 print.css","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://jafeney.com/tags/css/"}]},{"title":"理解Javascript的prototype","date":"2016-02-23T07:19:00.000Z","path":"2016/02/23/2016-02-23-prototype/","text":"写在前面废话不多说，请看下面3道题，把6个console.log()的答案写下来，然后对照着在Console控制台里敲一遍，校验一下结果。 代码片段123456789101112131415161718192021222324252627282930var A = function() &#123;&#125;;a.prototype = &#123; num : 1, text : &apos;aaa&apos;&#125;;var x = new A();// 第一题console.log(x.num);console.log(x.text);// --这里是分割线--var y = new A();A.prototype = &#123; num : 2&#125;;// 第二题console.log(y.num);console.log(y.text);// --这里是分割线--y.num = 3;var z=new A();// 第三题console.log(z.num);console.log(z.text); 答题时间题目都看明白了吧，给你10秒钟赶紧在纸上把6个console.log()的结果写下来吧。 计时开始咯… 1 …… 2 …… 3 …… 4 …… 5 …… 6 …… 7 …… 8 …… 9 …… 10 … 公布答案6个console.log()的结果如下：1234561aaa1aaa2undefined 好了，你对了几题呢？如果都对了说明你已经理解prototype的精髓了，可以离开这篇文章了。但如果你没有全对，还是建议看一下下面的解析。 答案解析第一题x对象是A类的一个实例，x继承A的原型，所以它具备了A的num和text属性，因此输出的结果是 1和aaa。 注意： 其实JavaScript并不是严格的面相对象语言，它没有类的概念，所谓的面向对象是用函数模拟出来的，这里暂且引用Java里面向对象的理论帮助大家更好理解。 第二题y对象是A类的一个实例，y继承A的原型，所以它的num和text属性值也是1和aaa。 注意：y实例化之后虽然对A的原型进行了操作，但是并不会影响到y，而会影响到第三题的z对象。 第三题上一题已经说到A的原型已经发生了重新定义，相比之前，缺少了对text的定义，因此z对象的num属性为 2，而text属性未定义是 undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"}]},{"title":"ES6版本下JavaScript的编程风格","date":"2016-02-15T08:40:26.000Z","path":"2016/02/15/2016-02-15-es6/","text":"写在前面ES62015年已经大刀阔斧地进入前端领域了，很多前沿的框架比如ReactJS、AngularJS、NodeJS和IOJS新版本都支持ES6语法。还是那句话，前端就是要走在最前端，技术革新速度相当快速，如果你还因循守旧，那就OUT出局吧。当然，ES6新特性很多，建议去极客学院WiFi上看看阮一峰老师的文档，今天不讲具体的语法，而是学习ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，以及如何形成良好的编码风格。 块级作用域let取代var ES6提出了两个新的变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 1234567&quot;use strict&quot;;if(true)&#123; let x=&apos;hello&apos;;&#125;for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了一个全局变量，这显然不是本意。变量应该是在其声明的代码块内有效，var命令则做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。12345&quot;use strict&quot;;if(true)&#123; console.log(x); //ReferenceError let x=&apos;Hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。就违反了变量先声明后使用的原则。所以建议不要再使用var命名声明变量，而是使用let命令取代。 全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常亮。这符合函数式编程思想，有利于将来的分布式计算。 12345678910// badvar a=1,b=2,c=3;// goodconst a=1;const b=2;const c=3;// bestconst [a,b,c]=[1,2,3]; const声明常量有两个好处，一是阅读代码的人立即会意识到不应该去修改这个值，而是防止了无意间修改变量值所导致的错误。 注意：所有的函数都应该设置为常量。let表示的变量，只应该出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证多线程安全。 严格模式 v8引擎只在严格模式之下支持let和const。结合前两点，这实际上意味着将来所有的编程都是针对严格模式的。 字符串 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 1234567891011// badconst a=&quot;foobar&quot;;const b=&apos;foo&apos;+a+&apos;bar&apos;;// acceptableconst c=&apos;foobar&apos;;// goodconst a=&apos;foobar&apos;;const b=&apos;foo$&#123;a&#125;bar&apos;;const c=&apos;foobar&apos;; 对象 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 12345678910111213// badconst a=&#123;k1:v1,k2:v2,&#125;;const b=&#123; k1:v1, k2:v2&#125;;// goodconst a=&#123;k1:v1,k2:v2&#125;;const b=&#123; k1:v1, k2:v2,&#125;; 对象尽量静态化，一旦定义好，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 1234567891011// badconst a=&#123;&#125;;a.x=3;// if reshape unavoidableconst a=&#123;&#125;;Object.assign(a,&#123;x:3&#125;);// goodconst a=&#123;x:null&#125;;a.x=3; 函数 使用匿名函数的场合，一律改为使用箭头函数。 12345// badarr.reduce(function(x,y)&#123;return x+y;&#125;,0);// goodarr.reduce((x,y)=&gt;x+y,0); 箭头函数取代Function.prototype.bind，不应该再用 self / _this / that 绑定 this。 1234567891011// badconst self=this;const boundMethod=function(...params)&#123; return method.apply(self.params);&#125;// acceptableconst boundMethod=method.bind(this);// bestconst boundMethod=(...params)=&gt;method.apply(this,params); 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 123456789// badfunction divide(a,b,option=false)&#123; //...&#125;// goodfunction divide(a,b,&#123;option=false&#125;=&#123;&#125;)&#123; //...&#125; Map结构 注意却分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制。 12345678910111213let map=new Map(arr);for(let key of map.keys())&#123; console.log(key);&#125;for(let value of map.values())&#123; console.log(value);&#125;for(let item of map.entries())&#123; console.log(item[0],item[1]);&#125; 模块 ES6的Class只是面向对象的语法糖，升级了ES5的对象定义的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。历史上JavaScript一直没有模块体系，无法将一个大程序拆成互相依赖的小组件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连css都有@import，但是JavaScript没有，这对开发大型的、复杂的项目形成了巨大障碍。 当然，在ES6之前社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种（目前还有seaJS的CMD）。前者用于服务器，后者用于浏览器。ES6在语言规定的层面上，实现了模块功能，而且实现地相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。哈哈，这里恰巧验证了之前的猜想，原文请 戳这里。 当然，ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。1var &#123;stat,exists,readFile&#125;=require(&apos;fs&apos;); ES6模块不是对象，而是通过expert命令显式指定输出的代码，输入时也采用静态命令的形式。1import &#123;stat,exists,readFile&#125; from &apos;fs&apos;; 所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。 使用import取代require1234567// badconst moduleA=require(&apos;moduleA&apos;);const func1=moduleA.func1;const func2=moduleA.func2;// goodimport&#123;func1,func2&#125; from &apos;moduleA&apos;; 使用export取代module.exports1234567891011121314151617// commonJS的写法var React=require(&apos;react&apos;);var Breadcrumbs=React.createClass(&#123; render:function()&#123; return &lt;nav /&gt; &#125;&#125;);module.exports=Breadcrumbs;// ES6的写法import React from &apos;react&apos;;const Breadcrumbs=React.createClass(&#123; render()&#123; return &lt;nav /&gt;; &#125;&#125;);export default Breadcrumbs","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://jafeney.com/tags/ES6/"}]},{"title":"基于webpack的模块化构建","date":"2016-02-02T07:51:43.000Z","path":"2016/02/02/2016-02-02-webpack/","text":"写在前面模块化构建会让项目的拓展性、代码复用性和可维护性大大提高，初期可能会增加一些管理的工作量。但是对长远来说绝对是值得的，一个良好的模块化方案会让维护工作变得轻松，这个好处项目越进展到后来越明显。而且模块化构建的框架和工具很多，RequireJS、SeaJS、Grunt、Gulp等，这些虽然成熟稳定但并不是我们今天的主题，既然是采用react开发webApp，那么模块化当然是选webpack。 webpack的优势1、支持CommonJs和AMD模块，意思也就是我们基本可以无痛迁移旧项目2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader更是有效支持ES6。3、可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。4、将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持sass，less等CSS预处理器。5、内置有source map，即使打包在一起依旧方便调试。 webpack入门首先介绍webpack的配置文件webpack.config.js1234567891011121314151617181920212223242526var webpack=require(&apos;webpack&apos;);module.exports=&#123; entry:[ &apos;webpack/hot/onlu-dev-server&apos;, &apos;./js/app.js&apos; ], output:&#123; path:&apos;./build&apos;, filename:&apos;bundle.js&apos; &#125;, module:&#123; leaders:[ &#123;test:/\\.js?$/,leaders:[&apos;react-hot&apos;,&apos;babel&apos;],exclude:/node_modules/&#125;, &#123;test:/\\.js$/,exclude:/node_modules/,loader:/&apos;babel-loader&apos;&#125;, &#123;test:/\\.css$/,loader:&apos;style!css&apos;&#125;, &#123;test:/\\.less/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125; ], &#125;, resolve:&#123; extensions:[&apos;&apos;,&apos;.js&apos;,&apos;.json&apos;] &#125;, plugins:[ new webpack.NoErrorsPlugin() ]&#125; webpack.config.js 文件通常放在项目的根目录里，它本身也是一个标准的Common.js规范的模块。在导出的配置对象中有几个关键的参数： entryentry可以说个字符串或数组或者是对象。当entry是个字符串的时候用来定义入口文件。1entry:&apos;./js/main.js&apos; 当entry是个数组的时候，里面同样包含入口文件，另外一个参数可以用来配置webpack提供的一个静态资源服务器如webpack-dev-server，它会监控项目中每一个文件的变化，实时进行构建，并且自动刷新页面，1234entry:[ &apos;webpack/hot/only-dev-server&apos;, &apos;./js/app.js&apos;] 当entry是一个对象的时候，我们可以将不同的文件构建成不同的文件，按需使用，比如：1234entry:&#123; hello:&apos;./js/hello.js&apos;, form:&apos;./js/form.js&apos;&#125; outputoutput是个对象，用户定义构建后的文件的输出。其中包含path和filename:1234output:&#123; path:&apos;./build&apos;, filename:&apos;bundle.js&apos;&#125; 当我们在entry中定义构建多个文件时，filename可以对应地更改为[name].bundle.js。 module关于模块的加载相关，我们就定义在module.loaders中，这里通过正则表达式去匹配不同后缀的文件名。然后它们定义不同的加载器，比如说给less文件定义三个串联的加载器（用!连接）12345678moudle:&#123; loaders:[ &#123;test:/\\.js?$/,loaders:[&apos;react-hot&apos;,&apos;babel&apos;],exclude:/node_modules/&#125;, &#123;test:/\\.js$/,exclude:/node_modules/,loader:&apos;babel-loader&apos;&#125;, &#123;test:/\\.css$/,loader:&apos;style!css&apos;&#125;, &#123;test:/\\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125; ]&#125; 除此之外，我们还可以用来定义 png、jpg这样的图片资源在小于10k时自动处理为base64图片的加载器。1&#123;test:/\\.(png|jpg)$/,loader:&apos;url-loader?limit=10000&apos;&#125; 给css和less还有图片添加了loader之后，我们不仅可以像在node中那样require进来了。就像这样：1234require(&apos;./bootstrap.css&apos;);require(&apos;./myapp.less&apos;);var img=document.createElement(&apos;img&apos;);img.src=require(&apos;./glyph.png&apos;); 注意： 这样require进来的文件会内联到 [name].bundle.js中。如果我们需要把保留 require写法又想把css文件单独拿出来，可以使用extract-text-webpack-plugin插件。1$ npm install extract-text-webpack-plugin --save-dev 123456var ExtractTextPlugin =require(&apos;extract-text-webpack-plugin&apos;);module.exports=&#123; plugins:[ new ExtractTextPlugin(&quot;[name].css&quot;); ] &#125; 在上面的示例代码中配置的第一个loader是react-hot的加载器，它可以实现react组件的热替换，我们已经在entry参数中配置了webpack/hot/only-dev-server,所以我们只要启动 webpack时开启-hot参数既可以使用react-hot-loader了，在package.json中这样定义：1234&quot;script&quot;:&#123; &quot;start&quot;:&quot;webpack-dev-server --hot --progress --colors&quot;, &quot;build&quot;:&quot;webpack --progress --colors&quot;&#125; resolvewebpack在构建包的时候会按目录的文件进行查找，resolve属性中的extensions数组中用于配置程序可有自动替换哪些文件的后缀,比如：123resolve:&#123; extensions:[&apos;&apos;,&apos;.js&apos;,&apos;.json&apos;]&#125; 然后我们想要加载一个js文件时，只要require(&#39;common&#39;)就可以加载common.js文件了。 pluginwebpack提供了丰富的组件来满足不同的需求，当然如果你足够牛也可以自己编写插件。这里介绍比较常用的 NoErrorsPlugin，它能跳过编译时出错的代码并记录，是编译后运行的包不会发生错误。123plugins:[ new webpack.NoErrorsPlugin()] externals当我们想在项目中require一些其他的类库或者API，而又不想让这些类库的源码构建到运行时的文件中，就可以通过配置externals参数来解决这个问题，比如jQuery类库123externals:&#123; &quot;jquery&quot;:&apos;jQuery&apos;&#125; 这样我们就可以放心在项目中使用这些API了1var jQuery=require(&apos;jquery&apos;); context当我们在require一个模块的时候，如果require中包含变量，想这样：1require(&quot;./mods/&quot;+name+&quot;.js&quot;); 那么在编译的时候是不能知道具体的模块的。但这个时候webpack也会帮我们分析： 分析目录：&#39;./mods&#39;; 提取正则表达式：/^.*\\.js$/;于是这个时候为了更好地配合webpack进行编译，我们可以给它指明路径，像在cake-webpack-config中所做的那样：12var currentBase=progress.cwd();var context=abcOptions.options.context?abcOptions.options.context:path.isAbsolute(entryDir)?enentryDir:path.join(currentBase,entryDir); 让webpack和gulp强强联手webpack与gulp并不矛盾，甚至一起使用会得到最大化的效益。大致的思路是这样：使用webpack进行assets编译，使用gulp的流快速对其他资源进行打包。 关于工具的定位webpack的定位是module bundler，作为模块化工具，它的竞争对手其实是browserify，而不是gulp。 功能和使用方式上的不同webpack 提供了一些非常使用的功能，像我们之前用到的那些，如图片的处理、resolve的处理、分开构建等,配置相当简单。gulp想要使用这些功能的时候我们可以在webpack里先配置好，做到强强联手！ @参考 推酷 webpack前端模块加载工具@参考 博客园 前端模块化工具-webpack@我的技术博客 Jafeney.com","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jafeney.com/tags/模块化/"}]},{"title":"webApp重构之路——性能和用户体验细节总结","date":"2016-01-28T08:17:42.000Z","path":"2016/01/28/2016-01-28-webapp-reset/","text":"写在前面webApp开发有一段时间了，随着自己的知识面和技能水平不断提升，一个“重构“的想法变得越来越强烈，当然，重构之前，一个确切的方案是相当关键的，也可以说是重中之重， 吸取之前草率上阵的教训，这次要充分考虑可拓展性和可维护性，把模块化、性能优化、用户体验等做到我所能达到的极致。首先，我先总结开发过程中领悟到的提升webApp性能和用户体验的一些方案。 性能优化性能优化，顾名思义是要提升webApp的响应速度并减少不必要的内存和网络开销。这个有很多方案啊，雅虎14条性能优化的方案 这里几乎都能用上，这里不抄书了，直接结合我的实战经验谈谈具体的做法。 压缩&amp;合并自从有了NodeJS的支持，前端静态资源压缩变得非常简单和快捷。这方面的技术很多，比如grunt、gulp、brower、webpack等，不同的工具API和功能也不尽相同。我用的比较熟练的是gulp，这里也抛砖引玉，具体介绍用gulp自动压缩和合并前端资源的策略：&gt;1、图片（压缩图片支持jpg、png、gif）2、样式 （支持sass 同时支持合并、压缩、重命名）3、javascript （检查、合并、压缩、重命名）4、html （压缩）5、客户端同步刷新显示修改6、构建项目前清除发布环境下的文件（保持发布环境的清洁） 选择gulp组件通过gulp plugins，寻找对于的gulp组件&gt;gulp-imagemin: 压缩图片gulp-ruby-sass: 支持sassgulp-minify-css: 压缩cssgulp-jshint: 检查jsgulp-uglify: 压缩jsgulp-concat: 合并文件gulp-rename: 重命名文件gulp-htmlmin: 压缩htmlgulp-clean: 清空文件夹gulp-livereload: 服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr） 安装Gulp组件1npm install gulp-util gulp-imagemin gulp-ruby-sass gulp-minify-css gulp-jshint gulp-uglify gulp-rename gulp-concat gulp-clean gulp-livereload tiny-lr --save-dev 项目目录结构project(项目名称)1234567891011121314|–.git 通过git管理项目会生成这个文件夹|–node_modules 组件目录|–dist 发布环境 |–css 样式文件(style.css style.min.css) |–images 图片文件(压缩图片) |–js js文件(main.js main.min.js) |–index.html 静态文件(压缩html)|–src 生产环境 |–sass sass文件 |–images 图片文件 |–js js文件 |–index.html 静态文件|–.jshintrc jshint配置文件|–gulpfile.js gulp任务文件 gulp基础语法gulp的语法相当简单，通过gulpfile文件来完成相关任务，因此项目中必须包含gulpfile.js。gulp有五个方法：src、dest、task、run、watch |-src和dest：指定源文件和处理后文件的路径 |- watch：用来监听文件的变化 |- task：指定任务 |- run：执行任务 编写gulp任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 组件安装 * npm install gulp-util gulp-imagemin gulp-ruby-sass gulp-minify-css gulp-jshint gulp-uglify gulp-rename gulp-concat gulp-clean gulp-livereload tiny-lr --save-dev */// 引入 gulp及组件var gulp = require(&apos;gulp&apos;), //基础库 imagemin = require(&apos;gulp-imagemin&apos;), //图片压缩 sass = require(&apos;gulp-ruby-sass&apos;), //sass minifycss = require(&apos;gulp-minify-css&apos;), //css压缩 jshint = require(&apos;gulp-jshint&apos;), //js检查 uglify = require(&apos;gulp-uglify&apos;), //js压缩 rename = require(&apos;gulp-rename&apos;), //重命名 concat = require(&apos;gulp-concat&apos;), //合并文件 clean = require(&apos;gulp-clean&apos;), //清空文件夹 tinylr = require(&apos;tiny-lr&apos;), //livereload server = tinylr(), port = 35729, livereload = require(&apos;gulp-livereload&apos;); //livereload// HTML处理gulp.task(&apos;html&apos;, function() &#123; var htmlSrc = &apos;./src/*.html&apos;, htmlDst = &apos;./dist/&apos;; gulp.src(htmlSrc) .pipe(livereload(server)) .pipe(gulp.dest(htmlDst))&#125;);// 样式处理gulp.task(&apos;css&apos;, function () &#123; var cssSrc = &apos;./src/scss/*.scss&apos;, cssDst = &apos;./dist/css&apos;; gulp.src(cssSrc) .pipe(sass(&#123; style: &apos;expanded&apos;&#125;)) .pipe(gulp.dest(cssDst)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(minifycss()) .pipe(livereload(server)) .pipe(gulp.dest(cssDst));&#125;);// 图片处理gulp.task(&apos;images&apos;, function()&#123; var imgSrc = &apos;./src/images/**/*&apos;, imgDst = &apos;./dist/images&apos;; gulp.src(imgSrc) .pipe(imagemin()) .pipe(livereload(server)) .pipe(gulp.dest(imgDst));&#125;);// js处理gulp.task(&apos;js&apos;, function () &#123; var jsSrc = &apos;./src/js/*.js&apos;, jsDst =&apos;./dist/js&apos;; gulp.src(jsSrc) .pipe(jshint(&apos;.jshintrc&apos;)) .pipe(jshint.reporter(&apos;default&apos;)) .pipe(concat(&apos;main.js&apos;)) .pipe(gulp.dest(jsDst)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(uglify()) .pipe(livereload(server)) .pipe(gulp.dest(jsDst));&#125;);// 清空图片、样式、jsgulp.task(&apos;clean&apos;, function() &#123; gulp.src([&apos;./dist/css&apos;, &apos;./dist/js&apos;, &apos;./dist/images&apos;], &#123;read: false&#125;) .pipe(clean());&#125;);// 默认任务 清空图片、样式、js并重建 运行语句 gulpgulp.task(&apos;default&apos;, [&apos;clean&apos;], function()&#123; gulp.start(&apos;html&apos;,&apos;css&apos;,&apos;images&apos;,&apos;js&apos;);&#125;);// 监听任务 运行语句 gulp watchgulp.task(&apos;watch&apos;,function()&#123; server.listen(port, function(err)&#123; if (err) &#123; return console.log(err); &#125; // 监听html gulp.watch(&apos;./src/*.html&apos;, function(event)&#123; gulp.run(&apos;html&apos;); &#125;) // 监听css gulp.watch(&apos;./src/scss/*.scss&apos;, function()&#123; gulp.run(&apos;css&apos;); &#125;); // 监听images gulp.watch(&apos;./src/images/**/*&apos;, function()&#123; gulp.run(&apos;images&apos;); &#125;); // 监听js gulp.watch(&apos;./src/js/*.js&apos;, function()&#123; gulp.run(&apos;js&apos;); &#125;); &#125;);&#125;); LiveReload配置1、安装Chrome LiveReload2、通过npm安装http-server ，快速建立http服务1npm install http-server -g 3、通过cd找到发布环境目录dist4、运行http-server，默认端口是80805、访问路径localhost:80806、再打开一个cmd，通过cd找到项目路径执行gulp，清空发布环境并初始化7、执行监控 gulp8、点击chrome上的LiveReload插件，空心变成实心即关联上，你可以修改css、js、html即时会显示到页面中 缓存在Web应用程序中，系统的瓶颈常在于系统的响应速度。如果系统响应速度过慢，用户就会出现埋怨情绪，系统的价值也因此会大打折扣。因此，提高系统响应速度，是非常重要的。缓存方案有2种，一种布在服务端，用于加快客户端请求的响应速度，比如 MemCache、Redis等；另一种是应用在客户端，目的是减少http请求，降低服务器压力，加快页面渲染速度。 服务端缓存MemCachememcache是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著[1] 。这是一套开放源代码软件，以BSD license授权发布。 MemCache的工作流程如下：先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。 Memcache是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。 Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。Memcached是以守护程序(监听)方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。 Redisredis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 客户端缓存客户端缓存的方案常用的是 ajax缓存、资源离线存储、Storage缓存等。 Ajax缓存Ajax异步请求数据虽然不影响页面的同步加载，但是过多的ajax请求也会给服务器带来压力，因此我们的策略是缓存不必要或者相同的请求，把请求返回的数据用变量存在本地，然后给事件触发点设置 缓存标志，只要是相同的ajax请求就从本地取数据，或者直接return。另外再掺插一个用户体验的优化建议，就是ajax加载时的缓冲动画，动画可以用gif图片替代。 1234567891011121314151617181920/*** [开启缓冲动画]* @return &#123;[type]&#125; [void]*/showLoadAnimate:function()&#123; var self=this; _loadAnimate.show(); _timer=window.setTimeout(function()&#123; self.closeLoadAnimate(); self.myalert(&apos;加载失败了&apos;) &#125;,2000);&#125;,/*** [关闭缓冲动画]* @return &#123;[type]&#125; [void]*/closeLoadAnimate:function()&#123; clearTimeout(_timer); _loadAnimate.fadeOut(&apos;fast&apos;);&#125; 1234567/*触发ajax*/$(&apos;#btn&apos;).on(&apos;click&apos;,function()&#123; if(!$(&apos;#find-shareBody&apos;).hasClass(&apos;isCahed&apos;))&#123; loadData(); $(&apos;#find-shareBody&apos;).addClass(&apos;isCahed&apos;); &#125;&#125;); 123456789101112131415161718192021222324252627282930/*数据加载函数*/function loadData()&#123; _util.showLoadAnimate(); //加载缓冲动画 $.ajax(&#123; url: _self.APIURL+&apos;/product/productTypes.json&apos;, type: &apos;GET&apos;, dataType: &apos;json&apos;, data: &#123;pId: _tId&#125;, success:function(res)&#123; var types=res.types,subTypes=res.subTypes; var tempStr=&quot;&quot;,len1=types.length,len2=subTypes.length; /*加载一级分类*/ for(i=0;i&lt;len1;i++)&#123; if(i===0)&#123; tempStr+=&quot;&lt;li class=&apos;category-item active&apos; data-id=&quot;+types[i].id+&quot;&gt;&quot;+types[i].typeName+&quot;&lt;/li&gt;&quot;; &#125;else&#123; tempStr+=&quot;&lt;li class=&apos;category-item&apos; data-id=&quot;+types[i].id+&quot;&gt;&quot;+types[i].typeName+&quot;&lt;/li&gt;&quot;; &#125; &#125; _categoryWrap.html(tempStr); /*加载二级分类*/ tempStr=&quot;&quot;; for(i=0;i&lt;len2;i++)&#123; tempStr+=&quot;&lt;li class=&apos;sub-category-item&apos; data-id=&quot;+subTypes[i].id+&quot;&gt;&lt;img alt=&apos;&quot;+subTypes[i].typeName+&quot;&apos; src=&quot;+subTypes[i].thumb+&quot;_100 /&gt;&lt;p&gt;&quot;+subTypes[i].typeName+&quot;&lt;/p&gt;&lt;/li&gt;&quot;; &#125; _subCategoryWrap.html(tempStr); _util.closeLoadAnimate(); //关闭缓冲动画 &#125; &#125;);&#125; AppCache如果你的Web应用中有一部分功能（或者整个应用）需要在脱离服务器的情况下使用，那么就可以通过AppCache来让你的用户在离线状态下也能使用。你所需要做的就是创建一个配置文件，在其中指定哪些资源需要被缓存，哪些不需要。此外，还能在其中指定某些联机资源在脱机条件下的替代资源。 AppCache的配置文件通常是一个以.appcache结尾的文本文件（推荐写法）。文件以CACHE MANIFEST开头，包含下列三部分内容：&gt; CACHE – 指定了哪些资源在用户第一次访问站点的时候需要被下载并缓存 NETWORK – 指定了哪些资源需要在联机条件下才能访问，这些资源从不被缓存 FALLBACK – 指定了上述资源在脱机条件下的替代资源 举个例子首先，你需要在页面上指定AppCache的配置文件： 1234&lt;!DOCTYPE html&gt;&lt;html manifest=&quot;manifest.appcache&quot;&gt;...&lt;/html&gt; 在这里千万记得在服务器端发布上述配置文件的时候，需要将MIME类型设置为text/cache-manifest，否则浏览器无法正常解析。 接下来是创建之前定义好的各种资源。我们假定在这个示例中，你开发的是一个交互类站点，用户可以在上面联系别人并且发表评论。用户在离线的状态下依然可以访问网站的静态部分，而联系以及发表评论的页面则会被其它页面替代，无法访问。 好的，我们这就着手定义那些静态资源： 1234567891011CACHE MANIFESTCACHE:/about.html/portfolio.html/portfolio_gallery/image_1.jpg/portfolio_gallery/image_2.jpg/info.html/style.css/main.js/jquery.min.js 注意：配置文件写起来有一点很不方便。举例来说，如果你想缓存整个目录，你不能直接在CACHE部分使用通配符（*），而是只能在NETWORK部分使用通配符把所有不应该被缓存的资源写出来。 你不需要显式地缓存包含配置文件的页面，因为这个页面会自动被缓存。接下来我们为联系和评论的页面定义FALLBACK部分： 123FALLBACK:/contact.html /offline.html/comments.html /offline.html 最后我们用一个通配符来阻止其余的资源被缓存： 12NETWORK:* 最后的结果就是下面这样： 123456789101112131415161718CACHE MANIFESTCACHE:/about.html/portfolio.html/portfolio_gallery/image_1.jpg/portfolio_gallery/image_2.jpg/info.html/style.css/main.js/jquery.min.jsFALLBACK:/contact.html /offline.html/comments.html /offline.htmlNETWORK:* 还有一件很重要的事情要记得：你的资源只会被缓存一次！也就是说，如果资源更新了，它们不会自动更新，除非你修改了配置文件。所以有一个最佳实践是，在配置文件中增加一项版本号，每次更新资源的时候顺带更新版本号： 123456CACHE MANIFEST# version 1CACHE:... Storage存储如果你想在Javascript代码里面保存些数据，那么这两个东西就派上用场了。前一个可以保存数据，永远不会过期（expire）。只要是相同的域和端口，所有的页面中都能访问到通过LocalStorage保存的数据。举个简单的例子，你可以用它来保存用户设置，用户可以把他的个人喜好保存在当前使用的电脑上，以后打开应用的时候能够直接加载。后者也能保存数据，但是一旦关闭浏览器窗口（译者注：浏览器窗口，window，如果是多tab浏览器，则此处指代tab）就失效了。而且这些数据不能在不同的浏览器窗口之间共享，即使是在不同的窗口中访问同一个Web应用的其它页面。 注意：有一点需要提醒的是，LocalStorage和SessionStorage里面只能保存基本类型的数据，也就是字符串和数字类型。其它所有的数据可以通过各自的toString()方法转化后保存。如果你想保存一个对象，则需要使用JSON.stringfy方法。（如果这个对象是一个类，你可以复写它默认的toString()方法，这个方法会自动被调用）。 举个例子我们不妨来看看之前的例子。在联系人和评论的部分，我们可以随时保存用户输入的东西。这样一来，即使用户不小心关闭了浏览器，之前输入的东西也不会丢失。对于jQuery来说，这个功能是小菜一碟。（注意：表单中每个输入字段都有id，在这里我们就用id来指代具体的字段） 1234567$(&apos;#comments-input, .contact-field&apos;).on(&apos;keyup&apos;, function () &#123;// let&apos;s check if localStorage is supported if (window.localStorage) &#123; localStorage.setItem($(this).attr(&apos;id&apos;), $(this).val()); &#125;&#125;); 每次提交联系人和评论的表单，我们需要清空缓存的值，我们可以这样处理提交（submit）事件： 123456789$(&apos;#comments-form, #contact-form&apos;).on(&apos;submit&apos;, function () &#123;// get all of the fields we saved $(&apos;#comments-input, .contact-field&apos;).each(function () &#123;// get field&apos;s id and remove it from local storage localStorage.removeItem($(this).attr(&apos;id&apos;)); &#125;);&#125;); 最后，每次加载页面的时候，把缓存的值填充到表单上即可： 1234567891011// get all of the fields we saved$(&apos;#comments-input, .contact-field&apos;).each(function () &#123;// get field&apos;s id and get it&apos;s value from local storage var val = localStorage.getItem($(this).attr(&apos;id&apos;));// if the value exists, set it if (val) &#123; $(this).val(val); &#125;&#125;); IndexedDB在我个人看来，这是最有意思的一种技术。它可以保存大量经过索引（indexed）的数据在浏览器端。这样一来，就能在客户端保存复杂对象，大文档等等数据。而且用户可以在离线情况下访问它们。这一特性几乎适用于所有类型的Web应用：如果你写的是邮件客户端，你可以缓存用户的邮件，以供稍后再看；如果你写的是相册类应用，你可以离线保存用户的照片；如果你写的是GPS导航，你可以缓存用户的路线……不胜枚举。 IndexedDB是一个面向对象的数据库。这就意味着在IndexedDB中既不存在表的概念，也没有SQL，数据是以键值对的形式保存的。其中的键既可以是字符串和数字等基础类型，也可以是日期和数组等复杂类型。这个数据库本身构建于存储（store，一个store类似于关系型数据中表的概念）的基础上。数据库中每个值都必须要有对应的键。每个键既可以自动生成，也可以在插入值的时候指定，也可以取自于值中的某个字段。如果你决定使用值中的字段，那么只能向其中添加Javascript对象，因为基础数据类型不像Javascript对象那样有自定义属性。 举个例子在这个例子中，我们用一个音乐专辑应用作为示范。不过我并不打算在这里从头到尾展示整个应用，而是把涉及IndexedDB的部分挑出来解释。如果大家对这个Web应用感兴趣的话，文章的后面也提供了源代码的下载。首先，让我们来打开数据库并创建store： 12345678910111213141516171819202122232425262728293031323334353637383940414243// check if the indexedDB is supportedif (!window.indexedDB) &#123; throw &apos;IndexedDB is not supported!&apos;;// of course replace that with some user-friendly notification&#125;// variable which will hold the database connectionvar db;// open the database// first argument is database&apos;s name, second is it&apos;s version (I will talk about versions in a while)var request = indexedDB.open(&apos;album&apos;, 1);request.onerror = function (e) &#123; console.log(e);&#125;;// this will fire when the version of the database changesrequest.onupgradeneeded = function (e) &#123;// e.target.result holds the connection to database db = e.target.result;// create a store to hold the data// first argument is the store&apos;s name, second is for options// here we specify the field that will serve as the key and also enable the automatic generation of keys with autoIncrement var objectStore = db.createObjectStore(&apos;cds&apos;, &#123; keyPath: &apos;id&apos;, autoIncrement: true &#125;); // create an index to search cds by title // first argument is the index&apos;s name, second is the field in the value// in the last argument we specify other options, here we only state that the index is unique, because there can be only one album with specific title objectStore.createIndex(&apos;title&apos;, &apos;title&apos;, &#123; unique: true &#125;);// create an index to search cds by band// this one is not unique, since one band can have several albums objectStore.createIndex(&apos;band&apos;, &apos;band&apos;, &#123; unique: false &#125;);&#125;; 相信上面的代码还是相当通俗易懂的。估计你也注意到上述代码中打开数据库时会传入一个版本号，还用到了onupgradeneeded事件。当你以较新的版本打开数据库时就会触发这个事件。如果相应版本的数据库尚不存在，则会触发事件，随后我们就会创建所需的store。接下来我们还创建了两个索引，一个用于标题搜索，一个用于乐队搜索。现在让我们再来看看如何增加和删除专辑： 12345678910111213141516171819202122232425262728293031323334// adding$(&apos;#add-album&apos;).on(&apos;click&apos;, function () &#123;// create the transaction// first argument is a list of stores that will be used, second specifies the flag// since we want to add something we need write access, so we use readwrite flag var transaction = db.transaction([ &apos;cds&apos; ], &apos;readwrite&apos;); transaction.onerror = function (e) &#123; console.log(e); &#125;; var value = &#123; ... &#125;;// read from DOM// add the album to the store var request = transaction.objectStore(&apos;cds&apos;).add(value); request.onsuccess = function (e) &#123;// add the album to the UI, e.target.result is a key of the item that was added &#125;;&#125;);// removing$(&apos;.remove-album&apos;).on(&apos;click&apos;, function () &#123; var transaction = db.transaction([ &apos;cds&apos; ], &apos;readwrite&apos;); var request = transaction.objectStore(&apos;cds&apos;).delete(/* some id got from DOM, converted to integer */); request.onsuccess = function () &#123;// remove the album from UI &#125;&#125;); 是不是看起来直接明了？这里对数据库所有的操作都基于事务的，只有这样才能保证数据的一致性。现在最后要做的就是展示音乐专辑： 12345678910111213141516171819request.onsuccess = function (e) &#123; if (!db) db = e.target.result; var transaction = db.transaction([ &apos;cds&apos; ]);// no flag since we are only reading var store = transaction.objectStore(&apos;cds&apos;);// open a cursor, which will get all the items from database store.openCursor().onsuccess = function (e) &#123; var cursor = e.target.result; if (cursor) &#123; var value = cursor.value; $(&apos;#albums-list tbody&apos;).append(&apos;&apos;+ value.title +&apos;&apos;+ value.band +&apos;&apos;+ value.genre +&apos;&apos;+ value.year +&apos;&apos;); // move to the next item in the cursor cursor.continue(); &#125; &#125;&#125; 这也不是十分复杂。可以看见，通过使用IndexedDB，可以很轻松的保存复杂对象，也可以通过索引来检索想要的内容： 12345678910111213141516171819function getAlbumByBand(band) &#123; var transaction = db.transaction([ &apos;cds&apos; ]); var store = transaction.objectStore(&apos;cds&apos;); var index = store.index(&apos;band&apos;);// open a cursor to get only albums with specified band// notice the argument passed to openCursor() index.openCursor(IDBKeyRange.only(band)).onsuccess = function (e) &#123; var cursor = e.target.result; if (cursor) &#123;// render the album// move to the next item in the cursor cursor.continue(); &#125; &#125;);&#125; 使用索引的时候和使用store一样，也能通过游标（cursor）来遍历。由于同一个索引值名下可能有好几条数据（如果索引不是unique的话），所以这里我们需要用到IDBKeyRange。它能根据指定的函数对结果集进行过滤。这里，我们只想根据指定的乐队进行检索，所以我们用到了only()函数。也能使用其它类似于lowerBound()，upperBound()和bound()等函数，它们的功能也是不言自明的。 CDNCDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 提供cdn的服务商很多，我所熟悉的是 又拍云，它不仅提供cdn加速服务，还有云处理的能力，比如 图片压缩、打水印、锐化等 ，个人比较推荐使用这个。你可以把 项目发布的静态资源（图片、样式、脚本）托管到又拍云上，图片还可以添加云处理如打水印等，相当方便。 懒加载懒加载是一种资源加载方案，符合人脑认识事物的规则，用户滚动页面的时候自动获取更多的数据,而新得到的数据不会影响原有数据的显示,同时最大程度上减少服务器端的资源耗用。Web应用程序做的最多就是和后台数据库交互，而查询数据库是种非常耗时的过程。当数据库里记录过多时，查询优化更显得尤为重要。为了解决这种问题，有人提出了缓存的概念。缓存就是将用户频繁使用的数据放在内存中以便快速访问。在用户执行一次查询操作后，查询的记录会放在缓存中。当用户再次查询时，系统会首先从缓存中读取，如果缓存中没有，再查询数据库。缓存技术在一定程度上提升了系统性能，但是当数据量过大时，缓存就不太合适了。因为内存容量有限，把过多的数据放在内存中，会影响电脑性能。而另一种技术，懒加载可以解决这种问题。 图片懒加载图片懒加载的实现思路很简单，一般是针对首页面内容比较长的页面，根据鼠标的滚动逐渐显示当屏的所有图片。你可能觉得这和 “瀑布流” 有点相似，但其实两者有本质差异。瀑布流是为了替代短分页，每次执行瀑布流会执行ajax操作。但是懒加载不一样，大家应该知道影响页面加载速度罪魁祸首就是图片，加载图片需要从服务端把图片download到浏览器然后渲染出来，这个过程非常耗时。但是 从服务端 下载图片的 url然后存储在DOM节点里是相当快速的。 上面说的比较拗口，还是来个例子演示一下。先下载 jQuery的 lazyload插件，我们把图片真正的url存在img标签的data-original 里，src属性 可以放一个 加载动画的gif图片的url，这样可以优化用户体验。 123&lt;div class=&quot;new-img-box&quot;&gt; &lt;img data-original=&quot;&#123;&#123;item.picture&#125;&#125;&quot; class=&quot;lazyload&quot; src=&quot;http://baaistatic.b0.upaiyun.com/Static/HK/load.gif_400&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; 12/*执行图片加载缓冲*/$(&apos;.lazyload&apos;).lazyload(&#123;effect : &quot;fadeIn&quot;&#125;); 这样，随着鼠标滚动栏滚动，进入当屏焦点的图片就会被 渐变加载。 用户体验用户体验优化，又叫交互优化，目的是让webApp更好用。主要是通过替换方案改变 用户感知到的响应速度，结合移动设备特点提供更有针对性、更好用的体验。 点击这个问题在我之前的文章里有详细介绍，感兴趣的同学可以 戳这里 。当然这里不做长篇大论复述，只说下原理和方案。 300ms延迟存在的理由就目前而言，还有很多的站点没有做移动端分辨率兼容，因此部分区域需要放大、缩小来浏览。而移动端常用放大缩小的方案就是通过 “双击” ，然后在指定区域放大或缩小显示。那么问题来了，怎样区分用户是单击还是双击呢？PC端我们是通过鼠标连续两次点击的时间差来确定这个事件的触发，同样的道理，移动端我们也需要用户手指连续两次点击的这个时间差，也就是300ms延迟。 tap事件的原理解决300ms延迟，最简单的办法是引入移动端的框架如zepto，用它提供的tap事件替代click事件。当然我并不强制要求你用zepto框架来做webApp开发，这里我重点是想说 tap事件的原理。 首先我们要明确，tap事件不是移动端浏览器原生支持的事件，而是通过 touchstart －&gt; touchmove －&gt; touchend 这三个事件模拟出来的。基本条件有2个： 1）从接触到离开时间间隔短 2）从起点到终点的距离小 只要能监听3个事件满足上面2个条件，你可以自己模拟出一个 tap 事件。比如我之前说的 fastClick。除此之外，如果你使用的是其他框架，有一个一劳永逸的方法就是拓展 on 方法，比如针对 jQuery： 1234567891011121314151617 /** * [针对移动端的click事件优化] * @type &#123;Boolean&#125; */var isTouch = (&apos;ontouchstart&apos; in document.documentElement) ? &apos;touchstart&apos; : &apos;click&apos;, _on = $.fn.on;if(!$.fn.quickOn)&#123; $.fn.quickOn= function()&#123; arguments[0] = (arguments[0] === &apos;click&apos;) ? isTouch: arguments[0]; return $.fn.on.apply(this, arguments); &#125;; &#125;/*注意：iOS设备quickOn会有默认事件，因此用quickOn绑定的click事件需要阻止鼠标的默认事件*/$(&apos;#btn&apos;).quickOn(&apos;click&apos;,function(e)&#123; e.preventDefault(); //....&#125;); 点击态什么是点击态？就是 给用户明确的点击反馈，提升用户体验。用两种常见的方案： 1）使用:active伪类 提供一个点击态样式。这个是通过CSS这门语言本身的特性来解决的问题，最容易让人接受，但是它有一个致命的缺点——页面滚动的时候也会触发这个伪类的样式。 2）通过添加一个class类如 .active ，tap触发的时候添加这个样式，tap结束后通过 Javascript的setTimeout 延迟150ms后移除这个样式。比如： 12345678$(&apos;#btn&apos;).on(&apos;tap&apos;,function(e)&#123; var _target=$(e.target); _target.addClass(&apos;active&apos;); setTimeout(function()&#123; _target.removeClass(&apos;active&apos;); &#125;,150);&#125;); 滚动 全局滚动，滚动条在body节点或更顶层。局部滚动，滚动条在body下的某一个DOM节点上。 弹性滚动针对IOS设备IOS设备 全局滚动 默认支持 弹性滚动，局部滚动默认不支持 弹性滚动，所以需要通过css设置。 12345678body&#123; -webkit-overflow-scrolling:touch;&#125;/*局部滚动的dom节点*/.scroll-el&#123; overflow:auto;&#125; 这个属性建议挂在body上，这样子节点可以继承这个属性，可以避免不必要的bug。 针对Andriod设备定制版本较多，表现各异，虽然默认没有弹性滚动的效果，但很多版本支持 力度滚动，而且也没有IOS上默认生硬的滚动效果效果。 -webkit-overflow-scrolling 默认浏览器是不支持的，所以不会起效果。 IOS出界困扰什么时候会触发出界呢？全局滚动：滚动到页面顶部（或底部）时继续向下（向上）滚动，就会出现。局部滚动：滚动到页面顶部（或底部）时，手指离开停下，再继续向下（向上）滑动，就会出现。 解决方案局部滚动：使用 scrollFix123456if(startTopScroll&lt;=0)&#123; elem.scrollTop=1;&#125;if(startTopScroll+elem.offsetHeight&gt;=elem.scrollHeight)&#123; elem.scrollTop=elem.scrollHeight-elem.offsetHeight-1;&#125; 除此之外，对于局部滚动页面的固定区域要禁止touchmove默认事件。 全局滚动： 暂时没有找到好的解决方法，可以考虑把全局滚动改成局部滚动。不过从iOS8开始Safari的出界部分的背景色和body的背景色保持一致。 Android 蛋疼的局部滚动andriod下使用局部滚动，会导致滚动条显示异常，且滚动不流畅。因此建议只使用全局滚动，固定元素可以通过定位在顶部或底部，然后给body添加内上边距或内下边距 模拟局部滚动的效果。 流畅滚动的N条军规1）body上加上 -webkit-overflow-scrolling:touch2）iOS尽量使用局部滚动3）iOS引进scrollFix避免出界4）andriod下尽量使用全局滚动：尽量不用overflow:auto ,使用 min-height:100%代替 height:100%。5）iOS下带有滚动条且position:absolute的节点不要设置背景色。 键盘定制定制软键盘样式可以通过设置input的 type 属性： 1234567&lt;form&gt; &lt;input type=&quot;email&quot; /&gt; &lt;input type=&quot;url&quot; /&gt; &lt;input type=&quot;tel&quot; /&gt; &lt;input type=&quot;number&quot; /&gt; &lt;input type=&quot;search&quot; /&gt;&lt;/form&gt; 这里要注意一点，需要给form设置阻止默认onsubmit事件。 另外还有个纯数字键盘的方案，注意pattern的属性值只能是 [0-9]*123&lt;form&gt; &lt;input type=&quot;text&quot; pattern=&quot;[0-9]*&quot; /&gt;&lt;/form&gt; 定制软键盘行为可以通过配置input节点的 autocapitalize、autocorrect 属性。 1）输入英文用户名首字母自动大写的别扭。1&lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt; 2）自动纠错1&lt;input type=&quot;text&quot; autocorrect=&quot;on&quot; /&gt;","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"webApp","slug":"webApp","permalink":"http://jafeney.com/tags/webApp/"}]},{"title":"Node爬坑记——伪造cookie","date":"2016-01-21T15:33:59.000Z","path":"2016/01/21/2016-01-20-cookie/","text":"写在前面在没有引入NodeJS层之前，客户端和服务端之前的数据传输可以用Ajax来完成，而且服务端可以直接读取客户端请求头携带的cookie，这个直接走 HTTP 协议，没有任何问题。但是当引入了一个NodeJS作为中间层，通过中间层调用服务层（比如Java的数据接口层）的接口时，你会发现 直接走http协议，Java层根本无法读取到 原本从客户端发送过来的cookie。这个时候 就需要在中间层 伪造一个cookie了。 客户端cookie在切入正题之前不妨先谈谈客户端cookie的情况，相信这也是你很想明白的东西。 Ajax如何跨域发送cookie刚才虽然说这个很容易，其实对于初学者来说还是有个陷阱在里面的，这个场景当然是发生在跨域请求里。不跨域的ajax请求原则上是可以携带cookie的，跨域了之后就需要设置XMLHttpRequest对象的一些参数了。 跨域的几种方式浅淡我所了解的跨域方案有5种，这里不做详细介绍。如果感兴趣，请用力 戳这里 document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com那显然是会报错地！ 动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。 利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。 window.name实现的跨域数据传输文章较长列在此处不便于阅读，你可以戳这里 。 使用HTML5 postMessage具体使用这个方法：otherWindow.postMessage(message, targetOrigin); otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制 用原生JavaScript Cookie操作123456789101112131415161718192021222324252627282930313233343536//COOKIE功能检查function fCheckCookie()&#123; if(!navigator.cookieEnabled)&#123; alert(&quot;您好，您的浏览器设置禁止使用cookie\\n请设置您的浏览器，启用cookie功能，再重新登录。&quot;); &#125;&#125;//获取Cookiefunction fGetCookie(sName)&#123; var sSearch = sName + &quot;=&quot;; if(document.cookie.length &gt; 0)&#123; offset = document.cookie.indexOf(sSearch) if(offset != -1)&#123; offset += sSearch.length; end = document.cookie.indexOf(&quot;;&quot;, offset) if(end == -1) end = document.cookie.length; return unescape(document.cookie.substring(offset, end)) &#125; else return &quot;&quot;； &#125;&#125;//设置Cookiefunction fSetCookie(name, value, isForever, domain)&#123; var sDomain = &quot;;domain=&quot; + (domain || gOption[&quot;sCookieDomain&quot;] ); document.cookie = name + &quot;=&quot; + escape(value) + sDomain + (isForever?&quot;;expires=&quot;+ (new Date(2099,12,31)).toGMTString():&quot;&quot;);&#125;//跨域调用方法function fGetScript(sUrl)&#123; var oScript = document.createElement(&quot;script&quot;); oScript.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); oScript.setAttribute(&quot;src&quot;, sUrl); try&#123;oScript.setAttribute(&quot;defer&quot;, &quot;defer&quot;);&#125;catch(e)&#123;&#125; window.document.body.appendChild(oScript);&#125; 用jQuery实现跨域调用cookie下面这段代码是个跨域读取cookie的例子：1234567891011121314151617181920$.ajax(&#123; type:&apos;get&apos;, url:_self.APIURL+&apos;/activity/isAttended.json&apos;, dataType:&apos;jsonp&apos;, data:&#123; activityId:_activityId, callback:1 &#125;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, success:function(res)&#123; if(res.isAttended==1)&#123; $(&apos;#indexMask&apos;).show(); &#125;else&#123; $(&apos;#indexMask&apos;).hide(); &#125; &#125;&#125;); 中间层cookie用原生http模块实现伪造cookie引入http模块（NodeJS的核心模块，可以直接调用）1var http=require(&apos;http&apos;); 路由方法（这里以购物车为例）12/*GET shopCar page.*/router.get(&apos;/shopCar&apos;,function(req,res,next)&#123;&#125; request方法的options参数配置（这一步即可在headers里伪造cookie）12345678910var options = &#123; hostname: &apos;api.baai.hk&apos;, port: 80, path: &apos;/cart.shtml&apos;, method: &apos;GET&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;, &apos;Cookie&apos;: &apos;baai_user_token=&apos;+req.cookies.baai_user_token &#125; &#125;; 模板渲染接着上面的路由方法，headers里的cookie伪造好之后就可以调用request请求了。12345678910111213141516171819202122/*声明一个空变量缓存返回的数据流（这一步很关键哦）*/var temp=&apos;&apos;;/*发起http请求*/var req = http.request(options, function (_res) &#123; console.log(&apos;STATUS: &apos; + res.statusCode); console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers)); _res.setEncoding(&apos;utf8&apos;); _res.on(&apos;data&apos;, function (chunk) &#123; console.log(chunk); /*把数据流拼接起来得到完整数据*/ _temp+=chunk; &#125;); _res.on(&apos;end&apos;, function()&#123; /*模板渲染*/ var data=JSON.parse(_temp); res.render(&apos;shopCar&apos;, data); &#125;);&#125;); /*关闭http请求*/req.end(); 用三方的request模块实现三方有个request模块，封装了原生http模块的一些功能，比较好用，也比较推荐使用这个。 安装request模块1npm install request --save 调用模块1var request=require(&apos;request&apos;); 这里注意一下，request为了安全默认是禁用cookie 的，需要手动开启。在defaults或options将jar设为true，使后续的请求都使用cookie。 1234var request = request.defaults(&#123;jar: true&#125;);request(&apos;http://www.google.com&apos;, function (_res) &#123; request(&apos;http://images.google.com&apos;);&#125;); 通过创建request.jar()的新实例，可以使用定制的cookie，而不是request全局的cookie jar，看下面这个实例。 12345678910var j = request.jar();var cookie = request.cookie(&apos;baai_user_token&apos;);j.setCookie(cookie, &apos;http://www.baai.hk&apos;, function (err, cookie)&#123; console.log(&apos;cookie set succeeded&apos;);&#125;);request(&#123;url: &apos;http://www.baai.hk/cart.shtml&apos;, jar: j&#125;, function (_res) &#123; /*模板渲染*/ var data=JSON.parse(_res); res.render(&apos;shopCar&apos;, data);&#125;); 结语就目前而言，NodeJS在国内互联网圈子里的地位还是属于刚起家的状况，这门技术应用的领域也相对单一，虽然阿里对NodeJS（尤其像淘宝、天猫）相当重视，今年双十一和双十二也充分尝到了技术进步带来的甜头。但是 NodeJS 作为中间层开发方面的文章、帖子、社区还是相对薄弱些，不过相信会一天天好起来吧。小子我虽初入茅庐，也很愿意花些业余时间为NodeJS 的开源工作 做些小小的贡献。 欢迎大家关注我的技术个人博客： http://jafeney.com ^_^","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"},{"name":"cookie","slug":"cookie","permalink":"http://jafeney.com/tags/cookie/"}]},{"title":"断点调试你的express项目","date":"2016-01-16T07:07:33.000Z","path":"2016/01/16/2016-01-16-express-debug/","text":"写在前面前端工程师接触最多的是JavaScript，JavaScript程序可以通过浏览器进行调试，比如chrome的调试工具、Firefox的FireBug等。现在大前端趋势下前端工程师开始接触NodeJS这个JavaScript的孪生兄弟，俗话说殊途同归，NodeJS当然也可以通过chrome的调试工具进行断点调试。这篇文章着重介绍一下这个技术。 node-inspector全局安装node-inspector执行这一步之前请确保已成功安装NodeJS环境，然后执行如下代码安装 node-inspector模块。1npm install -g node-inspector 以debug模式开启express服务我的Node项目习惯用express搭建，然后用supervisor自动监听改动并重启服务。如果对这个模式不太了解，请用力戳 这里 。 1supervisor --debug ./bin/www 启动node-inspector接着再打开一个命令窗口，执行下面的命令1node-inspector &amp; 这样 node-inspector服务就启动了，打开chrome浏览器（或者chrome内核的浏览器），输入1http://localhost:8080/?ws=localhost:8080&amp;port=5858 注意 如果不想默认监听8080端口，可以手动设置端口号，比如1node-inspector &amp; -p 8888 调试NodeJS程序接下来我们就可以 在chrome里 像之前调试 JavaScript一样 调试我们的NodeJS程序了","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"},{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"}]},{"title":"前端模板预编译技术——tmodJS浅谈","date":"2016-01-14T03:57:02.000Z","path":"2016/01/14/2016-01-14-tmodJS/","text":"什么是前端模板预编译前端模板预编译通过预编译技术让前端模板突破浏览器限制，实现后端模板一样的同步“文件”加载能力。它采用目录来组织维护前端模板，从而让前端模板实现工程化管理，最终保证前端模板在复杂单页 web 应用下的可维护性。同时预编译输出的代码经过多层优化，能够在最大程度节省客户端资源消耗。 按文件与目录组织模板1template(&apos;tpl/home/main&apos;, data) 模板支持引入子模板1&#123;&#123;include &apos;../public/header&apos;&#125;&#125; TmodJS 一经启动，就无需人工干预，每次模板创建与更新都会自动编译，引入一个 js 即可使用template(path)接口调用本地模板文件，直到正式上线都无需对代码进行任何修改，整个过程简单自然。 强大之处 编译模板为不依赖引擎的 js 文件 前端模板按文件与目录组织 模板之间支持引入外部模板 使用同步模板加载接口 可选多种规范的模块输出：AMD、CMD、CommonJS 支持作为 GruntJS 的插件构建项目 模板目录可被前后端共享 支持检测修改即时编译 支持模板运行时调试 配置文件支持多人共享 使用tmodJS全局安装1npm install -g tmodjs 编写模板TmodJS 的前端模板不再耦合在业务页面中，而是和后端模板一样有专门的目录管理。目录名称只支持英文、数字、下划线的组合，一个模板对应一个.html文件。 模板语法和artTemplate一脉相承，建议协同使用。 表达式 符号包裹起来的语句则为模板的逻辑表达式。### 输出表达式对内容编码输出：1&#123;&#123;content&#125;&#125; 不编码输出（编码可以防止数据中含有 HTML 字符串，避免引起 XSS 攻击） 1&#123;&#123;#content&#125;&#125; 条件表达式1234567&#123;&#123;if admin&#125;&#125; &lt;p&gt;admin&lt;/p&gt;&#123;&#123;else if code &gt; 0&#125;&#125; &lt;p&gt;master&lt;/p&gt;&#123;&#123;else&#125;&#125; &lt;p&gt;error!&lt;/p&gt;&#123;&#123;/if&#125;&#125; 遍历表达式无论数组或者对象都可以用 each 进行遍历。 123&#123;&#123;each list as value index&#125;&#125; &lt;li&gt;&#123;&#123;index&#125;&#125; - &#123;&#123;value.user&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125; 亦可以被简写： 123&#123;&#123;each list&#125;&#125; &lt;li&gt;&#123;&#123;$index&#125;&#125; - &#123;&#123;$value.user&#125;&#125;&lt;/li&gt;&#123;&#123;/each&#125;&#125; 模板包含表达式用于嵌入子模板：1&#123;&#123;include &apos;template_name&apos;&#125;&#125; 子模板默认共享当前数据，亦可以指定数据： 1&#123;&#123;include &apos;template_name&apos; news_list&#125;&#125; include 路径规范约定 路径不能带后缀名 路径不能够进行字符串运算 路径不能使用变量代替 必须使用以.开头的相对路径辅助方法1&#123;&#123;time | dateFormat:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125; 支持传入参数与嵌套使用：1&#123;&#123;time | say:&apos;cd&apos; | ubb | link&#125;&#125; 为了模板可维护，模板本身是不能随意访问外部数据的，它所有的语句都将运行在一个沙箱中。如果需要访问外部对象可以注册辅助方法，这样所有的模板都能访问它们。 新建一个辅助方法文件配置在模板目录新建一个 config/template-helper.js 文件，然后编辑 package.json 设置”helpers”: “./config/template-helper.js”。 编写辅助方法在 config/template-helper.js 中声明辅助方法。 以日期格式化为例：1234567891011121314151617181920212223242526272829template.helper(&apos;dateFormat&apos;, function (date, format) &#123; date = new Date(date); var map = &#123; &quot;M&quot;: date.getMonth() + 1, //月份 &quot;d&quot;: date.getDate(), //日 &quot;h&quot;: date.getHours(), //小时 &quot;m&quot;: date.getMinutes(), //分 &quot;s&quot;: date.getSeconds(), //秒 &quot;q&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 &quot;S&quot;: date.getMilliseconds() //毫秒 &#125;; format = format.replace(/([yMdhmsqS])+/g, function(all, t)&#123; var v = map[t]; if(v !== undefined)&#123; if(all.length &gt; 1)&#123; v = &apos;0&apos; + v; v = v.substr(v.length-2); &#125; return v; &#125; else if(t === &apos;y&apos;)&#123; return (date.getFullYear() + &apos;&apos;).substr(4 - all.length); &#125; return all; &#125;); return format;&#125;); 调用：1&#123;&#123;time | dateFormat:&apos;yyyy-MM-dd hh:mm:ss&apos;&#125;&#125; 编译模板只需要运行tmod这个命令即可，默认配置参数可以满足绝大多数项目。1tmod [模板目录] [配置参数] 注意：模板目录必须是模板的根目录，若无参数则为默认使用当前工作目录，tmodjs 会监控模板目录修改，每次模板修改都会增量编译。 配置参数 --debug 输出调试版本 --charset value 定义模板编码，默认utf-8 --output value 定义输出目录，默认./build --type value 定义输出模块格式，默认default，可选cmd、amd、commonjs --no-watch 关闭模板目录监控 --version 显示版本号 --help 显示帮助信息 注意：配置参数将会保存在模板目录配置文件中，下次运行无需输入配置参数（–no-watch 与 –debug 除外）。 举个例子1tmod ./tpl --output ./build 使用模板根据编译的 type 的配置不同，会有两种不同使用方式： 使用默认的格式TmodJS 默认将整个目录的模板压缩打包到一个名为 template.js 的脚本中，可直接在页面中使用它：12345&lt;script src=&quot;tpl/build/template.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var html = template(&apos;news/list&apos;, _list); document.getElementById(&apos;list&apos;).innerHTML = html;&lt;/script&gt; RequireJS、SeaJS、NodeJS 加载 在线实例 http://aui.github.io/tmodjs/test/index.html 指定格式（amd / cmd / commonjs)此时每个模板就是一个单独的模块，无需引用 template.js： 12var render = require(&apos;./tpl/build/news/list&apos;);var html = render(_list); 注意：模板路径不能包含模板后缀名 演示TmodJS 源码包中test/tpl是一个演示项目的前端模板目录，基于默认配置。切换到源码目录后，编译：1tmod test/tpl 编译完毕后你可以在浏览器中打开 test/index.html 查看如何使用编译后的模板。 配置TmodJS 的项目配置文件保存在模板目录的 package.json 文件中： 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;template&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;dependencies&quot;: &#123; &quot;tmodjs&quot;: &quot;1.0.0&quot; &#125;, &quot;tmodjs-config&quot;: &#123; &quot;output&quot;: &quot;./build&quot;, &quot;charset&quot;: &quot;utf-8&quot;, &quot;syntax&quot;: &quot;simple&quot;, &quot;helpers&quot;: null, &quot;escape&quot;: true, &quot;compress&quot;: true, &quot;type&quot;: &quot;default&quot;, &quot;runtime&quot;: &quot;template.js&quot;, &quot;combo&quot;: true, &quot;minify&quot;: true, &quot;cache&quot;: false &#125;&#125; gulp配置让 TmodJS 作为 Gulp 的一个插件使用：1npm install gulp-tmod --save-dev 由@lichunqiang开发，项目主页：https://github.com/lichunqiang/gulp-tmod 常见Q&amp;A问：TmodJS 需要部署到服务器中吗？ 不需要，这是本地工具，基于 NodeJS 编写是为了实现跨平台。 问：如何将每个模板都编译成单独的 amd/cmd 模块输出？ 指定 type 参数即可，如–type cmd则可以让每个模板都支持 RequireJS/SeaJS 调用。 问：如何将模板编译成 NodeJS 的模块？ 指定 type 参数即可，如–type commonjs。 问：线上运行的模板报错了如何调试？ 开启 debug 模式编译，如–debug，这样会输出调试版本，可以让你快速找到模板运行错误的语句以及数据。 问：如何不压缩输出 js？ 编辑配置文件，设置”minify”: false。 问：如何修改默认的输出目录？ 指定 output 参数即可，如–output ../../build 如何让模板访问全局变量？ 具体参考上面的 辅助方法。 问：可以使用使用类似 tmpl 那种的 js 原生语法作为模板语法吗？ 可以。编辑配置文件，设置”syntax”: “native”即可，目前 TmodJS 默认使用的是 simple 语法。 问：如何兼容旧版本 atc 的项目？ 编辑配置文件，分别设置”type”: “cmd”、”syntax”: “native”、”output”: “./“ 问：如何迁移原来写在页面中的 artTemplate 模板，改为 TmodJS 这种按按文件存放的方式？ 参考 《页面中的模板迁移指南》 问：我需要手动合并模板，如何让 tmodjs 不合并输出？ 编辑配置文件，设置combo:false。 @参考 《前端模板外置解决方案》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://jafeney.com/tags/模板引擎/"}]},{"title":"ArtTemplate helper函数的使用","date":"2016-01-11T09:28:01.000Z","path":"2016/01/11/2016-01-10-art/","text":"写在前面”Art虐我千百遍，而我待她如初恋“，前端模板引擎很多，机缘巧合之下结识了这位美丽的Art，于是对她情有独钟，纵使开源社区薄弱，API文档稀缺，还是坚韧不拔地去 使用她。和她相处的几个月里 遇到的坑，趟过的枪实在是不计其数，但是没关系，既然选择了她，那就要一心一意，去克服困难，一起成长不是吗？ nodeJS中使用最初结识它是在 WebApp开发的时候，那时还不太会nodeJS，Art也仅仅是用在客户端 数据的渲染上，用的最多的是 、 、 这些东西。在客户端JavaScript中 模块化有诸多限制，必须依托AMD或者CMD的方式来实现，而且客户端使用模板引擎对SEO的支持着实无助。当然这也算是自己趟过的一个坑吧，其实 Art真正实现价值还是在3.0之后 对nodeJS的支持，这样打破了传统的express+jade 组合模式，开启了另一个高性能的前后端可共用的模板引擎时代。 安装使用npm之前先确保已经安装了nodeJS，使用 node -v 测试一下，然后：1npm install art-template 使用123var template = require(&apos;art-template&apos;);var data = &#123;list: [&quot;aui&quot;, &quot;test&quot;]&#125;;var html = template(__dirname + &apos;/index/main&apos;, data); 配置NodeJS 版本新增了如下默认配置：| 字段 | 类型 | 默认值 | 说明 || —:— |—:—|—:—| —:—|| base | String | &#39;&#39; | 指定模板目录 || extname| String | &#39;.html&#39; | 指定模板后缀名 || encoding | String | &#39;utf-8&#39; | 指定模板编码 | 注意：配置base指定模板目录可以缩短模板的路径，并且能够避免include语句越级访问任意路径引发安全隐患，例如： 12template.config(&apos;base&apos;, __dirname);var html = template(&apos;index/main&apos;, data) NodeJS + Express这个在之前的文章里已经详细介绍了，配置方法大致长这样。123456var template = require(&apos;art-template&apos;);template.config(&apos;base&apos;, &apos;&apos;);template.config(&apos;extname&apos;, &apos;.html&apos;);app.engine(&apos;.html&apos;, template.__express);app.set(&apos;view engine&apos;, &apos;html&apos;);//app.set(&apos;views&apos;, __dirname + &apos;/views&apos;); 还不清楚的 用力戳 这里 helper函数helper函数的API很简单，但它的用处实在不小。也正是因为它的存在使得 Art变得非常地灵活——这也完全取决于你的自己。1template.helper(name, callback) 先看一下官方 yanis.wang 写的例子，他老人家故意整个正则和参数形式的回调 来提高逼格，小子我来回看了好几遍才搞懂（加了些注释进去） ~_~ 所以看之前，对 replace函数不熟悉的请 戳这里 html部分12345678&lt;!--数据容器--&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;!--/数据容器--&gt;&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt; /*对time对象进行格式化*/ &#123;&#123;time | dateFormat:&apos;yyyy年 MM月 dd日 hh:mm:ss&apos;&#125;&#125;&lt;/script&gt; JavaScript部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 对日期进行格式化， * @param date 要格式化的日期 * @param format 进行格式化的模式字符串 * 支持的模式字母有： * y:年, * M:年中的月份(1-12), * d:月份中的天(1-31), * h:小时(0-23), * m:分(0-59), * s:秒(0-59), * S:毫秒(0-999), * q:季度(1-4) * @return String * @author yanis.wang * @see http://yaniswang.com/frontend/2013/02/16/dateformat-performance/ */template.helper(&apos;dateFormat&apos;, function (date, format) &#123; date = new Date(date); //新建日期对象 /*日期字典*/ var map = &#123; &quot;M&quot;: date.getMonth() + 1, //月份 &quot;d&quot;: date.getDate(), //日 &quot;h&quot;: date.getHours(), //小时 &quot;m&quot;: date.getMinutes(), //分 &quot;s&quot;: date.getSeconds(), //秒 &quot;q&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 &quot;S&quot;: date.getMilliseconds() //毫秒 &#125;; /*正则替换*/ format = format.replace(/([yMdhmsqS])+/g, function(all, t)&#123; var v = map[t]; if(v !== undefined)&#123; if(all.length &gt; 1)&#123; v = &apos;0&apos; + v; v = v.substr(v.length-2); &#125; return v; &#125; else if(t === &apos;y&apos;)&#123; return (date.getFullYear() + &apos;&apos;).substr(4 - all.length); &#125; return all; &#125;); /*返回自身*/ return format;&#125;);/*数据*/var data = &#123; time: (new Date).toString(),&#125;;/*渲染*/var html = template(&apos;test&apos;, data);/*绑定*/document.getElementById(&apos;content&apos;).innerHTML = html; 当然了，看不懂这个例子也没关系，我扔块 “低小下”的砖头给你。 一块丑丑的砖头app.js12345678910111213141516/*引用artTemplate模板*/var template=require(&apos;art-template&apos;);template.render(&apos;transNumber&apos;,function(number)&#123; swich(number)&#123; case 0: return &quot;zero&quot;; break; case 1: return &quot;none&quot;; break; //...more and more default: break; &#125;&#125;); test.art1&lt;div&gt;&#123;&#123;number | transNumber:number&#125;&#125;&lt;/div&gt; 没错，这么搞就可以了，回调函数 按照实际需求爱怎么写就怎么写。 #最后欢迎关注我的个人博客： http://jafeney.com ^_^","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"},{"name":"模板引擎","slug":"模板引擎","permalink":"http://jafeney.com/tags/模板引擎/"}]},{"title":"JavaScript Singleton（单例）模式","date":"2016-01-10T07:29:05.000Z","path":"2016/01/10/2016-01-10-model-singleton/","text":"写在前面singleton模式是被熟知的原因是因为它限制了类的实例化次数只能一次。从经典意义上来说，singleton模式在该实例不存在的情况下，可以通过一个方法创建一个类来实现创建类的新实例；如果实例已经存在，它会简单返回该对象的引用。 singleton不同于静态类(或对象)，因为我们可以推迟它们的初始化，这通常是因为它们需要一些信息，而这些信息在初始化期间可能无法获得、对于没有察觉到之前的引用的代码，它们不会提供方便检索的方法。这是因为它既不是对象，也不是由一个singleton返回的“类”；它是一个结构。 思考一下闭包变量为何实际上并不是闭包，而提供闭包的函数作用域是闭包。在Javascript中，singleton充当共享资源命名空间，从全局命名空间中隔离出代码实现，从而为函数提供单一访问点。 来个例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var mySingleton=(function()&#123; //实例保持了Singleton的一个引用 var instance; function init()&#123; //Singleton //私有方法和变量 function privateMethod()&#123; console.log(&quot;I am private&quot;); &#125; var privateVariable=&quot;I am also private&quot;; var privateRandomNumber=Math.random(); return&#123; //公有方法和变量 publicMethod:function()&#123; console.log(&quot;The public can see me!&quot;); &#125;, publicProperty:&quot;I am also public&quot;, getRandomNumber:function()&#123; return privateRandomNumber; &#125; &#125;; &#125; return&#123; //获取singleton的实例，如果存在则返回，不存在就创建新实例 getInstance:function()&#123; if(!instance)&#123; instance=init(); &#125; return instance; &#125; &#125;&#125;)();var myBadSingleton=(function()&#123; //实例保存了singleton的一个引用 var instance; function init()&#123; //Singleton var privateRandomNumber=Math.random(); return&#123; getRandomNumber:function()&#123; return privateRandomNumber; &#125; &#125;; &#125; return&#123; //每次都创建新实例 getInstance:function()&#123; instance=init(); return instance; &#125; &#125;;&#125;)();var singleA=mySingleton.getInstance();var singleB=mySingleton.getInstance();console.log(singleA.getRandomNumber()===SingleB.getRandomNumber()); //truevar badSingleA=myBadSingleton.getInstance();var badSingleB=myBadSingleton.getInstance();console.log(badSingleA.getRandomNumber()!==badSingleB.getRandomNumber()); //true 分析好了，写了这么多代码，我们先明确一个问题——是什么使Singleton成为实例的全局访问入口（通常通过MySingleton.getInstance()）? 因为我们没有（至少在静态语言中）直接调用新的MySingleton()。然而，这在Javascript中是可能的。 适用的场景1、当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。2、该唯一的实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 延迟执行我们看下面代码： 12345678910mySingleton.getInstance=function()&#123; if(this._instance==null)&#123; if(isFoo())&#123; this._instance=new FooSingleton(); &#125;else&#123; this._instance=new BasicSingleton(); &#125; &#125; return this._instance;&#125;; 在这里，getInstance变得有点像Factory（工厂）方法，当访问它时，我们不需要更新代码中的每个访问点。FooSingleton（上面）将是一个BasicSingleton的子类，并将实现相同的接口。 那么问题来了，为什么要延迟执行Singleton呢？ 在C++中，Singleton负责隔绝动态初始化顺序的不可预知性，将控制权归还给程序员。 值得注意的是类的静态实例（对象）和Singleton之间的区别：当Singleton可以作为一个静态的实例实现时，它也可以延迟构建，直到需要使用静态实例时，无需使用资源或内存。 如果我们有一个可以直接被初始化的静态对象，需要确保执行代码的顺序总是相同的（例如：在初始化期间objCar需要objWheel的情况），当我们有大量的源文件时，它并不能伸缩。 Singleton和静态对象都是有用的，但是我们不应当以同样的方式过度使用它们，也不应该过度地使用其他模式。 最佳实践在实践中，当在系统中确实需要一个对象来协调其他对象时，Singleton模式是很有用的，在这里，大家可以看到在这个上下文中模式的使用： 123456789101112131415161718192021222324252627282930313233343536var SingletonTester=(function()&#123; //options:包含Singleton所需配置信息的对象 //@eg: var options=&#123;name:&quot;test&quot;,pointX:5&#125;; function Singleton(options)&#123; //如果未提供options则设置为空对象 options=options || &#123;&#125;; //未Singleton设置一些属性 this.name=&quot;SingletonTester&quot;; this.pointX=options.pointX||6; this.pointY=options.pointY||10; &#125; //实例持有者 var instance; //静态变量和方法的模拟 var _static=&#123; name:&quot;SingletonTester&quot;, //获取实例的方法，返回Singleton对象的Singleton实例 getInstance:function(options)&#123; if(instance===undefined)&#123; instance=new Singleton(options); &#125; return instance; &#125; &#125;; return _static;&#125;)();var singletonTest=SingletonTester.getInstance(&#123; pointX:5&#125;);//记录pointX的输出以便验证//输出：5console.log(singletonTest.pointX); 总结Singleton很有使用价值，通常当发现在Javascript中需要它的时候，则表示我们可能需要重新评估我们的设计。Singleton的存在往往表面系统中的模块要么是系统紧密耦合，要么是其逻辑国语分散在代码库的多个部分。由于一系列的问题：从隐藏的依赖到创建多个实例的难度、底层依赖的难度等等，Singleton的测试会更加困难。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"JavaScript Revealing Module（揭示模块）模式","date":"2016-01-10T07:23:44.000Z","path":"2016/01/10/2016-01-10-model-revealing/","text":"前言在对Module模式有个熟悉的了解之后，我们来认识一个稍有改进的版本——ChristianHeilmann的Revealing Module模式。 模式的由来原来的Module模式可能无法实现这样的需求：当我们从另一个方法调用一个公有方法或者访问公有变量时，必须要重复主对象的名称。而且使用Module时必须要切换到对象字面量表示法来让某种方法变成公有方法。 我们需要的可能是这样的一个模式：能够在私有范围内简单定义所有的函数和变量，并返回一个匿名对象，它拥有指向私有函数的指针，该函数是它希望展示为公有的方法。 有点拗口，还是上代码吧 (☆_☆) 代码123456789101112131415161718192021222324var myRevealingModule=(function()&#123; var privateVar=&quot;Ben Cherry&quot;, publicVar=&quot;Hey there!&quot;; function privateFunction()&#123; console.log(&quot;Name：&quot;+privateVar); &#125; function publicSetName(strName)&#123; privateName=strName; &#125; function publicGetName()&#123; privateFunction(); &#125; /*将暴露的公有指针指向到私有函数和属性上*/ return&#123; setName:publicSetName, greeting:publicVar, getName:publicGetName &#125;;&#125;)();myRevealingModule.setName(&quot;Paul Kinlan&quot;); 优点该模式可以使脚本语法更加一致，在模块代码底部，它也会很容易指出哪些函数和变量可以被公开访问，从而改善可读性。 缺点该模式的一个缺点是：如果一个私有函数引用一个公有函数，在需要打补丁时，公有函数是不能被覆盖的。这时因为私有函数将继续引用私有实现，该模式并不适用于公有成员，只适用于函数。 引用私有变量的公有对象成员也遵守无补丁规则，正因为如此，采用Revealing Module模式创建的模块可能比那些采用原始Module模式创建的模块更加脆弱，所以在使用时应该特别小心。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"JavaScript Module模式","date":"2016-01-10T07:21:14.000Z","path":"2016/01/10/2016-01-10-model-module/","text":"写在前面Module模式最初被定义为一种在传统软件工程中为类提供私有和公有封装的方法。而在Javascript中，Module模式用于进一步模拟类的概念，通过这种方式，能够使一个单独的对象拥有公有/私有的方法和变量，从而屏蔽来自全局作用域的特殊部分。产生的结果是：函数名与在页面上其他脚本定义的函数冲突的可能性降低。 应当注意的一点是：在Javascript没有private访问修饰符因此算不得真正的私有，而是通过函数作用域来模拟私有这个概念。在Module模式内由于闭包的存在，声明的变量和方法只在该模式内部可用，但在返回对象上定义的变量和方法是可以对外访问的。 示例12345678910111213141516var testModule=(function()&#123; var counter=0; return&#123; incrementCounter:function()&#123; return ++counter; &#125;, resetCounter:function()&#123; console.log(&quot;counter value prior to reset:&quot;+counter); counter=0; &#125; &#125;;&#125;)();//增加计数器testModule.incrementCounter();//加长计数器值并重置testModule.resetCounter(); Module模式变化引入混入这种变化允许我们把全局变量（如jQUery、Underscore）作为参数传递给模块的匿名函数，并按照我们所希望的为它们取个本地别名。 1234567891011121314var myModule=(function(jQ,_)&#123; function privateMethod1()&#123; jQ(&quot;.container&quot;).html(&quot;test&quot;); &#125; function privateMethod2()&#123; console.log(_.min([10,5,100,2,1000])); &#125; return&#123; publicMethod:function()&#123; privateMethod1(); &#125; &#125;;//引入jQuery对象和underscore对象&#125;)(jQuery,_); 引出这种变化允许我们声明全局变量，而不需要实现它们，并可以同样地支持上一个实例中全局引入的概念。 1234567891011121314var myModule=(function()&#123; //模块对象 var module=&#123;&#125;, privateVariable=&quot;Hello World&quot;; function privateMethod()&#123; //.... &#125; module.publicProperty=&quot;Foobar&quot;; module.publicMethod=function()&#123; console.log(privateVariable); &#125; return module;&#125;)(); 总结优点我们已经了解单例模式如何使用，但为什么Module模式是一个好的选择呢？首先，相比真正封装的思想，它对于很多拥有面向对象背景的开发人员来说更加整洁，至少是从Javascript的角度。 其次，他支持私有数据，因此在Module模式中代码的公有部分能够接触私有部分，然而外界无法接触类的私有部分。 缺点Module模式的缺点是：由于我们访问公有和私有成员的方式不同，当我们想改变可见性时，实际上我们必须要修改每一个曾经使用该成员的地方。 我们也无法访问那些之后再方法里添加的私有成员。也就是说在很多情况下，如果正确使用Module模式任然是当然有用的，肯定可以改进应用程序的结构。 其他缺点包括：无法为私有成员创建自动化单元测试，bug需要修正补丁时会增加额外的复杂性。为私有方法打补丁是不可能的。相反，我们必须覆盖所有bug的私有方法进行交互的公有方法。另外开发人员也无法轻易地拓展私有方法，所以要记住私有方法并不想它们最初显示出来那么灵活。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"JavaScript Constructor(构造器)模式","date":"2016-01-10T07:18:36.000Z","path":"2016/01/10/2016-01-10-model-constructor/","text":"前言在经典的面相对象语言编程中，Constructor是一种在内存已分配给该对象的情况下，用于初始化新创建对象的特殊方法。在Javascript中，几乎所有东西都是对象，我们通常最感兴趣的是object构造器。 object构造器用于创建特定类型的对象——准备好对象以备使用，同时接收构造器可以使用的参数，以在第一次创建对象时，设置成员属性和方法的值。 基本ConstructorJavascript虽然不支持类的概念，但它确实支持与对象一起用的特殊constructor函数，通过在构造器前面加new关键字，告诉Javascript像使用构造器一样实例化一个新对象，并且对象成员由该函数定义。 在构造器内，this关键字引用新创建的对象。回顾对象创建，基本的构造器看起来可能是这样的： 123456789101112131415function Car(model,year,miles)&#123; this.model=model; this.year=year; this.miles=miles; this.toString=function()&#123; return this.model+&quot;has done &quot;+this.miles+&quot;miles&quot;; &#125;;&#125;var civic=new Car(&quot;Honda Civic&quot;,2009,20000);var mondeo=new Car(&quot;Ford Mondeo&quot;,2010,5000);console.log(civic.toString());console.log(mondeo.toString()); &gt;分析：上面是一个简单的构造器模式版本，但它有2个问题。 它使得继承变得困难； toString()这样的函数是为每个使用Car构造器创建的新对象而分别重新定义的，这不是最理想的构造方式，因为这种函数应该在所有Car类型实例之间共享。 带原型的ConstructorJavascript的prototype属性相信大家都知道，调用Javascript构造器创建一个对象后，新对象就会具有构造器原型的所有属性。通过这种方式，可以创建多个Car对象，并访问相同的原型。如下： 123456789101112131415function Car(model,year,miles)&#123; this.model=model; this.year=year; this.miles=miles;&#125;/*使用Object.prototype.newMethod而不是Object.prototype可以避免重新定义prototype对象*/Car.protoType.toString=function()&#123; return this.model+&quot;has done &quot;+this.miles+&quot;miles&quot;;&#125;;var civic=new Car(&quot;Honda Civic&quot;,2009,20000);var mondeo=new Car(&quot;Ford Mondeo&quot;,2010,5000);console.log(civic.toString());console.log(mondeo.toString()); 这样toString()的当以实例就能够在所有Car对象之间共享了^_^","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"Javascript 设计模式类别","date":"2016-01-10T07:16:11.000Z","path":"2016/01/10/2016-01-10-model-type/","text":"前言命名、抽象、标识是通用设计结构的主要方面，这些设计结构能被用于构造可复用的面向对象设计。设计模式确定所包含的类和实例、它们的角色、协作方式以及职责分配。 每一种设计模式都重点关注一个特定的对象设计问题或者设计要点，描述何时使用它，在另一些约束条件下是否还能使用，以及使用的效果和利弊。由于我们最终要实现设计，设计模式还是提供了示例，代码来阐明其实现。 虽然设计模式描述的是面向对象设计，但是他们都是基于实际的解决方案。这些设计方案的实现语言是主流面向对象的编程语言。 设计模式的分类创建型设计模式创建型设计模式专注于处理对象创建机制，以适合给定情况下的方式来创建对象，创建对象的基本方法都可能导致项目复杂性增加。而这些模式旨在通过控制创建过程来解决这类问题。 常见的创建型设计模式包括：Constructor构造器模式、Factory工厂模式、Abstract抽象模式、Prototype原型模式、Singleton单例模式和Builder生成器模式。 结构型设计模式结构型设计模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。同时对于不适合因某一特定目的而改变的系统部分，这种模式也可以帮助它们完成重组。 常见的结构型设计模式有：Decorator装饰者模式、Facade外观模式、Flyweight享元模式、Adapter适配器模式和Proxy代理模式。 行为型设计模式行为型设计模式专注于改善或简化系统中不同对象之间的通信。 行为模式包括：Iterator迭代器模式、Mediator中介者模式、Observer观察者模式、Visitor访问者模式。 ClassJavascript是一种无类语言，但可以用函数来模拟类，然后使用new关键字创建新的对象，使用this来定义对象的新属性和方法。 123456789function Car(model)&#123; this.model=model; this.color=&quot;silver&quot;; this.year=&quot;2012&quot;; this.getInfo=function()&#123; return this.model+&quot; &quot;+this.year; &#125;;&#125; 然后我们像这样我们使用上面定义的car构造函数来实例化该对象。123var myCar=new Car(&quot;ford&quot;);myCar.year=&quot;2010&quot;;console.log(myCar.getInfo()); 创建型模式 基于创建对象的概念 类 工厂方法基于接口数据或者生成几个派生类的一个实例 对象 抽象工厂创建若干类系列的一个实例，无需描述具体的的类 生成器从表示中分离对象构建；总是创建相同类型的对象 原型用于复制或者克隆完全初始化的实例 单例一个类在全局访问点只有唯一一个实例———- 结构型模式 基于构建对象块的想法 类 适配器匹配不同类的接口，因此可以在不兼容接口的情况下共同工作 对象 适配器匹配不同类的接口，因此可以在不兼容接口的情况下共同工作 桥接将对象接口从器实现中分离，因此它们可以独立进行变化 组合简单和复合对象的结构，使对象的总和不只是它们各部分的总和 装饰向对象动态添加备选的处理 外观隐藏整个子系统复杂性的唯一一个类 享元一个用于实现包含在别处信息的高效共享的细粒度实例代理占位符对象代表真正的对象 ———- 行为型模式 基于对象在一起配合工作的方式 类 解释器将语言元素包含在应用程序中的方法，以匹配预期语言的语法 模板方法在方法中创建算法的shell，然后将确切的步骤推到子类 对象 职责链在对象链之间传递请求的方法，以找到能够处理请求的对象 命令将命令执行从其调用程序中分离的方法 迭代器顺序访问一个集合中的元素，无需了解该集合内部的工作原理 中介者在类之间定义简化的通信，以防止一组类显式引用彼此 备忘录捕获对象的内部状态，已能够在以后恢复它 观察者向多个类通知改变的方式，以确保类之间的一致性状态状态改变时，更改对象的行为 策略在一个类中封装算法，将选择与实现分离 访问者向类添加一个新的操作，无需改变类","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"Javascript 反模式","date":"2016-01-10T07:12:41.000Z","path":"2016/01/10/2016-01-10-mod/","text":"什么是反模式如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。反模式这个术语是1995年由安德鲁·凯尼格在当年的11月C++报告中创造的，是受“四人组”所著《设计模式》一书的启发。在凯尼格的报告中，他提出反模式的两个概念：&gt;描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；描述如何摆脱前述的糟糕情况以及如何创造好的解决方案 反模式的由来每一个设计问题都是以在两个实体之间实现平衡为开始的，即：问题的形式和它的上下文。形式是解决问题的方案；上下文定义该问题。 虽然设计模式很重要，但是理解反模式也同样重要。创建应用程序时，一个项目的声明周期就会以此为起点；一旦完成了初始版本，就需要进行维护。最终方案的质量好坏取决于技能水平和团队投入时间。 当然这里的好坏是在上下文中考虑的，如果一个“完美的”设计模式应用于错误的上下文中，那么它也可能是一个反模式。应用程序在进入生产环境并即将进入维护模式时会面临更大的挑战。之前没有研究过该应用程序的开发人员，在这样的系统上工作，可能会将不良设计意外地引入到项目中，如果说将不良实践创建为反模式，则能让开发人员有办法提前识别这些反模式，这样可以避免常见错误的发生。 总结总的来说，反模式是一种值得记录的不良设计。Javascript中常见的反模式有很多，简单举几个例子： 在全局上下文中定义大量的变量污染全局命名空间。 向setTimeout或setInterval传递字符串，无意中触发eval( )的内部使用。 修改Object类的原型（这是一个特别不良的反模式） 以内联形式使用Javascript，它是不可改变的。 在使用document.createElement等原生DOM方法更适合的情况下使用document.write。多年来document.write一直都在被滥用，并有相当多的缺点，包括：如果在页面加载完成后执行document.write，它实际上会重写我们的页面，而documet.createElement则不会。 总之，了解反模式是成功的关键。一旦能够识别这种反模式，我们能重构代码来防止它们的出现，这样我们解决方案的总体质量就能立即得到改善。","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"认识JavaScript设计模式","date":"2016-01-10T07:10:49.000Z","path":"2016/01/10/2016-01-10-model/","text":"写在前面从来没有系统地研究过设计模式，之前领悟出来的JavaScript设计模式那纯粹是个人兴起之作，和主流的大家们整理的设计模式还是有不少差距的。这次有幸看到了一本很不错的书。作者归纳地真的很不错，赞叹之余，不忘摘录几段分享给大家。 编写易于维护的代码，其中一个重要方面是能够找到代码中重复出现的主题并优化他们，这就是设计模式有价值的地方。 什么是模式模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题。 &gt;模式是已经验证的解决方案模式很容易被复用模式富有表达力模式不是一种确切的解决方案，但可以为我们提供一个解决问题的方法 模式的优点复用模式有助于防止在应用程序开发工程中小问题引发大问题。这意味着当我们在已经验证的模式基础上编写代码时，可以在代码结构上少花点时间，从而有更多的时间专注于整体解决方案的质量。因为模式支持我们用更结构化和更富有组织性的方式编写代码，从而避免以后因为代码的整洁性问题而重构代码。 模式可以提供通用的解决的方案，并且其记录方式不需要与某个特定的问题挂钩。这种通用的方法意味着不管现在开发的是哪种应用程序（在许多情况下是指编程语言），设计模式都可以用于改进代码的结构。 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量通过鼓励开发人员更密切地关注解决方案中可以即刻减少代码复用的部分。例如，减少类似处理过程中的函数数量，用一个广义函数取而代之，那么久可以减少代码库的总体大小，也就是所谓使代码更简洁。 模式添加到开发人员的词汇中，会使得沟通更快速经常使用的模式可以逐步改进因为其他开发人员使用这些模式后总结出的共同经验又贡献给了设计模式社区。在某些情况下这回创造出全新的设计模式，而在其他的情况下，会对有关如何更好地使用特定模式的指导做出改进。这样可以确保基于模式的解决方案比临时解决方案更加强大。 @ 参考 《JavaScript设计模式》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://jafeney.com/tags/设计模式/"}]},{"title":"JavaScript内存回收机制","date":"2016-01-10T07:04:50.000Z","path":"2016/01/10/2016-01-10-js/","text":"写在前面JavaScript语言是一门优秀的脚本语言.其中包含脚本语言的灵活性外还拥有许多高级语言的特性.例如充许构建和实例化一个对象,垃圾回收机制(GC:Garbage Collecation).通常我们使用new创建对象,GC负责回收对象占用内存区域.因此了解GC,可以加深对JavaScript垃圾回收机制的理解。 认识GC用局部变量和全局变量解释GCGC在回收内存时,首先会判断该对象是否被其它对象引用.在确定没有其它对象引用便释放该对象内存区域.因此如何确定对象不再被引用是GC的关键所在. 1234567891011121314function aa()&#123; this.rr = &quot;弹窗&quot;;&#125;function bb()&#123; this.rr = &quot;弹窗&quot;;&#125;var b1;function cc()&#123; var a1 = new aa(); b1 = new bb(); return b1;&#125;cc();alert(b1.rr) 上面的代码中：执行完cc()后a1被回收了,此后我们可以通过b1.rr弹出文字窗口.在一些基础书籍中解释为:a1为局部变量,b1是全局变量.局部变量执行完后会被GC回收.但不全是这样,如下代码: 12345678910111213function aa()&#123; this.rr = &quot;弹窗&quot;;&#125;function bb()&#123; this.rr = &quot;弹窗&quot;;&#125;function cc()&#123; var a1 = new aa(); var b1 = new bb(); return b1;&#125;var b1 = cc();alert(b1.rr); 此时cc函数中的 a1,b1都是局部变量,但仍然会弹出文字窗口.说明b1并没有被GC回收.因此javascript中局部变量不是所有时候都被GC回收的. 抽象理解GCGC回收机制还需要近一步了解。在此时引入几个概念:双向链表,作用域链,活动对象(为了方便理解，简化了原文的概念[http://softbbs.pconline.com.cn/9497825.html]) , 其中双向链表描述复杂对象的上下层级关系. 作用域链与活动对象分别是双向链表中的某个节点.以函数cc为例变量层级关系为: 12window&lt;=&gt;cc&lt;=&gt;a1&lt;=&gt;rr &lt;=&gt;b1&lt;=&gt;rr 在执行cc()方法时，内存中变量的引用关系如上图,文字解释如下:window的活动对象包括cc,假设window是顶级对象(因为运行中不会被回收)，cc的活动对象包括a1和b1，其作用域链是window，a1的活动对象包括rr，其作用域链是cc，b1的活动对象包括rr，其作用域链是cc。 执行cc()时，cc的执行环境会创建一个活动对象和一个作用域链.其局部变量a1,b1都会挂在cc的活动对象中.当cc()执行完毕后，执行环境会尝试回收活动对象占用的内存.但因局部变量b1 通过return b1,为其增加了一条作用域链:window&lt;=&gt;b1&lt;=&gt;rr,所以GC停止对b1回收。 因此如果想将一个局部变量/函数提升为全局的，为其增加一条作用域链就OK了。同时控制好对象的作用域链也变得重要了.因作用域链会意外导致GC无法回收目标对象.例如:1234567891011121314151617181920212223242526//猫function cat(name)&#123; var zhuren ; this.name = name; //设置主人 this.addZhuRen = function(zr)&#123; zhuren = zr; &#125; this.getZhuRen = function()&#123; return zhuren; &#125;&#125;//主人function zhuren(name)&#123; this.name = name;&#125;//创建主人:var zr = new zhuren(&quot;zhangsan&quot;);//创建猫var cat1 = new cat(&quot;asan&quot;);//设置该猫的主人cat1.addZhuRen(zr);//释放主人zr = null ;//此处还存在对主人对象的引用alert(cat1.getZhuRen().name); 原理垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 举个例子：1234567891011function fn1() &#123; var obj = &#123;name: &apos;hanzichi&apos;, age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:&apos;hanzichi&apos;, age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); 我们来看代码是如何执行的。首先定义了两个function，分别叫做fn1和fn2，当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: ‘hanzichi’, age: 10}，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。 标记清除js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 12345function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境&#125;test(); //执行完毕 之后 a、b又被标离开环境，被回收。 垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。 123456function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1&#125; Netscape Navigator3是最早使用引用计数策略的浏览器，但很快它就遇到一个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。 1234567function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125;fn(); 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄露。在IE7与IE8上，内存直线上升。 我们知道，IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。 1234var element = document.getElementById(&quot;some_element&quot;);var myObject = new Object();myObject.e = element;element.o = myObject; 这个例子在一个DOM元素（element)与一个原生js对象（myObject)之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名为o回指myObject。由于存在这个循环引用，即使例子中的DOM从页面中移除，它也永远不会被回收。 看上面的例子，有同学回觉得太弱了，谁会做这样无聊的事情，其实我们是不是就在做： 1234window.onload=function outerFunction()&#123; var obj = document.getElementById(&quot;element&quot;); obj.onclick=function innerFunction()&#123;&#125;;&#125;; 这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)，document.getElementById(“element”) 的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽啊。 解决办法最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样： 12myObject.element = null;element.o = null; 12345window.onload=function outerFunction()&#123; var obj = document.getElementById(&quot;element&quot;); obj.onclick=function innerFunction()&#123;&#125;; obj=null;&#125;; 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。要注意的是，IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变 内存管理什么时候触发垃圾回收？垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6的垃圾回收是根据内存分配量运行的，当环境中存在256个变量、4096个对象、64k的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好吗？但是如果环境中就是有这么多变量等一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法儿玩儿了。 微软在IE7中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临街条件翻倍，如果回收的内存高于85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作提升了很多。 合理的GC方案1、Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），即： （1）遍历所有可访问的对象。 （2）回收已不可访问的对象。 2、GC的缺陷和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。 3、GC优化策略 David大叔主要介绍了2个优化方案，而这也是最主要的2个优化方案了： （1）分代回收（Generation GC） 这个和Java回收策略思想是一致的。目的是通过区分“临时”与“持久”对象；多回收“临时对象”区（young generation），少回收“持久对象”区（tenured generation），减少每次需遍历的对象，从而减少每次GC的耗时。如图： 这里需要补充的是：对于tenured generation对象，有额外的开销：把它从young generation迁移到tenured generation，另外，如果被引用了，那引用的指向也需要修改。 （2）增量GC 这个方案的思想很简单，就是“每次处理一点，下次再处理一点，如此类推”。 这种方案，虽然耗时短，但中断较多，带来了上下文切换频繁的问题。因为每种方案都其适用场景和缺点，因此在实际应用中，会根据实际情况选择方案。比如：低 (对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。 @参考：《javascript 内存回收机制理解》@参考：《跟我学习javascript的垃圾回收机制与内存管理》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"}]},{"title":"NodeJS中间层搭建——楔子","date":"2016-01-10T06:55:59.000Z","path":"2016/01/10/2016-01-10-node-middleware/","text":"前言最近碰了个壁，公司开发的一个新项目里我大胆地提出要前后端完全分离，用JavaScript模板引擎、ajax、路由等技术替代繁琐的前后端混合的业务逻辑，项目进行到一半前辈提出来仅仅靠前端的力量无法满足公司对SEO的要求。是放弃之前的工作重新改用后端velocity模板引擎来渲染页面，把工作重心转交给Java后端，还是坚持走全后端分离路线但是另辟一条蹊径呢？ 最后又来了个大胆的决定——用nodeJS搭一个中间层来渲染数据，弥补前端模板引擎和路由无法做到的SEO友好性工作。年轻就是任选，哈哈 ^_^ 前后端分离（参考淘宝）什么是前后端分离大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题： WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。 现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景： 前端：负责View和Controller层。 后端：只负责Model层，业务处理/数据等。 为什么要前后端分离现有开发模式的适用场景不同的开发模式各有各的适用场景，没有哪一种完全取代另外一种。 比如后端为主的MVC，做一些同步展现的业务效率很高，但是遇到同步异步结合的页面，与后端开发沟通起来就会比较麻烦。 Ajax为主SPA型开发模式，比较适合开发APP类型的场景，但是只适合做APP，因为SEO等问题不好解决，对于很多类型的系统，这种开发方式也过重。 前后端职责不清在业务逻辑复杂的系统里，我们最怕维护前后端混杂在一起的代码，因为没有约束，M-V-C每一层都可能出现别的层的代码，日积月累，完全没有维护性可言。虽然前后端分离没办法完全解决这种问题，但是可以大大缓解。因为从物理层次上保证了你不可能这么做。 开发效率问题电商网站Web基本上都是基于MVC框架webx，架构决定了前端只能依赖后端。所以我们的开发模式依然是，前端写好静态demo，后端翻译成VM模版，这种模式的问题就不说了，被吐槽了很久。 直接基于后端环境开发也很痛苦，配置安装使用都很麻烦。为了解决这个问题，我们发明了各种工具，比如VMarket，但是前端还是要写VM，而且依赖后端数据，效率依然不高。 另外，后端也没法摆脱对展现的强关注，从而专心于业务逻辑层的开发。 对前端发挥的局限性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作才能碰撞出火花，但由于后端框架限制，我们很难使用Comet、Bigpipe等技术方案来优化性能。 为了解决以上提到的一些问题，我们进行了很多尝试，开发了各种工具，但始终没有太多起色，主要是因为我们只能在后端给我们划分的那一小块空间去发挥。只有真正做到前后端分离，我们才能彻底解决以上问题。 怎么做前后端分离前端：负责View和Controller层。后端：负责Model层，业务处理/数据等。 试想一下，如果前端掌握了Controller，我们可以做url design，我们可以根据场景决定在服务端同步渲染，还是根据view层数据输出json数据，我们还可以根据表现层需求很容易的做Bigpipe,Comet,Socket等等，完全是需求决定使用方式。 基于NodeJS“全栈”式开发如果想实现上图的分层，就必然需要一种web服务帮我们实现以前后端做的事情，于是就有了标题提到的“基于NodeJS的全栈式开发” 这张图看起来简单而且很好理解，但没尝试过，会有很多疑问。 SPA模式中，后端已供了所需的数据接口，view前端已经可以控制，为什么要多加NodeJS这一层？ 多加一层，性能怎么样？ 多加一层，前端的工作量是不是增加了？ 多加一层就多一层风险，怎么破？ NodeJS什么都能做，为什么还要JAVA？ 这些问题要说清楚不容易，下面说下我的认识过程。 为什么要增加一层NodeJS？现阶段我们主要以后端MVC的模式进行开发，这种模式严重阻碍了前端开发效率，也让后端不能专注于业务开发。 解决方案是让前端能控制Controller层，但是如果在现有技术体系下很难做到，因为不可能让所有前端都学java，安装后端的开发环境，写VM。 NodeJS就能很好的解决这个问题，我们无需学习一门新的语言，就能做到以前开发帮我们做的事情，一切都显得那么自然。 性能问题分层就涉及每层之间的通讯，肯定会有一定的性能损耗。但是合理的分层能让职责清晰、也方便协作，会大大提高开发效率。分层带来的损失，一定能在其他方面的收益弥补回来。另外，一旦决定分层，我们可以通过优化通讯方式、通讯协议，尽可能把损耗降到最低。 举个例子：&gt;淘宝宝贝详情页静态化之后，还是有不少需要实时获取的信息，比如物流、促销等等，因为这些信息在不同业务系统中，所以需要前端发送5，6个异步请求来回填这些内容。有了NodeJS之后，前端可以在NodeJS中去代理这5个异步请求，还能很容易的做Bigpipe,这块的优化能让整个渲染效率提升很多。可能在PC上你觉得发5,6个异步请求也没什么，但是在无线端，在客户手机上建立一个HTTP请求开销很大，有了这个优化，性能一下提升好几倍。 前端的工作量是否增加了？相对于只切页面/做demo，肯定是增加了一点，但是当前模式下有联调、沟通环节，这个过程非常花时间，也容易出bug，还很难维护。 所以，虽然工作量会增加一点，但是总体开发效率会提升很多。 另外，测试成本可以节省很多。以前开发的接口都是针对表现层的，很难写测试用例。如果做了前后端分离，甚至测试都可以分开，一拨人专门测试接口，一拨人专注测试UI（这部分工作甚至可以用工具代替）。 增加Node层带来的风险怎么控制？随着Node大规模使用，系统/运维/安全部门的同学也一定会加入到基础建设中，他们会帮助我们去完善各个环节可能出现的问题，保障系的稳定性。 Node什么都能做，为什么还要JAVA？我们的初衷是做前后端分离，如果考虑这个问题就有点违背我们的初衷了。即使用Node替代Java，我们也没办法保证不出现今天遇到的种种问题，比如职责不清。我们的目的是分层开发，专业的人，专注做专业的事。基于JAVA的基础架构已经非常强大而且稳定，而且更适合做现在架构的事情。 淘宝基于Node的前后端分离 最上端是服务端，就是我们常说的后端。后端对于我们来说，就是一个接口的集合，服务端提供各种各样的接口供我们使用。因为有Node层，也不用局限是什么形式的服务。对于后端开发来说，他们只用关心业务代码的接口实现。 服务端下面是Node应用。 Node应用中有一层Model Proxy与服务端进行通讯。这一层主要目前是抹平我们对不同接口的调用方式，封装一些view层需要的Model。 Node层还能轻松实现原来vmcommon,tms（引用淘宝内容管理系统）等需求。 Node层要使用什么框架由开发者自己决定。不过推荐使用express+xTemplate的组合，xTemplate能做到前后端公用。 怎么用Node大家自己决定，但是令人兴奋的是，我们终于可以使用Node轻松实现我们想要的输出方式:JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。 浏览器层在我们这个架构中没有变化，也不希望因为引入Node改变你以前在浏览器中开发的认知。 引入Node，只是把本该就前端控制的部分交由前端掌控。 我们还需要要做什么？ 把Node的开发流程集成到淘宝现有的SCM流程中。 基础设施建设，比如session,logger等通用模块。 最佳开发实践 线上成功案例 大家对Node前后端分离概念的认识 安全 性能 技术上不会有太多需要去创新和研究的，已经有非常多现成的积累。其实关键是一些流程的打通和通用解决方案的积累，相信随着更多的项目实践，这块慢慢会变成一个稳定的流程。 总结基于node的全栈式开发模式淘宝是个很好的例子，技术开源，我们大可以充分借鉴它们成功的经验。好了，文字介绍大家看的可能不是很爽，最后留一个在线的幻灯片，也是来自淘宝的，感兴趣的可以看一看。 @ 幻灯片 《淘宝前后端分离实践》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"}]},{"title":"NodeJS中间层搭建——楔子","date":"2016-01-10T06:55:59.000Z","path":"2016/01/10/2016-01-10-express-middleware/","text":"前言最近碰了个壁，公司开发的一个新项目里我大胆地提出要前后端完全分离，用JavaScript模板引擎、ajax、路由等技术替代繁琐的前后端混合的业务逻辑，项目进行到一半前辈提出来仅仅靠前端的力量无法满足公司对SEO的要求。是放弃之前的工作重新改用后端velocity模板引擎来渲染页面，把工作重心转交给Java后端，还是坚持走全后端分离路线但是另辟一条蹊径呢？ 最后又来了个大胆的决定——用nodeJS搭一个中间层来渲染数据，弥补前端模板引擎和路由无法做到的SEO友好性工作。年轻就是任选，哈哈 ^_^ 前后端分离（参考淘宝）什么是前后端分离大家一致认同的前后端分离的例子就是SPA(Single-page application)，所有用到的展现数据都是后端通过异步接口(AJAX/JSONP)的方式提供的，前端只管展现。从某种意义上来说，SPA确实做到了前后端分离，但这种方式存在两个问题： WEB服务中，SPA类占的比例很少。很多场景下还有同步/同步+异步混合的模式，SPA不能作为一种通用的解决方案。 现阶段的SPA开发模式，接口通常是按照展现逻辑来提供的，有时候为了提高效率，后端会帮我们处理一些展现逻辑，这就意味着后端还是涉足了View层的工作，不是真正的前后端分离。 SPA式的前后端分离，是从物理层做区分（认为只要是客户端的就是前端，服务器端的就是后端），这种分法已经无法满足我们前后端分离的需求，我们认为从职责上划分才能满足目前我们的使用场景： 前端：负责View和Controller层。 后端：只负责Model层，业务处理/数据等。 为什么要前后端分离现有开发模式的适用场景不同的开发模式各有各的适用场景，没有哪一种完全取代另外一种。 比如后端为主的MVC，做一些同步展现的业务效率很高，但是遇到同步异步结合的页面，与后端开发沟通起来就会比较麻烦。 Ajax为主SPA型开发模式，比较适合开发APP类型的场景，但是只适合做APP，因为SEO等问题不好解决，对于很多类型的系统，这种开发方式也过重。 前后端职责不清在业务逻辑复杂的系统里，我们最怕维护前后端混杂在一起的代码，因为没有约束，M-V-C每一层都可能出现别的层的代码，日积月累，完全没有维护性可言。虽然前后端分离没办法完全解决这种问题，但是可以大大缓解。因为从物理层次上保证了你不可能这么做。 开发效率问题电商网站Web基本上都是基于MVC框架webx，架构决定了前端只能依赖后端。所以我们的开发模式依然是，前端写好静态demo，后端翻译成VM模版，这种模式的问题就不说了，被吐槽了很久。 直接基于后端环境开发也很痛苦，配置安装使用都很麻烦。为了解决这个问题，我们发明了各种工具，比如VMarket，但是前端还是要写VM，而且依赖后端数据，效率依然不高。 另外，后端也没法摆脱对展现的强关注，从而专心于业务逻辑层的开发。 对前端发挥的局限性能优化如果只在前端做空间非常有限，于是我们经常需要后端合作才能碰撞出火花，但由于后端框架限制，我们很难使用Comet、Bigpipe等技术方案来优化性能。 为了解决以上提到的一些问题，我们进行了很多尝试，开发了各种工具，但始终没有太多起色，主要是因为我们只能在后端给我们划分的那一小块空间去发挥。只有真正做到前后端分离，我们才能彻底解决以上问题。 怎么做前后端分离前端：负责View和Controller层。后端：负责Model层，业务处理/数据等。 试想一下，如果前端掌握了Controller，我们可以做url design，我们可以根据场景决定在服务端同步渲染，还是根据view层数据输出json数据，我们还可以根据表现层需求很容易的做Bigpipe,Comet,Socket等等，完全是需求决定使用方式。 基于NodeJS“全栈”式开发如果想实现上图的分层，就必然需要一种web服务帮我们实现以前后端做的事情，于是就有了标题提到的“基于NodeJS的全栈式开发” 这张图看起来简单而且很好理解，但没尝试过，会有很多疑问。 SPA模式中，后端已供了所需的数据接口，view前端已经可以控制，为什么要多加NodeJS这一层？ 多加一层，性能怎么样？ 多加一层，前端的工作量是不是增加了？ 多加一层就多一层风险，怎么破？ NodeJS什么都能做，为什么还要JAVA？ 这些问题要说清楚不容易，下面说下我的认识过程。 为什么要增加一层NodeJS？现阶段我们主要以后端MVC的模式进行开发，这种模式严重阻碍了前端开发效率，也让后端不能专注于业务开发。 解决方案是让前端能控制Controller层，但是如果在现有技术体系下很难做到，因为不可能让所有前端都学java，安装后端的开发环境，写VM。 NodeJS就能很好的解决这个问题，我们无需学习一门新的语言，就能做到以前开发帮我们做的事情，一切都显得那么自然。 性能问题分层就涉及每层之间的通讯，肯定会有一定的性能损耗。但是合理的分层能让职责清晰、也方便协作，会大大提高开发效率。分层带来的损失，一定能在其他方面的收益弥补回来。另外，一旦决定分层，我们可以通过优化通讯方式、通讯协议，尽可能把损耗降到最低。 举个例子：&gt;淘宝宝贝详情页静态化之后，还是有不少需要实时获取的信息，比如物流、促销等等，因为这些信息在不同业务系统中，所以需要前端发送5，6个异步请求来回填这些内容。有了NodeJS之后，前端可以在NodeJS中去代理这5个异步请求，还能很容易的做Bigpipe,这块的优化能让整个渲染效率提升很多。可能在PC上你觉得发5,6个异步请求也没什么，但是在无线端，在客户手机上建立一个HTTP请求开销很大，有了这个优化，性能一下提升好几倍。 前端的工作量是否增加了？相对于只切页面/做demo，肯定是增加了一点，但是当前模式下有联调、沟通环节，这个过程非常花时间，也容易出bug，还很难维护。 所以，虽然工作量会增加一点，但是总体开发效率会提升很多。 另外，测试成本可以节省很多。以前开发的接口都是针对表现层的，很难写测试用例。如果做了前后端分离，甚至测试都可以分开，一拨人专门测试接口，一拨人专注测试UI（这部分工作甚至可以用工具代替）。 增加Node层带来的风险怎么控制？随着Node大规模使用，系统/运维/安全部门的同学也一定会加入到基础建设中，他们会帮助我们去完善各个环节可能出现的问题，保障系的稳定性。 Node什么都能做，为什么还要JAVA？我们的初衷是做前后端分离，如果考虑这个问题就有点违背我们的初衷了。即使用Node替代Java，我们也没办法保证不出现今天遇到的种种问题，比如职责不清。我们的目的是分层开发，专业的人，专注做专业的事。基于JAVA的基础架构已经非常强大而且稳定，而且更适合做现在架构的事情。 淘宝基于Node的前后端分离 最上端是服务端，就是我们常说的后端。后端对于我们来说，就是一个接口的集合，服务端提供各种各样的接口供我们使用。因为有Node层，也不用局限是什么形式的服务。对于后端开发来说，他们只用关心业务代码的接口实现。 服务端下面是Node应用。 Node应用中有一层Model Proxy与服务端进行通讯。这一层主要目前是抹平我们对不同接口的调用方式，封装一些view层需要的Model。 Node层还能轻松实现原来vmcommon,tms（引用淘宝内容管理系统）等需求。 Node层要使用什么框架由开发者自己决定。不过推荐使用express+xTemplate的组合，xTemplate能做到前后端公用。 怎么用Node大家自己决定，但是令人兴奋的是，我们终于可以使用Node轻松实现我们想要的输出方式:JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。 浏览器层在我们这个架构中没有变化，也不希望因为引入Node改变你以前在浏览器中开发的认知。 引入Node，只是把本该就前端控制的部分交由前端掌控。 我们还需要要做什么？ 把Node的开发流程集成到淘宝现有的SCM流程中。 基础设施建设，比如session,logger等通用模块。 最佳开发实践 线上成功案例 大家对Node前后端分离概念的认识 安全 性能 技术上不会有太多需要去创新和研究的，已经有非常多现成的积累。其实关键是一些流程的打通和通用解决方案的积累，相信随着更多的项目实践，这块慢慢会变成一个稳定的流程。 总结基于node的全栈式开发模式淘宝是个很好的例子，技术开源，我们大可以充分借鉴它们成功的经验。好了，文字介绍大家看的可能不是很爽，最后留一个在线的幻灯片，也是来自淘宝的，感兴趣的可以看一看。 @ 幻灯片 《淘宝前后端分离实践》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"}]},{"title":"JavaScript call和apply的区别","date":"2016-01-10T06:53:32.000Z","path":"2016/01/10/2016-01-10-call/","text":"写在前面 很多来面试前端工程师的人说自己精通Javascript语言，问他call()和apply()这两个方法有什么区别，结果往往是一问三不知。 其实区分 apply和call就一句话：1foo.call(this,arg1,arg2,arg3)==foo.apply(thsi,arguments)==this.foo(arg1,arg2,arg3); 两者区别&gt;call 和 apply都属于Function.prototype的一个方法，它是Javascript引擎内在实现的，因为属于Function.prototype对象的实例，也就是每个方法都有call,apply属性，这两个方法很容易混淆，因为他们的作用一样，只是使用方式不同（传递的参数不同）。 不同点分析我们针对上面的foo.call(this,arg1,arg2,arg3)展开分析：&lt;br/&gt; foo 是一个方法，this是方法执行时上下文相关对象，永远指向当前代码所处在的对象中。arg1,arg2,arg3是传给foo方法的参数。 12345678910111213141516function A()&#123; var message=\"a\"; return&#123; getMessage:function()&#123;return this.message&#125; &#125;&#125;function B()&#123; var message=\"b\"; return&#123; setMessage:function(message)&#123;this.message=message&#125; &#125;&#125;var a=new A();var b=new B();b.setMessage.call(a,\"a的消息\");alert(a.getMessage()); //这里将输出“a的消息” 这就是动态语言Javascript call的威力所在，简直是无中生有，对象的方法可以任意指派，而对象本身是没有这个方法的。注意，指派通俗地讲就是把方法借给另一个对象调用，原理上时方法执行时上下文的对象改变了。 所以，b.setMessage.call(a,”a 的消息”);就等于用a做执行时上下文对象调用b对象的setMessage()方法，而这个过程与b一点关系都没有。作用等效于a.setMessage() 下面说一下apply的使用场景123456789101112function print(a,b,c,d)&#123; console.log(a+b+c+d);&#125;function example(a,b,c,d)&#123; //用call方式借用print，参数显式打散传递 print.call(this,a,b,c,d); //apply方式借用print，参数作为一个数组传递 print.apply(this,arguments); //或者这样写 print.apply(this,[a,b,c,d]);&#125;example('我','不','开','心'); 从上面的例子我们发现，call和apply方法除了第一个参数相同，call方法的其他参数一次传递给借用的方法做参数，而apply就两个参数，第二个参数是借用方法的参数组成的数组。 总结一下，当参数明确时可用call，当参数不明确时用apply并结合arguments","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://jafeney.com/tags/Javascript/"}]},{"title":"jQuery一些技巧总结","date":"2016-01-10T06:41:58.000Z","path":"2016/01/10/2016-01-10-jquery-q/","text":"写在前面这里总结了一些jQuery开发过程中的一些技巧，希望对大家有所帮助。 禁用页面的右击菜单12345$(function()&#123; $(document).on('contextmenu',function(e)&#123; return false; &#125;);&#125;); 新窗口打开页面123456789$(function()&#123; //例子1:href=\"http://\"的超链接将会在新窗口打开链接 $('a[href^=\"http://\"]').attr('target','_blank'); //例子2:rel=\"external\"的超链接将会在新窗口打开链接 $('#a[rel$=\"external\"]').on('click',function()&#123; this.target=\"_blank\"; &#125;);&#125;); 判断浏览器类型1234567891011121314151617181920212223242526$(function()&#123; //Firefox 2 and above if($.support.mozilla &amp;&amp; $.support.version&gt;='1.8')&#123; //do something &#125; //Safari if($.support.safari)&#123; //do something &#125; //Chrome if($.support.chrome)&#123; //do something &#125; //Opera if($.support.opera)&#123; //do something &#125; //IE6 and below if($.support.msie &amp;&amp; $.support.version&lt;=6)&#123; //do something &#125; //anything above IE6 if($.support.msie &amp;&amp; $.support.version&gt;6)&#123; //do something &#125;&#125;); 输入框文字获取和失去焦点1234567891011121314151617$(function()&#123; $('input.text1').val(\"Enter your search text here\"); textFill($('input.text1'));&#125;);//input focus text functionfunction textFill(input)&#123; var originalvalue=input.val(); input.focus(function()&#123; if($.trim(input.val())===originalvalue)&#123; input.val(); &#125; &#125;).blur(function()&#123; if($.trim(input.val()===''))&#123; input.val(originalvalue); &#125; &#125;);&#125; 返回头部滑动动画12345678910jQuery.fn.scrollTo=function(speed)&#123; var targetOffset=$(this).offset().top; $('html.body').stop().animate(&#123;scrollTop:targetOffset&#125;,speed); return this;&#125;// use$('#goheader').click(function()&#123; $('body').scrollTo(500); return false;&#125;); 获取鼠标位置12345$(document).ready(function()&#123; $(document).mousemove(function(e)&#123; $('#XY').html(\"X:\"+e.pageX+\" | Y:\"+e.pageY); &#125;);&#125;); 判断元素是否存在12345$(document).ready(function()&#123; if($('#id').length)&#123; //do something &#125;&#125;); 点击div也可以跳转123456$('div').click(function()&#123; window.location=$(this).find('a').attr('href'); return false;&#125;);// use&lt;div&gt;&lt;a href=\"#\"&gt;home&lt;/a&gt;&lt;/div&gt; 设置div在屏幕中央1234567891011$(document).ready(function()&#123; jQuery.fn.center=function()&#123; this.css(&#123; 'position':’absolute‘, 'top':($(window).height()-this.height())/2+$(window).scrollTop()+\"px\", 'left':($(window).width()-this.width())/2+$(window).scrollLeft()+\"px\" &#125;); &#125; //use $('#XY').center();&#125;); 根据浏览器的大小添加不同的样式12345678910$(function()&#123; function checkWindowSize()&#123; if($(window).width()&gt;1200)&#123; $('body').addClass('large'); &#125;else&#123; $('body').removeClass('large'); &#125; &#125; $(window).resize(checkWindowSize);&#125;); 创建自己的选择器12345678910$(function()&#123; $.extend($.expr[':'],&#123; moreThen500px:function(a)&#123; return $(a).width()&gt;500 &#125; &#125;); $('.box:moreThen500px').click(function()&#123; //... &#125;);&#125;); 关闭所有的动画效果123$(function()&#123; jQuery.fn.off=true;&#125;); 检测鼠标的右键还是左键12345$(function()&#123; $('#XY').mousedown(function(e)&#123; alert(e.which) //1:左键 2:中键 3:右键 &#125;);&#125;); 回车提交表单1234567$(function()&#123; $('input').keyup(function(e)&#123; if(e.which==='13')&#123; alert('回车提交！'); &#125; &#125;);&#125;); 设置全局Ajax参数12345678910$(function()&#123; $('#load').ajaxStart(function()&#123; showLoading(); //显示loading disableButtons(); //禁用按钮 &#125;); $('#load').ajaxComplete(function()&#123; hideLoading(); //隐藏 loading enableButtons(); //启用按钮 &#125;);&#125;); 获取选中的下拉框12$('#someElement').find('option:selected');$('#someElement option:selected'); 切换复选框12345var tog=false;$('button').click(function()&#123; $('input[type=checkbox]').attr('checked',!tog); tog=!tog;&#125;); 使用siblings()来选择同辈元素123456789//不这样做$('#nav li').click(function()&#123; $('#nav li').removeClass('active'); $(this).addClass('active');&#125;);//替代的做法$('#nav li').click(function()&#123; $(this).addClass('active').siblings().removeClass('active');&#125;); 在一段时间之后自动隐藏或者关闭元素1$('div').slideUp(300).delay(3000).fadeIn(400); 使用Firefox和Firebug来记录事件日志123456jQuery.log=jQuery.fn.log=function(msg)&#123; if(console)&#123; console.log('%s:%o',msg,this); &#125; return this;&#125; 为任何与选择器相匹配的元素绑定事件123$('table').on('click','td',function()&#123; $(this).toggleClass('hover');&#125;); 使用CSS钩子12345678910$.cssHooks['borderRadius']=&#123; get:function(elem,computed,extra)&#123; //depending on browser,read the value of -moz-,-webkit-,-o-... &#125; set:function(elem,value)&#123; //set the appropriate css3 property &#125;&#125;;//use$('#reset').css('borderRadius',5); $.proxy()的使用使用回调方法的缺点之一是当执行类库中的方法后，上下文对象this被设置到另外一个元素，而使用$.proxy()可以解决这个问题，代码如下：1234567$('#panel').fadeIn(function()&#123; //Using $.proxy: $('#panel button').click($.proxy(function()&#123; //this 指向 #panel $(this).fadeOut(); &#125;,this));&#125;); 限制Text-Area域中的字符个数123456789101112131415161718192021222324jQuery.fn.maxLength=function(max)&#123; this.each(function()&#123; var type=this.tagName.toLowerCase(); var inputType=this.type?this.type.toLowerCase():null; if(type===\"input\" &amp;&amp; inputType===\"text\" || inputType===\"password\")&#123; //应用标准的maxLength this.maxLength=max;e &#125;else if(type===\"textarea\")&#123; this.onkeypress=function(e)&#123; var ob=e||event; var keyCode=ob.keyCode; var hasSlection=document.selection?document.selection.createRange().text.length&gt;0:this.selectionStart!==this.selectionEnd; return !(this.value.length&gt;==max &amp;&amp; (keyCode&gt;50 || keyCode===32 || keyCode===0 || keyCode===13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSlection); &#125;; this.onkeyup=function()&#123; if(this.value.length&gt;max)&#123; this.value=this.value.substring(0,max); &#125; &#125;; &#125; &#125;);&#125;;//use$('#mytextarea').maxLength(10); 本地存储1localStorage.someData=\"This is going to be saved\"; 解析json数据时报parseError错误12345678910//1.4之前版本，key没引号，这样没问题&#123; key:\"123\", status:\"0\"&#125;//升级成jQuery1.4之后，都必须加上双引号，格式如下：&#123; \"key\":\"123\", \"status\":\"0\"&#125; 从元素中除去HTML1234567891011(function($)&#123; $.fn.stripHtml=function()&#123; var regExp=/&lt;(\"[^\"]*\"|'[^']*'|[^'\"&gt;])*&gt;/gi; this.each(function()&#123; $(this).html($(this).html().replace(regExp,'')); &#125;); return $(this); &#125;&#125;)(jQuery);//use$('div').stripHtml(); 拓展String对象的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$.extend(String.prototype,&#123; isPositiveInteger:function()&#123; return (new RegExp(/^[1-9]\\d/).test(this)); &#125;, isInteger:function()&#123; return (new RegExp(/^\\d+$/).test(this)); &#125;, isNumber:function(value,element)&#123; return (new RegExp(/^-?(?:\\d+|\\d&#123;1,3&#125;(?:,\\d&#123;3&#125;)+)(?:\\.\\d+)?$/).test(this)); &#125;, trim:function()&#123; return this.replace(/(^\\s*)|(\\s*$)|\\r|\\n/g,\"\"); &#125;, trans:function()&#123; return this.replace(/&amp;lt;/g,'&lt;').replace(/&amp;gt;/g,'&gt;').replace(/&amp;quot;/g,'\"'); &#125;, replaceAll:function(os,ns)&#123; return this.replace(new RegExp(os,\"gm\"),ns); &#125;, skipChar:function(ch)&#123; if(!this || this.length===0)&#123;return '';&#125; if(this.charAt(0)===ch)&#123;return this.substring(1).skipChar(ch);&#125; return this; &#125;, isValidPwd:function()&#123; return (new RegExp(/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/).test(this)); &#125;, isValidMail:function()&#123; return (new RegExp(/^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/).test(this.trim())); &#125;, isSpaces:function()&#123; for(var i=0,length=this.length;i&lt;length;i++)&#123; var ch=this.charAt(i); if(ch!=' ' &amp;&amp; ch!=\"\\n\" &amp;&amp; ch!=\"\\t\" &amp;&amp; ch!=\"\\r\")&#123; return false; &#125; return true; &#125; &#125;, isPhone:function()&#123; return (new RegExp(/(^([0-9]&#123;3,4&#125;[-])?\\d&#123;3,8&#125;(-\\d&#123;1,6&#125;)?$)|(^\\([0-9]&#123;3,4&#125;\\)\\d&#123;3,8&#125;(\\(\\d&#123;1,6&#125;\\))?$)|(^\\d&#123;3,8&#125;$)/).test(this)); &#125;, isUrl:function()&#123; return (new RegExp(/^[a-zA-Z]+:\\/\\/([a-zA-Z0-9\\-\\.]+)(-\\w .\\/?%&amp;=:]*)$/).test(this)); &#125;, isExternalUrl:function()&#123; return this.isUrl() &amp;&amp; this.indexOf(\"://\"+document.domain)===-1; &#125;&#125;);//use$('input').val().isInteger();","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jafeney.com/tags/jQuery/"}]},{"title":"jQuery性能优化常用策略","date":"2016-01-10T06:36:53.000Z","path":"2016/01/10/2016-01-10-model-jquery/","text":"写在前面如果你不会原生js，只会用jquery，那么你必须懂得jquery如何做性能优化。下面我总结了一些常用的，希望对大家有些帮助。 使用最新的jQuery类库使用合适的选择器 (1) 使用id来定位DOM元素是最高效的方式，如果不能直接用id找到你需要的元素，可以考虑用find()方法。(2) 标签选择器的性能也是不错的，它是性能优化的第二选择，因为jQuery将直接调用本地方法document.getElementByTagName()来定位DOM元素。(3) 对于类选择器，现代浏览器和IE9+ 支持本地方法document.getElementByClassName(),而对于老的浏览器如IE8 以及以前的版本，只能靠使用DOM 搜索方式来实现，这无疑对性能产生较大的影响，所以建议大家有选择性的使用它。(4) 属性选择器无法直接实现，大多都是使用DOM搜索方式来达到效果，很多现代浏览器支持querySelectorAll()方法，但是不同的浏览器的性能还是不一样的，总的来说，使用这种方式性能并不是非常理想。所以尽量避免使用这种有害性能的方式。(5) 伪类选择器也同样无法直接实现，jQuery需要搜索每一个元素来定位这个元素，这将是对性能造成较大的消耗，尽量不要使用，如果非用不可，就先用ID 选择器定位父元素，然后再使用该选择器。注意：尽量使用ID选择器，尽量给选择器指定上下文。 缓存对象 (1) 推荐使用jQuery的链式方式，这样可以最大程度上发挥缓存变量的优点，有效提高代码运行性能。(2) 如果一个jQuery对象被多次使用，那么可以把它们缓存到全局环境中。记住，永远不要让相同的选择器在大马里出现多次。 循环时的DOM操作使用jQuery可以很方便地添加、删除或者修改DOM节点，但是在一些循环，例如for()、while()或者$.each() 中处理节点时得值得注意，因为这样很消耗性能，最好的方式是 先把元素字符串全部创建好 再插入到DOM中去。 数组方式使用jQuery对象(1) 使用jQuery选择器获取结果是一个jQuery对象。然而jQuery类库回让你感觉你正在使用一个定义了索引和长度的数组。再性能方面，建议使用简单for和while循环来处理，而不是$.each()，这样能使你的代码更快。 12345678$.each(array,function(i)&#123; array[i]=i;&#125;);//替换为：var array=new Array();for(var i=0;i&lt;array.length;i++)&#123; array[i]=i;&#125; (2) 检查长度也是一个检查jQuery对象是否存在的方式，下面一段代码通过length属性检查页面中是否存在ID为“content”的元素：123456789var $content=$('#content');if($content)&#123; //总是true //Do something&#125;if($content.length)&#123; //拥有元素才返回true //Do something&#125; 事件代理 每一个javascript事件都会冒泡到父级节点。当我们需要给多个元素调用同个函数时这点会很有用。比如，我们要为一个表格绑定这样的行为：点击td后，把背景设置为红色，代码如下：123$('#myTable td').click(function()&#123; $(this).css('background','red');&#125;); 假定有100个td元素，在使用以上方式的时候，你绑定了100个事件，这将带来很负面的性能影响。更好的方式是：向它们的父级节点绑定一次事件，然后通过 event.target 获取到点击的当前元素，代码如下：1234$('#myTable').click(function(e)&#123; var $clicked=$(e.target); // e.target 捕捉到触发的目标元素 $clicked.css('background','red');&#125;); 在改进方式中，你只为一个元素绑定了一个事件。显然，这种方式的属性有优于之前那种，同时在1.7版本中提供了一个新的方式 on()，来帮助你将整个事件监听封装到一个便利方法中，如：123$('#myTable').on('click','td',function()&#123; $(this).css('background','red');&#125;); 将你的代码转换成jQuery插件 如果你的代码需要反复重用，有一种很优雅的写法就是转变成jQuery插件，格式如下：123456(function($)&#123; $.fn.yourPluginName=function()&#123; // your code goes here return this; &#125;&#125;)(jQuery); ##使用join()来拼接字符串## 也许你之前一直使用“＋”来拼接长字符串，现在你可以改改了。虽然它可能会是有点奇怪，但它确实有助于优化性能，尤其是长字符串处理的时候。首先创建一个数组，然后循环，最后使用join()把数组转化为字符串，代码如下：12345var array=[];for(var i=0;i&lt;=10000;i++)&#123; array[i]='&lt;li&gt;'+i+'&lt;/li&gt;';&#125;$('#list').html(array.join('')); 合理使用HTML5的Data属性 data()方法可以获取 data- 格式的 属性值。规则如下：1&lt;div id='d1' data-role='page' data-last-value='43' data-options='&#123;\"name\":\"John\"&#125;'&gt;&lt;/div&gt; 123$('#d1').data('role'); //\"page\"$('#d1').data('lastvalue'); //43$('#d1').data('options').name; //\"John\" 尽量使用原生的JavaScript方法 下面一段代码，它用来判断多选框是否被选中：1234567var $cr=$('#cr'); //jQuery对象$cr.on('click',function&#123; if($cr.is(\":checked\"))&#123; //jQuery方式判断 alert(\"感谢你的支持，你可以继续操作\"); &#125;&#125;); 以上方式可以直接用JavaScript方法来实现：12345678var $cr=$('#cr'); //jQuery对象var cr=$cr.get(0); //DOM对象，获取$cr[0]$cr.on('click',function()&#123; if(cr.checked)&#123; //原生的JavaScript方式判断 alert(\"感谢你的支持，你可以继续操作\"); &#125;&#125;); 毋庸置疑，第二种方式效率高于第一种方式，因为它不需要拐弯抹角的去调用许多函数。还有更多类似的操作，把如下代码：123456$(this).css('color','red');//优化成：this.style.color=\"red\";$('&lt;p&gt;&lt;/p&gt;');//优化成：$(document.createElement('p')); 压缩JavaScript","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jafeney.com/tags/jQuery/"}]},{"title":"封装一个简单的日历组件","date":"2016-01-10T06:30:05.000Z","path":"2016/01/10/2016-01-10-datepicker/","text":"写在前面 说到日历组件，网上一搜一大堆，各种插件啊、集成框架啊实在不少。但是插件有的不合需求，框架嘛依赖关系一大堆，比如jQueryUI、bootstrap等。其实现在我就是想要一个轻量级的日历组件，功能也不需要很强大，只要能兼容所有浏览器，能选择任意年份日期和星期就可以了。 &gt; 好了，废话不多说，直接上代码： 实现代码 好了，先引入jQuery库。（发表一下感概：angularJS的数据双向绑定着实让我对jQuery的未来担忧了一阵子，不过jQuery毕竟存在的时间很久，API文档和应用方面实在太广泛了 _ ，而且jQuery无可厚非是一款相当不错的DOM操作类库，至少我觉得段时间内这个地位无可动摇。所以大家还是大胆地用吧！） 1&lt;script type=\"text/javascript\" src=\"./js/jQuery.min.js\"&gt;&lt;/script&gt; 下面这个是还没压缩的js文件，纯手写哦 ^_^123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/* * jquery extend: dateField * author:jafeney * createTime:2015-8-28 （很久之前写的，拿出来炒下冷饭） */jQuery.fn.extend(&#123; dateField:function(options,callback)&#123; var self=this, _self=$(this), _eventType=options.eventType || 'click', _style=options.style || 'default', _parent=$(this).parent(), _nowDate=&#123; year:new Date().getFullYear(), month:new Date().getMonth()+1 &#125;, _switchState=0, _monthArray=['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月'], _daysArray=[31,28,31,30,31,30,31,31,30,31,30,31]; /*init*/ _self.on(_eventType,function()&#123; /*before use this extend,the '_self' must have a container*/ _self.parent().css('position','relative'); /*create element as dateField's container*/ var _container=$(\"&lt;div class='dateField-container'&gt;&lt;/div&gt;\"); var _header=$(\"&lt;div class='dateField-header'&gt;\" +\"&lt;div class='dateField-header-btns'&gt;\" +\"&lt;span class='btn dateField-header-btn-left'&gt;«&lt;/span&gt;\" +\"&lt;span class='btn dateField-header-datePicker'&gt;\"+_nowDate.year+\"年\"+_nowDate.month+\"月&lt;/span&gt;\" +\"&lt;span class='btn dateField-header-btn-right'&gt;»&lt;/span&gt;\" +\"&lt;/div&gt;\" +\"&lt;ul class='dateField-header-week'&gt;&lt;li&gt;日&lt;/li&gt;&lt;li&gt;一&lt;/li&gt;&lt;li&gt;二&lt;/li&gt;&lt;li&gt;三&lt;/li&gt;&lt;li&gt;四&lt;/li&gt;&lt;li&gt;五&lt;/li&gt;&lt;li&gt;六&lt;/li&gt;&lt;/ul&gt;\" +\"&lt;/div&gt;\"); var _body=$(\"&lt;div class='dateField-body'&gt;\"+self.getDays(_nowDate.year,_nowDate.month)+\"&lt;/div&gt;\"); var _footer=$(\"&lt;div class='dateField-footer'&gt;&lt;span class='btn dateField-footer-close'&gt;关闭&lt;/span&gt;&lt;/div&gt;\"); _container.append(_header).append(_body).append(_footer); _self.parent().append(_container); _self.parent().find('.dateField-container').show(); /*do callback*/ if(callback) callback(); &#125;); /*some functions*/ /*get any year and any month's days into a list*/ self.getDays=function(year,month)&#123; var _monthDay=self.getMonthDays(year,month); var _firstDay=new Date(year+'/'+month+'/'+'01').getDay(); //get this month's first day's weekday var returnStr=''; returnStr+=\"&lt;ul class='dateField-body-days'&gt;\"; for(var i=1;i&lt;=42;i++)&#123; if(i&lt;=_monthDay+_firstDay)&#123; if(i%7===0)&#123; returnStr+=\"&lt;li class='dateField-select select-day last'&gt;\"+self.filterDay(i-_firstDay)+\"&lt;/li&gt;\"; &#125;else&#123; returnStr+=\"&lt;li class='dateField-select select-day'&gt;\"+self.filterDay(i-_firstDay)+\"&lt;/li&gt;\"; &#125; &#125;else&#123; if(i%7===0)&#123; returnStr+=\"&lt;li class='dateField-select select-day last'&gt;&lt;/li&gt;\"; &#125;else&#123; returnStr+=\"&lt;li class='dateField-select select-day'&gt;&lt;/li&gt;\"; &#125; &#125; &#125; returnStr+=\"&lt;/ul&gt;\"; return returnStr; &#125; /*filter days*/ self.filterDay=function(day)&#123; if(day&lt;=0 || day&gt;31) &#123; return ''; &#125;else&#123; return day; &#125; &#125; /*judge any year is LeapYear*/ self.isLeapYear=function(year)&#123; var bolRet = false; if (0===year%4&amp;&amp;((year%100!==0)||(year%400===0))) &#123; bolRet = true; &#125; return bolRet; &#125; /*get any year and any month's full days*/ self.getMonthDays=function(year,month)&#123; var c=_daysArray[month-1]; if((month===2) &amp;&amp; self.isLeapYear(year)) c++; return c; &#125; /*get this year's months*/ self.getMonths=function()&#123; var returnStr=\"\"; returnStr=\"&lt;ul class='dateField-body-days dateField-body-months'&gt;\"; for(var i=0;i&lt;12;i++)&#123; if((i+1)%3===0)&#123; returnStr+=\"&lt;li class='dateField-select select-month last' data-month='\"+(i+1)+\"'&gt;\"+self.switchMonth(i)+\"&lt;/li&gt;\"; &#125;else&#123; returnStr+=\"&lt;li class='dateField-select select-month' data-month='\"+(i+1)+\"'&gt;\"+self.switchMonth(i)+\"&lt;/li&gt;\"; &#125; &#125; returnStr+='&lt;/ul&gt;'; return returnStr; &#125; /*get siblings 12 years*/ self.getYears=function(year)&#123; var returnStr=\"\"; returnStr=\"&lt;ul class='dateField-body-days dateField-body-years'&gt;\"; for(var i=0;i&lt;12;i++)&#123; if((i+1)%3===0)&#123; returnStr+=\"&lt;li class='dateField-select select-year last' data-year='\"+(year+i)+\"'&gt;\"+(year+i)+\"&lt;/li&gt;\"; &#125;else&#123; returnStr+=\"&lt;li class='dateField-select select-year' data-year='\"+(year+i)+\"'&gt;\"+(year+i)+\"&lt;/li&gt;\"; &#125; &#125; returnStr+='&lt;/ul&gt;'; return returnStr; &#125; /*formatDate*/ self.formatDate=function(date)&#123; if(date.length===1 || date&lt;10)&#123; return '0'+date; &#125;else&#123; return date; &#125; &#125; /*switch month number to chinese*/ self.switchMonth=function(number)&#123; return _monthArray[number]; &#125; /*go to prev*/ _parent.on('click','.dateField-header-btn-left',function()&#123; switch(_switchState)&#123; /*prev month*/ case 0: _nowDate.month--; if(_nowDate.month===0)&#123; _nowDate.year--; _nowDate.month=12; &#125; $(this).siblings('.dateField-header-datePicker').text(_nowDate.year+'年'+_nowDate.month+'月'); $(this).parent().siblings('ul').show(); $(this).parent().parent().siblings('.dateField-body').html(self.getDays(_nowDate.year,_nowDate.month)); break; /*next 12 years*/ case 2: _nowDate.year-=12; $(this).parent().parent().siblings('.dateField-body').html(self.getYears(_nowDate.year)); break; default: break; &#125; &#125;); /*go to next*/ _parent.on('click','.dateField-header-btn-right',function()&#123; switch(_switchState)&#123; /*next month*/ case 0: _nowDate.month++; if(_nowDate.month===13)&#123; _nowDate.year++; _nowDate.month=1; &#125; $(this).siblings('.dateField-header-datePicker').text(_nowDate.year+'年'+_nowDate.month+'月'); $(this).parent().siblings('ul').show(); $(this).parent().parent().siblings('.dateField-body').html(self.getDays(_nowDate.year,_nowDate.month)); break; /*next 12 years*/ case 2: _nowDate.year+=12; $(this).parent().parent().siblings('.dateField-body').html(self.getYears(_nowDate.year)); break; default: break; &#125; &#125;); /*switch choose year or month*/ _parent.on('click','.dateField-header-datePicker',function()&#123; switch(_switchState)&#123; case 0: /*switch month select*/ $(this).parent().siblings('ul').hide(); $(this).parent().parent().siblings('.dateField-body').html(self.getMonths()); _switchState=1; break; case 1: /*switch year select*/ $(this).parent().parent().siblings('.dateField-body').html(self.getYears(_nowDate.year)); _switchState=2; break; default: break; &#125; &#125;); /*select a year*/ _parent.on('click','.dateField-select.select-year',function()&#123; if($(this).text()!=='')&#123; $(this).parent().children('.dateField-select.select-year').removeClass('active'); $(this).addClass('active'); _nowDate.year=$(this).data('year'); $(this).parent().parent().siblings().find('.dateField-header-datePicker').text(_nowDate.year+'年'+_nowDate.month+'月'); $(this).parent().parent().parent().find('.dateField-header-week').hide(); $(this).parent().parent().html(self.getMonths()); _switchState=1; &#125; &#125;); /*select a month*/ _parent.on('click','.dateField-select.select-month',function()&#123; if($(this).text()!=='')&#123; $(this).parent().children('.dateField-select.select-month').removeClass('active'); $(this).addClass('active'); _nowDate.month=$(this).data('month'); $(this).parent().parent().siblings().find('.dateField-header-datePicker').text(_nowDate.year+'年'+_nowDate.month+'月'); $(this).parent().parent().parent().find('.dateField-header-week').show(); $(this).parent().parent().html(self.getDays(_nowDate.year,_nowDate.month)); _switchState=0; &#125; &#125;); /*select a day*/ _parent.on('click','.dateField-select.select-day',function()&#123; if($(this).text()!=='')&#123; var _day=$(this).text(); $(this).parent().children('.dateField-select.select-day').removeClass('active'); $(this).addClass('active'); var _selectedDate=_nowDate.year+'-'+self.formatDate(_nowDate.month)+'-'+self.formatDate(_day); _self.val(_selectedDate).attr('data-Date',_selectedDate); _self.parent().find('.dateField-container').remove(); /*template code： just for this page*/ $('#check-birthday').removeClass('fail').hide(); &#125; &#125;); /*close the dateFiled*/ /*click other field to close the dateField (outclick event)*/ $(document).on('click',function(e)&#123; var temp=$(e.target); if(temp.hasClass('dateField-container') || temp.hasClass('dateField-header-btn-left') || temp.hasClass('dateField-header-datePicker') || $(e.target).hasClass('dateField-header-btn-right') || $(e.target).hasClass('dateField-select') || $(e.target)[0].id===_self.attr('id'))&#123; ; &#125;else&#123; $('.dateField-container').remove(); _switchState=0; &#125; &#125;); return self; &#125;&#125;); 下面是我 写的简单的一套样式风格，有点模仿微信的风格。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/*dateField styles*//*reset*/ul,li&#123; list-style: none; padding:0; margin:0;&#125;/*default*/.dateField-container&#123; position:absolute; width:210px; border:1px solid rgb(229,229,229); z-index:99999; background:#fff; font-size:13px; margin-top:0px; cursor: pointer; display:none;&#125;.dateField-header&#123; width:212px; position:relative; left:-1px;&#125;.dateField-header-btns&#123; width:100%; height:30px; text-align:center; background:rgb(243,95,143);&#125;.btn&#123; user-select:none; -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;&#125;.dateField-header-btn-left&#123; float: left; display:block; width:30px; height:30px; color:#fff; line-height:30px;&#125;.dateField-header-btn-left:hover&#123; background:rgb(238,34,102);&#125;.dateField-header-datePicker&#123; display:inline-block; width:120px; text-align:center; color:#fff; line-height:30px;&#125;.dateField-header-datePicker:hover&#123; background:rgb(238,34,102);&#125;.dateField-header-btn-right&#123; float: right; width:30px; height:30px; display:block; color:#fff; line-height:30px;&#125;.dateField-header-btn-right:hover&#123; background:rgb(238,34,102);&#125;.dateField-header-week&#123; clear:both; width:100%; height:26px;&#125;.dateField-header-week li&#123; float: left; width:30px; height:30px; line-height:30px; text-align:center;&#125;.dateField-body&#123; width:100%;&#125;.dateField-body-days&#123; clear: both;&#125;.dateField-body-days li&#123; float: left; width:30px; height:30px; box-sizing:border-box; -webkit-box-sizing:border-box; -ms-box-sizing:border-box; -moz-box-sizing:border-box; border-top:1px solid rgb(229,229,229); border-right:1px solid rgb(229,229,229); line-height:30px; text-align:center;&#125;.dateField-body-days li:hover&#123; color:#fff; background:rgb(243,95,143);&#125;.dateField-body-days li.active&#123; color:#fff; background:rgb(243,95,143);&#125;.dateField-body-days li.last&#123; border-right:0;&#125;.dateField-footer&#123; border-top:1px solid rgb(229,229,229); clear:both; width:100%; height:26px; font-size:12px;&#125;.dateField-footer-close&#123; margin-top:2px; display:inline-block; width:100%; height:22px; background:rgb(245,245,245); text-align: center; line-height:22px;&#125;.dateField-footer-close:hover&#123; background:rgb(238,238,238);&#125;.dateField-select&#123; user-select:none; -webkit-user-select:none; -ms-user-select:none; -moz-user-select:none;&#125;.dateField-body-months&#123;&#125;.dateField-body-months li&#123; width:70px; height:35px; line-height:35px;&#125;.dateField-body-years li&#123; width:70px; height: 35px; line-height: 35px;&#125; 到了最关键的时刻，怎么使用呢？嘿嘿，就2行代码。 1234567891011121314&lt;!-- input group --&gt; &lt;div class=\"input-group\"&gt; &lt;input type=\"text\" id=\"input-date\" class=\"input-text\"&gt; &lt;/div&gt; &lt;!--end input group--&gt;&lt;script type=\"text/javascript\"&gt; ;$(function()&#123; $('#input-date').dateField(&#123; eventType:'click', style:'default' &#125;) &#125;); &lt;/script&gt; 好吧，我承认我很装逼，故意写一大堆英文注释。不过因为需求，还是出现了汉字 ＊_＊ 感兴趣的同学可以 到我的gitHub上clone一份吧 ^_^我的地址 https://github.com/Jafeney/dateField ，欢迎star我，哈哈","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jafeney.com/tags/jQuery/"}]},{"title":"Javascript调用Android方法","date":"2016-01-10T06:25:40.000Z","path":"2016/01/10/2016-01-10-webview/","text":"前言目前流行原生App和H5进行混合开发，提高开发速度。IOS和JS进行通信比较麻烦，但Android对这种交互进行了很好的封装、我们可以很简单的用Java代码调用WebView中的js函数、也可以用WebView中的js来调用Android应用中的Java代码。 网页的JS代码调用Android中Java代码的方法在网页中调用java代码、需要在webview控件中添加javascriptInterface1234contentWebView = (WebView) findViewById(R.id.webview);//启用javascriptcontentWebView.getSettings().setJavaScriptEnabled(true);contentWebView.addJavascriptInterface(this, &quot;js对象名&quot;); 在Activity中定义一个要被js调用的方法、src为js传递过来的参数、如果没有不传也可以的哈 123456789public void jsFunction(final String str) &#123; Toast.makeText(this, str, Toast.LENGTH_SHORT).show(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //在里对Android应用的UI进行处理 &#125; &#125;);&#125; 在网页中、只需要像调用js方法一样、进行调用就可以。 Android中Java代码调用网页的JS代码的方法Java代码调用js并传参其实是通过WebView的loadUrl方法去调用的、只是参数url的写法不一样而已 1234// 无参数调用contentWebView.loadUrl(&quot;javascript:javacalljs()&quot;);// 传递参数调用contentWebView.loadUrl(&quot;javascript:javacalljswithargs(&quot;+ &quot;´hello world´&quot; + &quot;)&quot;); Java和JS交互注意事项&gt;1 Java 调用 js 里面的函数、效率并不是很高、估计要200ms左右吧、做交互性很强的事情、这种速度很难让人接受、而js去调Java的方法、速度很快、50ms左右、所以尽量用js调用Java方法2、Java 调用 js 的函数、没有返回值、调用了就控制不到了3、Js 调用 Java 的方法、返回值如果是字符串、你会发现这个字符串是 native 的、转成 locale 的才能正常使用、使用 toLocaleString() 函数就可以了、不过这个函数的速度并不快、转化的字符串如果很多、将会很耗费时间4、网页中尽量不要使用jQuery、执行起来需要5-6秒、最好使用原生的js写业务脚本、以提升加载速度、改善用户体验 @ 参考 DD博客 ANDROID JS 交互","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"webApp","slug":"webApp","permalink":"http://jafeney.com/tags/webApp/"}]},{"title":"从jQuery到AngularJS，再到React，前端必须走在最前端","date":"2016-01-10T06:10:59.000Z","path":"2016/01/10/2016-01-10-latest/","text":"前言最近 很认真地在学习AngularJS，正准备在项目中实践，却不小心地知道了React，根据我师傅说的 React相比AngularJS对DOM的操作思想又是不一样的，React的虚拟文档对象模型(DOM)和拼接机制很有可能是新的一种趋势。这让我很忧郁啊 _ ，就像以前初学JavaScript的时候，jQuery的编程思想让我耳目一新，于是没有深入学JavaScript而是花了很长一段时间去研究jQuery，接着在熟练掌握了jQuery之后又被AngularJS给洗脑。而现在呢，AngularJS还没有使地很6，又要去学React吗？前端的新技术兴起速度快得出乎你的想象。唉，没办法。“沉舟侧畔千帆过，病树前头万木春”，学技术的，总是要不断地“抛弃”原有的技术，去研究新的技术。 简单分析一下三者的区别jQueryjQuery不能跟AngularJS、 ReactJS归到同一类，因为JQ只是一个库，其他两个才算是重框架；毕竟是“先入为主”，jQuery 存在的时间最早，各种插件、组件、UI库多的根本数不清。也正是因为跟“大白菜”一样的逻辑，jQuery的学习和应用都非常容易，所以很适合初学者使用。 AngularJSAngularJS 这个框架比较重且兼容性一般般，比起jquery1.xIE全兼容，这货只能兼容IE8及以上（对于IE8以下版本，使用ng IE补丁插件毕竟是费力不讨好的事情），但无可否认它是能明显提高前端开发效率的工具。它比较适合做前端后台管理界面、或ERP类web app（例如：worktile就是用ng实现）。有一点必须承认，AngularJS最吸引人的是它的编程思想，它把很多后端的思想比如“依赖注入、指令”应用到前端，这使得它的门槛变得有点高，所以初学者不建议直接去学习AngularJS（因为你根本不会用，哈哈）。 ReactJSReact是脸谱开发的一种JavaScript框架，它的唯一目标就是构建高性能的用户接口。开发React就是为了解决其他JavaScript框架都未能解决的一个问题-高效地渲染大型数据集。它采用了虚拟文档对象模型(DOM)和拼接机制，这样，每一次对网页做了更改后，React就只更新与更改相关的部分，而不需要重新对整个站点进行渲染。 最为最近很火的一个前端解决方案，这货一开始只是Facebook 内部使用的UI库（类似bootstrap），后来慢慢发展成一整套前后端通吃的 Web App 解决方案（野心很大，让现在的Hybrid 之流怎么活？估计之前facebook HTML5大跃进失败了，想要用它继续完成三端同步的梦想），所以这框架适合Web移动开发。（据说ReactJS项目组能调用android ios一些不为人知的接口，从而显著提高android ios原生项目效率）目前使用react在实际应用中，必须使用其扩展插件，而使用了插件的reactjs的确算是重框架React 的大小和 Angular 相当，但 Angular 是一个完整的应用框架。React 显而易见的臃肿，但是你只获得了很少的功能。 重点分析AngularJS和React通常认为Angular是一种“固执己见”的框架。意思就是AngularJS的开发者认为一个“好的”应用前端架构就应改像AngularJS这样，他们也在AngularJS的核心也采用的是这样的架构。因此，当你的应用满足上面所说的限制的话，Angular就运行的非常良好。然而，如果你发现你的应用框架构与Angular所期望的架构相差很大，那么你会感觉到非常痛苦。相比之下，React并不打算给你提供一个适合你编码的理想架构。它让你减少要装载的组件，降低装载时间，让你更加自由地管理数据的表现形式。 模版Angular的指令（Directive）用于数据驱动显示，通过它来编写显示模版相当容易，这是使用Angular的一大好处。当你为数据构建UI时，使用Angular是非常直接的。对于数据展现而言，只要放弃对某些环节的控制，你就能以一种更直观的方式，给用户界面带来更少的代码以及“显而易见”的感觉。然而，React趋向于由你提供自定义函数来驱动数据的展现。这通常意味着，在数据被通过代码融入DOM前，你得自己定义你的数据将如何被展现。这使得在尝试决定某个元素具体该如何被渲染时，逻辑上会出现一定的断层。 性能虽然Angular的数据的表达能够非常紧凑, 但是渲染大型数据集依旧被证明是一个痛点. 由于双向数据绑定需要监听每一个可变元素, 数据量变大就会带来显著的性能问题. React, 在另一方面, 使用虚拟DOM来跟踪元素的变化. 当检测到变化时, React会构建一个针对DOM变化的补丁, 然后应用这些补丁. 由于不必在每个元素每次变化时重新渲染整个巨大的table, React相对于其他JavaScript框架有显著的性能提升. 应用架构AngularJS和React还有一个不同点在于它们所选择的架构. 最初AngularJS使用了MVC(模型-视图-控制器)模式构建, 然后逐渐演化成了MVVM(模型-视图-视图模型)-MVC混合架构. React却是另一方面, 它的关注点只在MVC模型的”V”上 – 它被设计用来展现数据, 而将其他方面交由应用架构中编程人员选择的其他组件负责. 有一件值得注意的有趣的事是, 由于这样的架构选型, AngularJS的某些棘手的组件完全可以通过React来增强. 结论 Angular 和 React 相同的是 Model Driven View 的套路, 自动维护 View, 减少手工状态维护.把两者都当作是对 Backbone MVP 模式的改进的话, 上边这一点差不多的.不同的地方是 React 采用的方案有点像函数式的做法, Component, Immutable data 等等更着重于将 DOM 封装可以相互组合的 Component, 并且将 DOM 操作抽象为状态的改变.这样抽象之后, 学习和编写复杂应用的成本降下来很多React 的问题主要在它实现功能近似与 jQuery 的 DOM 操作和事件监听,要写完整的应用需要 MVC, 对 React 来说就是后来发布的 Flux 模型,而 Flux 并不是完整的一个框架, 只是 Facebook 发布的一套架构体系所以要写完整的大应用估计还有不少坑要淌过去.. 在这方面 Angular 东西多多了. 在为你的应用选择JavaScript框架时，要考虑每个框架的优势和劣势，这需要对相关的知识有深入的了解。正如上文所述，如果应用时常要处理大量的动态数据集，并以相对简便和高性能的方式对大型数据表进行显示和变更，React是相当不错的选择。但是React不像AngularJS那样包含完整的功能，举例来说，React没有负责数据展现的控制器（Controller）层。总而言之，在AngularJS和React之间做出选择意味着回答一个看似简单的问题：为了解决应用潜在的性能问题，是否值得你去花精力学习和使用React？或者说，是否可能将React的组件（Component）在AngularJS中实现（当然这样会使得架构整体变得冗余）[译者注：AngularJS中的指令和React的组件扮演着类似的角色]？要回答这个问题并不容易，你要根据具体的应用场景来做出决定。 @ 参考 http://blog.backand.com/angularjs-vs-react/@ 参考 http://www.zhihu.com/question/31079930/answer/51500640","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jafeney.com/tags/react/"}]},{"title":"封装一个简单的模态组件","date":"2016-01-10T05:40:05.000Z","path":"2016/01/10/2016-01-10-modal/","text":"前言最近在翻新7月份一个项目的代码，确实感觉现在的水平提升了不止一个档次啊^_ ^，之前花了一个近1500行代码完成的交互效果，现在几百行就搞定，而且不依赖三方的UI组件。我现在的编码有自己的设计模式，像模态这些通用的功能我习惯整理在util模块里，其他模块里如果需要调用new一个对象即可。今天不介绍整个util模块的代码，就拎一个模态组件和大家分享一下，如果觉得不错 就拿去用吧。真的很不建议为了实现一个简单的功能去网上下一个重量级的UI组件，而且还不好维护，倒不如自己手写一个。 演示一下效果myAlert 细心的同学会发现 这个alert是没有关闭按钮的，为什么呢？因为它是定时关闭的，而且结合淡入淡出的动画体验效果会很好哦。 myConfirm 这个就比较常见了，不过这种样式我还是很喜欢的，简洁美，有没有 ^ _ ^ 上代码吧css样式css样式就70行，大可以直接注释一下打包到你的base.css里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*模态窗口*/.myMask&#123; position: fixed; width: 100%; height: 100%; z-index: 9999; background: rgba(0,0,0,0.4); background: rgb(0,0,0)\\9; filter:alpha(opacity=0.4)\\9; top: 0; display: none;&#125;.hide&#123; display: none;&#125;.modal&#123; position: absolute; top: 30%; left: 0; right: 0; margin:auto; z-index: 10000; width: 360px; height: 120px; background:#fff;&#125;.modal.myConfirm&#123; height: 150px;&#125;.modal&gt;h2&#123; text-align: left; background: rgb(238,34,102); color: #fff; height: 40px; line-height: 40px; padding-left: 20px; font-size: 13px;&#125;.modal&gt;p&#123; padding: 10px 20px; padding-top: 20px; padding-left:25px; font-size: 13px; color: #777;&#125;.confirmBtns&#123; position: absolute; bottom: 0; height: 40px; font-size: 0; width: 100%; border-top: 1px solid #eee;&#125;.confirmBtns&gt;a&#123; display: inline-block; vertical-align: top; font-size: 12px; width: 50%; height: 100%; text-align: center; color: #888; line-height: 40px; box-sizing:border-box; -webkit-box-sizing:border-box;&#125;.confirmBtns&gt;a:hover&#123; background-color:rgb(255,251,237); color: #666;&#125;.confirmBtns&gt;a.first&#123; border-right: 1px solid #eee;&#125; JavaScript代码定义组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * [通用工具模块] * @param &#123;[type]&#125; $ [JQuery对象] * @param &#123;[type]&#125; self [单例上下文] * @return &#123;[type]&#125; [公开方法] */Module_util:function($,self)&#123; var _wraper=$(&apos;#wrap&apos;),//内容容器 return&#123; /** * [myAlert description] * @param &#123;[type]&#125; $txt [description] * @return &#123;[type]&#125; [description] */ myAlert:function($txt)&#123; /*创建DOM结构*/ _wraper.append(&apos;&lt;div class=&quot;myMask&quot; id=&quot;myMask&quot;&gt;&lt;/div&gt;&apos;); $(&apos;#myMask&apos;).html(&apos;&lt;div id=&quot;myAlert&quot; class=&quot;modal myAlert hide&quot;&gt;&lt;h2 id=&quot;alertTitle&quot;&gt;温馨提示&lt;/h2&gt;&lt;p&gt;哎呀*_*，您&lt;span id=&quot;alertTxt&quot;&gt;&apos;+$txt+&apos;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&apos;); /*绑定功能*/ $(&apos;#myMask&apos;).fadeIn(); $(&apos;#myAlert&apos;).show(); /*延迟800ms后关闭并销毁DOM*/ window.setTimeout(function()&#123; $(&apos;#myMask&apos;).fadeOut(); $(&apos;#myAlert&apos;).remove(); $(&apos;#myMask&apos;).remove(); &#125;,800); &#125;, /** * [myConfirm 确认框组件] * @param &#123;[type]&#125; $title [确认框标题] * @param &#123;[type]&#125; $txt [确认的内容] * @param &#123;[type]&#125; $sureCallback [确定的回调函数] * @param &#123;[type]&#125; $cancelCallback [取消的回到函数] * @return &#123;[type]&#125; [void] */ myConfirm:function($title,$txt,$sureCallback,$cancelCallback)&#123; /*创建DOM结构*/ _wraper.append(&apos;&lt;div class=&quot;myMask&quot; id=&quot;myMask&quot;&gt;&lt;/div&gt;&apos;); $(&apos;#myMask&apos;).html(&apos;&lt;div id=&quot;myConfirm&quot; class=&quot;modal myConfirm hide&quot;&gt;&lt;h2 id=&quot;confirmTitle&quot;&gt;&apos;+$title+&apos;&lt;/h2&gt;&lt;p&gt;您确定要&lt;span id=&quot;confirmTxt&quot;&gt;&apos;+$txt+&apos;&lt;/span&gt; ?&lt;/p&gt;&lt;div class=&quot;confirmBtns&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot; id=&quot;confirmYes&quot; class=&quot;first&quot;&gt;确定&lt;/a&gt;&lt;a href=&quot;javascript:void(0)&quot; id=&quot;confirmNo&quot;&gt;取消&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&apos;); /*绑定功能*/ $(&apos;#myMask&apos;).fadeIn(); $(&apos;#myConfirm&apos;).show(); /*确认回调*/ $(&apos;#confirmYes&apos;).on(&apos;click&apos;,function()&#123; if($sureCallback)&#123; $sureCallback(); $(&apos;#myMask&apos;).fadeOut(); $(&apos;#myConfirm&apos;).remove(); $(&apos;#myMask&apos;).remove(); &#125; &#125;); /*取消回调*/ $(&apos;#confirmNo&apos;).on(&apos;click&apos;,function()&#123; if($cancelCallback)&#123; $cancelCallback(); $(&apos;#myMask&apos;).fadeOut(); $(&apos;#myConfirm&apos;).remove(); $(&apos;#myMask&apos;).remove(); &#125; &#125;); &#125; &#125;&#125; 如何调用12345678910111213141516171819202122232425262728293031323334353637/** * [操作模块] * @param &#123;[type]&#125; $ [JQuery对象] * @param &#123;[type]&#125; self [单例上下文] * @return &#123;[type]&#125; [公开方法] */Module_operate:function($,self)&#123; var util=new self.Module_util($,self); /** * [deleteSome 批量删除] * @return &#123;[type]&#125; [description] */ function deleteSome()&#123; artWrap.on(&apos;click&apos;,&apos;#btn-selectd-delete&apos;,function()&#123; var selectArray=$(&apos;.shop-product-item.checked&apos;); if(selectArray.length===0)&#123; util.myAlert(&apos;请先选择要删除的商品&apos;); &#125;else&#123; util.myConfirm(&apos;删除提示&apos;,&apos;删除这些商品吗&apos;,function()&#123; selectArray.remove(); shopCheckProduct(); countTotal(); &#125;,function()&#123; return false; &#125;); &#125; &#125;); &#125; return&#123; /*对外暴露的模块初始化接口*/ init:&#123; /*加载批量删除功能*/ deleteSome(); //........ &#125; &#125;&#125; 好了，上面只是代码的片段，如果看不懂可以出门右转往前翻我的那篇《我的JavaScript设计模式》的文章，或者给我留言，我会尽快回复 ＾＿＾","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jafeney.com/tags/jQuery/"}]},{"title":"NodeJS开发简单的爬虫程序","date":"2016-01-10T05:32:03.000Z","path":"2016/01/10/2016-01-10-node-spider/","text":"写在前面经常说SEO却从来没有写过爬虫，今天很有幸看到了关于nodeJS的爬虫程序的实现，模仿着写了个demo，权当砖头抛给大家了。 程序架构因为是基于nodeJS，我们所需准备的架构很简单，用express4.x生成一个项目，然后再安装request和cheerio模块就可以。项目的package.json是这样的： 123456789101112131415161718192021&#123; &quot;name&quot;: &quot;spider&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;body-parser&quot;: &quot;~1.13.2&quot;, &quot;cookie-parser&quot;: &quot;~1.3.5&quot;, &quot;debug&quot;: &quot;~2.2.0&quot;, &quot;express&quot;: &quot;~4.13.1&quot;, &quot;jade&quot;: &quot;~1.11.0&quot;, &quot;morgan&quot;: &quot;~1.6.1&quot;, &quot;serve-favicon&quot;: &quot;~2.3.0&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;cheerio&quot;: &quot;^0.19.0&quot;, &quot;request&quot;: &quot;^2.67.0&quot; &#125;&#125; 当然你也可以直接 copy这个package.json到你自己的项目里，然后 npm install 就可以了。 cheerior模块介绍 用最简单的一句话概括 —— ”cheerior是运行在node服务端的jQuery“，也就是说 cheerior可以像jQuery一样提供简单的API去操纵DOM树。 它的API和jQuery操纵DOM的ＡＰＩ基本一致，如果你想更深入地学习ｃｈｅｅｒｉｏｒ，不妨去看看它在ｎｐｍ的官网的标准API文档：https://www.npmjs.com/package/cheerio 。不过是英文版的哦，如果觉得看不太懂，这里还有个中文精简版的：https://cnodejs.org/topic/5203a71844e76d216a727d2e 抓取网站的源码安装完所有的node_modules，我们就可以开始我们的抓取之旅了。当然在抓取之前我必须声明：不是每个网站的所有信息都可以爬，我们必须遵循robots协议，否则可能会涉及到法律问题。 举个例子，比如京东的robots文件： Disallow的东西你是不能爬的，如果你去篡改这个文件那京东就可以告你侵权了。 下面再举个实际的例子，这是我抓取我们八爱网首页的一些信息，代码很简单： app.js (为了方便我改了原本的app.js)1234567891011121314151617181920212223242526var express=require(&apos;express&apos;);var request=require(&apos;request&apos;);var cheerio=require(&apos;cheerio&apos;);var app=express();app.get(&apos;/&apos;,function(req,res)&#123; res.charset=&apos;utf-8&apos;; request(&apos;http://www.baai.com/&apos;,function(err,response,body)&#123; if(!err &amp;&amp; response.statusCode==200)&#123; $=cheerio.load(body); //当前$相当于整个body的选择器 var proInfos=$(&apos;.pro-info&gt;h4&apos;); var imgs=$(&apos;.pro-img&gt;img&apos;); var imgsTemp=[],proInfosTemp=[]; for(var i=0,len=imgs.length;i&lt;len;i++)&#123; imgsTemp.push(imgs.eq(i).attr(&apos;data-original&apos;)); proInfosTemp.push(proInfos.eq(i).html()); &#125; res.json(&#123; &apos;productImage&apos;:imgsTemp, &apos;proInfosName&apos;:proInfosTemp &#125;); &#125; &#125;);&#125;);app.listen(3000); 接下来用 supervisor 启动这个node服务，对supervisor有疑问的同学欢迎出门左转翻一翻我前一篇【实践】express搭建nodeJS中间层（三），那里有比较详细的介绍。 好了，成功启动之后控制台可以看到这样的信息： 接下来我们打开浏览器，输入 127.0.0.1:3000 ，就启动这个爬虫程序了，抓取到的数据是这样的： 后话今天就先写个简单的demo吧，感兴趣的同学可以继续研究 如何抓取 ajax 返回的内容。","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://jafeney.com/tags/NodeJS/"}]},{"title":"用路由为webApp提供多入口","date":"2016-01-10T05:24:47.000Z","path":"2016/01/10/2016-01-10-webapp/","text":"写在前言我1个月前开发的webApp是个单入口的单页应用，那个时候需求没有很复杂，仅仅是一个购物的站点，但后来不停地添加功能，而且近期还提出需要把webAPP的部分页面分享到 IOS webView、微信朋友圈，并且能完成完整的业务逻辑。 我的策略拆模块，分多页这个需求下来，我第一反应是“拆”——把单页的webAPP根据模块拆分成多页，以一个新的html页面的形式提供给iOS和微信端。这么做的好处很明显： 思路简单，不需要很复杂的js架构 可以利用浏览器的历史记录来做返回跳转，避免了原先的靠判断状态码来实现 返回 更简便且易维护。 以模块拆分页面，方便团队开发和维护。 此法虽好，但是不太适合眼前的情况： 放弃单页的思路，那么之前的架构就得重新整合，这会是一个大工程，因为现有的代码光js已经超过了4500行，公司追求速度，不太情愿花过多的时间在架构上。 放弃单页的思路，那么对模块化的要求就变得更高，单页内资源共享的优势就荡然无存，需要花费不少时间去封装原有的模块，单一职责，充分解耦。这又是一个时间投入比较大的工作，公司又不情愿了。 如何在有限的时间里 把这个问题解决呢？我 最后想来想去，觉得 可以参考 AngularJS里 路由 的思路。 换路由，多入口之前做项目架构的时候我还没来得及学习AngularJS，所以在设计上有不少的“笨思路”，没有很好地站在巨人的肩膀上去思考问题。唉，好在现在已经意识到这一点了，以后做每件事都不应该“闭门造车”，而且多参考一些成功的案例，借鉴别人成功的经验，少走弯路才好。 路由的好处： 以url作为页面跳转的媒介，这样的思路可能和 原先的 状态码 类似，但是状态码是只能 通过JS内部调用，无法外部操作，而url则不然，不仅可以外部操作，多口入进入，而且对SEO友好性上 也提升了一些。 改用路由的方式，原先的很多模块不用做太多的改动，仅仅是 controller层的 状态码 写入需要做相应的改动。 这样就节省了 “大手术”的开发成本和风险。 可能方法没有好坏之分，只有适合不适合当前的现状吧。伟人云“黑猫白猫能抓到老鼠的就是好猫”，这一理论在小公司特别明显。没办法，我们的项目需求变动地很快，老板要求的时间也很紧张，没有很多的时间让我去学习和思考技术的好坏，只要能快速地出成果就OK。这样的现状使得小公司出来的技术人才在技术理论层面或者深度上会不及大公司的同类人才，但是论项目经验和碰壁的次数也是没的比的。在这个公司，作为前端的我，不仅要把前端的工作 做好，PS、Linux、PHP、Java方面的问题都要接触不少。而我们的原则就是“既然碰壁，那就努力把它碰穿”，无论什么问题，解决就可以了！ 既然目前的趋势是“大前端”，那我并不觉得小公司出来的人才在能力上会比大公司出来的差，还是要看一个人的品质和他努力的程度的，我始终相信成功靠坚持，一个人肯在一个领域里不停地摸索滚爬，那么终有一天能成为该领域的领军人物的。 具体实施get方式做路由get方式的url参数传递是比较好理解的，而且取值操作也很容易，重要的是这样的参数方式不会对页面产生任何影响。123456789101112function queryString()&#123; var url = location.search; var theRequest = new Object(); if (url.indexOf(&quot;?&quot;) != -1) &#123; var str = url.substr(1); strs = str.split(&quot;&amp;&quot;); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(&quot;=&quot;)[0]]=unescape(strs[i].split(&quot;=&quot;)[1]); &#125; &#125; return theRequest;&#125; 当然，仅仅针多webAPP这种单页应用来说，没有所谓的get方式提交表单的问题，因为所有的数据都是通过ajax异步加载和渲染的。但是从长远的角度考虑，这样的方式有点“越界”的意思，get方式的初衷是数据请求，现在却用它做路由总感觉职责不明，是不是有很好的方式呢？ 哈希方式的路由大家知道 html里有个 锚点链接 的概念吧，通过 #锚点名来实现页面内部的跳转。这个其实就是最原始的哈希方式的路由了，不过仅仅是用于页面内部，而单页应用也是一个页面，内部的其他页面是通过js控制显示和隐藏的，这使得 哈希方式的路由思路上十分自然。 当然，借鉴ThinkPHP、springMVC、express等框架对路由的设计，我们可以把我们的路由搞得更高大上些：12345678910111213141516171819202122232425262728293031323334353637383940414243var app= &#123;&#125;;app.Router = function()&#123; function Router()&#123; &#125; Router.prototype.setup = function(routemap, defaultFunc)&#123; var that = this, rule, func; this.routemap = []; this.defaultFunc = defaultFunc; for (var rule in routemap) &#123; if (!routemap.hasOwnProperty(rule)) continue; that.routemap.push(&#123; rule: new RegExp(rule, &apos;i&apos;), func: routemap[rule] &#125;); &#125; &#125;; Router.prototype.start = function()&#123; console.log(window.location.hash); var hash = location.hash, route, matchResult; for (var routeIndex in this.routemap)&#123; route = this.routemap[routeIndex]; matchResult = hash.match(route.rule); if (matchResult)&#123; route.func.apply(window, matchResult.slice(1)); return; &#125; &#125; this.defaultFunc(); &#125;; return Router;&#125;();var router = new app.Router();router.setup(&#123; &apos;#/list/(.*)/(.*)&apos;: function(cate, id)&#123; console.log(&apos;list&apos;, cate, id); &#125;, &apos;#/show/(.*)&apos;: function(id)&#123; console.log(&apos;show&apos;, id); &#125;&#125;, function()&#123; console.log(&apos;default router&apos;);&#125;);router.start(); 在线实例 @ 实例在线演示地址：http://webapp.baai.com/basic/router/index.html html结构： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;js实现简单的路由&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;开启路由功能&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot; id=&quot;open-page1&quot;&gt;打开第一个页面&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot; id=&quot;open-page2&quot;&gt;打开第二个页面&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0)&quot; id=&quot;open-page3&quot;&gt;打开第三个页面&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page1&quot; class=&quot;bg1&quot;&gt;这里是页面一&lt;/div&gt; &lt;div id=&quot;page2&quot; class=&quot;bg2&quot;&gt;这里是页面二&lt;/div&gt; &lt;div id=&quot;page3&quot; class=&quot;bg3&quot;&gt;这里是页面三&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./router.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; css结构： 1234567891011121314151617181920212223242526body&#123; text-align: center; font-size: 12px; color: #555; font-family: &apos;微软雅黑&apos;; padding-top: 30px;&#125;li&#123; margin-top: 10px;&#125;div&#123; width: 800px; height: 600px; display: none; margin: 20px auto; padding-top: 20px;&#125;div.bg1&#123; background: rgba(238,34,102,0.5);&#125;div.bg2&#123; background: #f0f0f0;&#125;div.bg3&#123; background: rgba(0,145,230,0.5);&#125; js结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$(function()&#123; var app = &#123;&#125;; app.Router = function()&#123; function Router()&#123; &#125; Router.prototype.setup = function(routemap, defaultFunc)&#123; var that = this, rule, func; this.routemap = []; this.defaultFunc = defaultFunc; for (var rule in routemap) &#123; if (!routemap.hasOwnProperty(rule)) continue; that.routemap.push(&#123; rule: new RegExp(rule, &apos;i&apos;), func: routemap[rule] &#125;); &#125; &#125;; Router.prototype.start = function()&#123; var hash = location.hash, route, matchResult; for (var routeIndex in this.routemap)&#123; route = this.routemap[routeIndex]; matchResult = hash.match(route.rule); if (matchResult)&#123; route.func.apply(window, matchResult.slice(1)); return; &#125; &#125; this.defaultFunc(); &#125;; return Router; &#125;(); var router = new app.Router(); router.setup(&#123; &apos;#/list/(.*)/(.*)&apos;: function(cate, id)&#123; console.log(&apos;list&apos;, cate, id); &#125;, &apos;#/show/(.*)&apos;: function(id)&#123; console.log(&apos;show&apos;+id); $(&apos;div&apos;).hide(); $(&apos;#&apos;+id).show(); &#125; &#125;, function()&#123; console.log(&apos;default router&apos;); &#125;); app.operate=(function()&#123; var btns=[$(&apos;#open-page1&apos;),$(&apos;#open-page2&apos;),$(&apos;#open-page3&apos;)]; $.each(btns,function(idx,item)&#123; var pageIdx=idx+1; item.on(&apos;click&apos;,function()&#123; var oldUrl=location.href.split(&apos;#&apos;)[0]; location.replace(oldUrl+&quot;#/show/page&quot;+pageIdx); router.start(); &#125;); &#125;); &#125;)();&#125;);","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://jafeney.com/categories/移动开发/"}],"tags":[{"name":"webApp","slug":"webApp","permalink":"http://jafeney.com/tags/webApp/"}]},{"title":"前端模块化两兄弟——requireJS和seaJS","date":"2016-01-10T04:05:11.000Z","path":"2016/01/10/2016-01-10-module/","text":"写在前面之前没学过nodeJS，底子不好，对AMD和CMD的实现没法理解，现在nodeJS也算是步入门槛，再回过身好好研究一下这个“模块化加载器”。 SeaJS与RequireJS最大的区别 一言以蔽之：执行模块的机制大不一样 RequireJS 是执行的 AMD 规范, 所有的依赖模块都是先执行，当然 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。这点和常规的nodeJS风格很像，模块编写前把所有用到的依赖模块率先在头部注入进来，然后需要调用的时候就可以直接拿来用。后端语言大多是这个编码思路，比较好接受。而SeaJS对模块的态度是懒执行（ As lazy as possible），这样有四个好处： &gt;1、防止对象被提前创建（内存优化，如加载plist文件等耗内存的操作）2、防止对象重复创建 （永远只加载一次）3、防止对象使用时,还没被创建4、可以在懒加载方法里面,进行初始化操作 举个简单的例子：1234567891011121314151617// CMD define(function(require, exports, module) &#123; var a = require(&apos;./a&apos;) a.doSomething() // 此处略去 100 行 var b = require(&apos;./b&apos;) // 依赖可以就近书写 b.doSomething() // ... &#125;) // AMD 默认推荐的是 define([&apos;./a&apos;, &apos;./b&apos;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ... &#125;) 注意，上面也提到了requireJS也支持CMD写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。 此外，AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 豆瓣一个有名的帖子如下模块分别通过SeaJS/RequireJS来加载：1234567891011121314define(function(require, exports, module) &#123; console.log(&apos;require module: main&apos;); var mod1 = require(&apos;./mod1&apos;); mod1.hello(); var mod2 = require(&apos;./mod2&apos;); mod2.hello(); return &#123; hello: function() &#123; console.log(&apos;hello main&apos;); &#125; &#125;; &#125;); SeaJS的执行结果 123456require module: mainrequire module: mod1hello mod1require module: mod2hello mod2hello main RequireJS执行结果123456require module: mod1require module: mod2require module: mainhello mod1hello mod2hello main 小结SeaJS只会在真正需要使用(依赖)模块时才执行该模块，SeaJS是异步加载模块的没错, 但执行模块的顺序也是严格按照模块在代码中出现(require)的顺序, 这样也许更符合逻辑。 RequireJS会先尽早地执行(依赖)模块, 相当于所有的require都被提前了, 而且模块执行的顺序也不一定100%就是先mod1再mod2 。因此你看到执行顺序和你预想的完全不一样。 注意这里说的是执行(真正运行define中的代码)模块, 而非加载(load文件)模块。模块的加载都是并行的, 没有区别，区别在于执行模块的时机，或者说是解析。 阻塞问题SeaJS的懒执行 RequireJS的预执行 小结可以很明显的看出RequireJS的做法是并行加载所有依赖的模块, 并完成解析后, 再开始执行其他代码, 因此执行结果只会”停顿”1次, 完成整个过程是会比SeaJS要快. 而SeaJS一样是并行加载所有依赖的模块, 但不会立即执行模块, 等到真正需要(require)的时候才开始解析, 这里耗费了时间, 因为这个特例中的模块巨大, 因此造成”停顿”2次的现象, 这就是我所说的SeaJS中的”懒执行”. 总结jockchou 的看法我个人感觉requirejs更科学，所有依赖的模块要先执行好。如果A模块依赖B。当执行A中的某个操doSomething()后，再去依赖执行B模块require(‘B’);如果B模块出错了，doSomething的操作如何回滚？很多语言中的import, include, useing都是先将导入的类或者模块执行好。如果被导入的模块都有问题，有错误，执行当前模块有何意义？ 总之载入的所有模块，都是当前要使用的，为什么要动态的去执行？这个问题可以总结为模块的载入执行是静态还是动态。如果是动态执行的话，那页面的程序执行过程会受到当前模块执行的影响。而正如楼主所言，动态执行总体时间上是比静态一次执行要慢的。 楼主说requirejs是坑，是因为你还不太理解AMD“异步模块”的定义，被依赖的模块必须先于当前模块执行，而没有依赖关系的模块，可以没有先后。在楼主的例子中，假设mod1和mod2某天发生了依赖的话，比如在某个版本，mod1依赖了mod2（这是完全有可能的），这个时候seajs的懒执行会不会有问题？而requirejs是不会有问题，也不需要修改当前模块。 在javascript这个天生异步的语言中，却把模块懒执行，这让人很不理解。想像一下factory是个模块工厂吧，而依赖dependencies是工厂的原材料，在工厂进行生产的时候，是先把原材料一次性都在它自己的工厂里加工好，还是把原材料的工厂搬到当前的factory来什么时候需要，什么时候加工，哪个整体时间效率更高？显然是requirejs，requirejs是加载即可用的。为了响应用户的某个操作，当前工厂正在进行生产，当发现需要某种原材料的时候，突然要停止生产，去启动原材料加工，这不是让当前工厂非常焦燥吗？暂且不去理会这个吧，等ECMA规范中加入了模块化的定义后，再看谁更合理吧。 玉伯 的观点原文链接：https://www.zhihu.com/question/20342350/answer/14828786 RequireJS 和 SeaJS 都是很不错的模块加载器，两者区别如下：1、两者定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端 2、两者遵循的标准有差异。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者 API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。 3、两者社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，而采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。 4、两者代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。 5、两者对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便便捷。RequireJS 无这方面的支持。 6、两者的插件机制有差异。RequireJS 采取的是在源码中预留接口的形式，源码中留有为插件而写的代码。SeaJS 采取的插件机制则与 Node 的方式一致：开放自身，让插件开发者可直接访问或修改，从而非常灵活，可以实现各种类型的插件。还有不少细节差异就不多说了。 总之，SeaJS 从 API 到实现，都比 RequireJS 更简洁优雅。如果说 RequireJS 是 Prototype 类库的话，则 SeaJS 是 jQuery 类库。最后，向 RequireJS 致敬！RequireJS 和 SeaJS 是好兄弟，一起努力推广模块化开发思想，这才是最重要的。 个人之见AMD速度和效率比CMD快，虽然可能会存在不必要的内存开销，但是对于小项目来说，这些开销是可以忽略不计的，因为现在的硬件设备提升的速度很快，而且如果你早已养成良好的编码习惯，这些差异是肉眼无法捕捉到的，而且AMD思想比较符合常规的编程逻辑，更容易让前端工程师接受，学习成本低。 CMD的好处上面也讲了不少了，而且作为国产大头，我对它的发展还是很看好的，模块的单一职责和延迟加载特性使得代码变得优雅、容易维护。对于复杂的前端项目（如webApp），我还是会倾向于seaJS，它的编程思想更令我喜爱，奔着早日进军阿里的信念，很值得花时间去研读 seaJS的源码，去领悟这门框架的精髓，走近开发这门框架的牛人们的世界。 还是那句话，思想没有好坏之分，只有适不适合你的项目开发。 @参考 《LABjs、RequireJS、SeaJS 哪个最好用？为什么？》","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jafeney.com/tags/模块化/"}]},{"title":"CommonJS规范和实现","date":"2016-01-10T04:02:27.000Z","path":"2016/01/10/2016-01-10-common/","text":"写在前面 一言以蔽：CommonJS是服务器端模块的规范，Node.js采用了这个规范。 commonJS简介根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。 举个例子 example.js 12345678console.log(&quot;evaluating example.js&quot;);var invisible = function () &#123; console.log(&quot;invisible&quot;);&#125;exports.message = &quot;hi&quot;;exports.say = function () &#123; console.log(message);&#125; 我们可以通过 require 加载这个模块1var example = require(&apos;./example.js&apos;); 这时，变量example就对应模块中的exports对象，于是就可以通过这个变量，使用模块提供的各个方法。1234&#123; message: &quot;hi&quot;, say: [Function]&#125; require方法默认读取js文件，所以可以省略js后缀名。 1var example = require(&apos;./example&apos;); 注意 js文件名前面需要加上路径，可以是相对路径（相对于使用require方法的文件），也可以是绝对路径。如果省略路径，node.js会认为，你要加载一个核心模块，或者已经安装在本地 node_modules 目录中的模块。如果加载的是一个目录，node.js会首先寻找该目录中的 package.json 文件，加载该文件 main 属性提到的模块，否则就寻找该目录下的 index.js 文件。 【例】最简单的模块模块 addition.js1exports.do = function(a, b)&#123; return a + b &#125;; 上面的语句定义了一个加法模块，做法就是在exports对象上定义一个do方法，那就是供外部调用的方法。使用的时候，只要用require函数调用即可。12var add = require(&apos;./addition&apos;);add.do(1,2); // 输出3 【例】稍复杂些的例子模块 foobar.js 123456789function foobar()&#123; this.foo = function()&#123; console.log(&apos;Hello foo&apos;); &#125; this.bar = function()&#123; console.log(&apos;Hello bar&apos;); &#125;&#125;exports.foobar = foobar; 调用该模块的方法如下： 123var foobar = require(&apos;./foobar&apos;).foobar, test = new foobar();test.bar(); // 输出 &apos;Hello bar&apos; 有时，不需要exports返回一个对象，只需要它返回一个函数。这时，就要写成module.exports 123module.exports = function () &#123; console.log(&quot;hello world&quot;)&#125; AMD规范与CommonJS规范的兼容性 CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 AMD规范使用define方法定义模块（最典型的就是requireJS了）12345678define([&apos;package/lib&apos;], function(lib)&#123; function foo()&#123; lib.log(&apos;hello world!&apos;); &#125; return &#123; foo: foo &#125;;&#125;); 当然，AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： 123456789101112define(function( require, exports, module ) var someModule = require( &quot;someModule&quot; ); var anotherModule = require( &quot;anotherModule&quot; ); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function() &#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;;&#125;); Package.json定义根据commonJS规范，每个nodeJS模块都必须有个package.json文件，也方便分享到npm社区。 name必须字段，在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。name是这个东西的名字。注意：1、不要把node或者js放在名字中。因为你写了package.json它就被假定成为了js，不过你可以用”engine”字段指定一个引擎（见后文）。2、这个名字会作为在URL的一部分、命令行的参数或者文件夹的名字。任何non-url-safe的字符都是不能用的。3、这个名字可能会作为参数被传入require()，所以它应该比较短，但也要意义清晰。4、在取名字之前，你最好去 npm registry 查看一下这个名字是否已经被使用了。 version必须字段，在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。 version必须能被 node-semver解析，它被包在npm的依赖中。（要自己用可以执行npm install semver） description可选字段，模块描述，必须是字符串。npm search的时候会用到。 keywords可选字段，放简介，字符串。方便屌丝们在 npm search中搜索。 homepage可选字段，项目官网的url。 注意 这和“url”不一样。如果你放一个“url”字段，registry会以为是一个跳转到你发布在其他地方的地址，然后喊你滚粗。 嗯，滚粗，没开玩笑。 bugs可选字段，你项目的提交问题的url和（或）邮件地址。这对遇到问题的屌丝很有帮助。差不多长这样：1234&#123; &quot;url&quot; : &quot;http://github.com/owner/project/issues&quot;, &quot;email&quot; : &quot;project@hostname.com&quot;&#125; 你可以指定一个或者指定两个。如果你只想提供一个url，那就不用对象了，字符串就行。如果提供了url，它会被npm bugs命令使用。 License可选字段，你应该要指定一个许可证，让人知道使用的权利和限制的。最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：1&#123; &quot;license&quot; : &quot;BSD&quot; &#125; 如果你有更复杂的许可条件，或者想要提供给更多地细节，可以这样: 12345&quot;licenses&quot; : [ &#123; &quot;type&quot; : &quot;MyLicense&quot; , &quot;url&quot; : &quot;http://github.com/owner/project/path/to/license&quot; &#125;] 在根目录中提供一个许可证文件也蛮好的。 people fields: author, contributors都是可选字段。author是一个人。contributors是一堆人的数组。person是一个有name字段，可选的有url、email字段的对象，像这样：12345&#123; &quot;name&quot; : &quot;Barney Rubble&quot;, &quot;email&quot; : &quot;b@rubble.com&quot;, &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;&#125; 或者可以把所有的东西都放到一个字符串里，npm会给你解析：1&quot;Barney Rubble &lt;b@rubble.com&gt; (http://barnyrubble.tumblr.com/) email和url在两种形式中都是可选的。也可以在你的npm用户信息中设置一个顶级的maintainers字段。 Files可选字段，files是一个包含项目中的文件的数组。如果命名了一个文件夹，那也会包含文件夹中的文件。（除非被其他条件忽略了）你也可以提供一个.npmignore文件，让即使被包含在files字段中得文件被留下。其实就像 .gitignore一样。 main可选字段。main字段配置一个文件名指向模块的入口程序。如果你包的名字叫foo，然后用require(“foo”)，main配置的模块的exports对象会被返回。这应该是一个相对于根目录的文件路径。对于大多数模块，它是非常有意义的，其他的都没啥。 bin可选字段。很多的包都会有执行文件需要安装到PATH中去。这个字段对应的是一个Map，每个元素对应一个{ 命令名：文件名 }。1&#123; &quot;bin&quot; : &#123; &quot;npm&quot; : &quot;./cli.js&quot; &#125; &#125; directories用于指示包的目录结构 directories.lib指示库文件的位置。 directories.bin和前面的bin是一样的，但如果前面已经有bin，那么这个就无效。除了以上两个，还有Directories.doc&amp; Directories.man &amp; Directories.example。 repository可选字段。用于指示代码存放的位置。1234567891011&quot;repository&quot; : &#123; &quot;type&quot; : &quot;git&quot;, &quot;url&quot; : &quot;http://github.com/npm/npm.git&quot; &#125;&quot;repository&quot; : &#123; &quot;type&quot; : &quot;svn&quot;, &quot;url&quot; : &quot;http://v8.googlecode.com/svn/trunk/&quot; &#125; scripts可选字段，object。Key是生命周期事件名，value是在事件点要跑的命令。参考npm-scripts。 config可选字段，object。Config对象中的值在Scripts的整个周期中皆可用，专门用于给Scripts提供配置参数。 dependencies可选字段，指示当前包所依赖的其他包。1234567891011121314&#123; &quot;dependencies&quot; :&#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;, &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot;, &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot;, &quot;boo&quot; : &quot;2.0.1&quot;, &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot;, &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;, &quot;til&quot; : &quot;~1.2&quot;, &quot;elf&quot; : &quot;~1.2.3&quot;, &quot;two&quot; : &quot;2.x&quot;, &quot;thr&quot; : &quot;3.3.x&quot;, &#125;&#125; 版本格式可以是下面任一种： 1234567891011121314151617181920212223242526272829version 完全匹配&gt;version 大于这个版本&gt;=version大于或等于这个版本&lt;version&lt;=version~version 非常接近这个版本^version 与当前版本兼容1.2.x X代表任意数字，因此1.2.1, 1.2.3等都可以http://... Unix系统下使用的tarball的URL。* 任何版本都可以&quot;&quot;任何版本都可以version1 - version2 等价于 &gt;=version1 &lt;=version2.range1 || range2 满足任意一个即可git... Git地址user/repo devDependencies可选字段。如果只需要下载使用某些模块，而不下载这些模块的测试和文档框架，放在这个下面比较不错。 peerDependencies可选字段。兼容性依赖。如果你的包是插件，适合这种方式。 bundledDependencies可选字段。发布包时同时打包的其他依赖。 optionalDependencies可选字段。如果你想在某些依赖即使没有找到，或则安装失败的情况下，npm都继续执行。那么这些依赖适合放在这里。 engines可选字段。既可以指定node版本：1&#123; &quot;engines&quot; : &#123;&quot;node&quot; : &quot;&gt;=0.10.3 &lt;0.12&quot; &#125; &#125; 也可以指定npm版本：1&#123; &quot;engines&quot; : &#123;&quot;npm&quot; : &quot;~1.0.20&quot; &#125; &#125; engineStrick可选字段，布尔值。如果你肯定你的程序只能在制定的engine上运行，设置为true。 os可选字段。指定模块可以在什么操作系统上运行：12&quot;os&quot; : [ &quot;darwin&quot;,&quot;linux&quot; ]&quot;os&quot; : [ &quot;!win32&quot; ] cpu可选字段。指定CPU型号。12&quot;cpu&quot; : [ &quot;x64&quot;,&quot;ia32&quot; ]&quot;cpu&quot; : [ &quot;!arm&quot;,&quot;!mips&quot; ] preferGlobal可选字段，布尔值。如果你的包是个命令行应用程序，需要全局安装，就可以设为true。 private可选字段，布尔值。如果private为true，npm会拒绝发布。这可以防止私有repositories不小心被发布出去。 publishConfig可选字段。发布时使用的配置值放这。 默认值1&quot;scripts&quot;:&#123;&quot;start&quot;: &quot;node server.js&quot;&#125; 如果你的包里有server.js文件，npm默认将执行： node server.js.1&quot;scripts&quot;:&#123;&quot;preinstall&quot;:&quot;node-gyp rebuild&quot;&#125; 如果包里有binding.gyp，npm默认在preinstall命令时，使用node-gyp做编译。 参考资料 @参考 《CommonJS规范》@参考 《Specifics of npm’s package.json handling》@参考 《package.json 字段全解析》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://jafeney.com/tags/模块化/"}]},{"title":"封装一个简单的倒计时组件","date":"2016-01-10T03:53:24.000Z","path":"2016/01/10/2016-01-10-timer/","text":"写在前面电商网站经常会用到倒计时组件，不过很多JavaScript基础薄弱的前端工程师第一反应是去网上下载一个组件，我知道jQuery针对timer就有很多插件，但尽管是压缩后的版本，代码量也有几kb，而且没事使用就要引用进来，有必要吗？就这么简单的一个功能。看我50行搞定它。 上代码html结构12345678&lt;div&gt; &lt;span&gt;剩余时间&lt;/span&gt; &lt;span id=&quot;operate-timer-hours&quot;&gt;&lt;/span&gt; : &lt;span id=&quot;operate-timer-minutes&quot;&gt;&lt;/span&gt; : &lt;span id=&quot;operate-timer-seconds&quot;&gt;&lt;/span&gt;&lt;/div&gt; js代码段 熟悉我编码模式的你应该知道怎么用到你的项目里吧 ^_^ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657Module_Timer:function()&#123; var _leaveTime, //设定的倒计时秒数 _hours, //剩余的小时数 _minutes, //剩余的分钟数 _seconds, //剩余的秒数 _myTimer, //定时器对象 _hourWrap=document.getElementById(&apos;operate-timer-hours&apos;), _minuteWrap=document.getElementById(&apos;operate-timer-minutes&apos;), _secondWrap=document.getElementById(&apos;operate-timer-seconds&apos;); /*倒计时函数*/ function timer()&#123; _myTimer=window.setInterval(function()&#123; _seconds--; if(_seconds===0)&#123; _seconds=59; _minutes--; if(_minutes&lt;=0)&#123; _minutes=59; _hours--; if(_hours&lt;=0)&#123; window.clearInterval(_myTimer); &#125; _hourWrap.innerText=formatTimeNumber(_hours); &#125; _minuteWrap.innerText=formatTimeNumber(_minutes); &#125; _secondWrap.innerText=formatTimeNumber(_seconds); &#125;,1000); &#125; /*格式化时间数字*/ function formatTimeNumber(number)&#123; number=number*1; if(number&lt;10)&#123; number=&quot;0&quot;+number; &#125; return number; &#125; return&#123; /*模块初始化*/ init:function(opts)&#123; _leaveTime=opts.leaveTime || 24*3600; /*根据剩余的时间计算小时数*/ _hours=_leaveTime/3600&gt;&gt;0; /*计算剩余的分钟数*/ _minutes=(_leaveTime-3600*_hours)/60&gt;&gt;0; /*计算剩余的秒数*/ _seconds=_leaveTime%60; /*初始赋值*/ _hourWrap.innerText=formatTimeNumber(_hours); _minuteWrap.innerText=formatTimeNumber(_minutes); _secondWrap.innerText=formatTimeNumber(_seconds); /*启动计时器*/ timer(); &#125; &#125;&#125; 调用模块123456var timer=new Module_Timer()timer.init(&#123; leaveTime:(23*60*60+25)&#125;);样式什么自己爱怎么写就怎么写，我那个项目里是这样的：","categories":[{"name":"前端","slug":"前端","permalink":"http://jafeney.com/categories/前端/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://jafeney.com/tags/jQuery/"}]},{"title":"NoSQL数据库学习（二）","date":"2016-01-10T03:41:37.000Z","path":"2016/01/10/2016-01-10-nosql-2/","text":"写在前面之前一篇简单介绍了NoSQL数据库mongoDB的基本语法，暂且不深入研究它高级的用法，这一节具体谈谈nodeJS里如何快速操作mongoDB数据库，也好快速上手。 mongoose介绍基本概念Schema —— 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model —— 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity —— 由Model创建的实体，他的操作也会影响数据库 记住这三者的关系：Schema生成Model，Model创造Entity，Model和Entity都可对数据库操作造成影响，但Model比Entity更具操作性。 连接数据库mongoDB安装好之后默认会生成一个test数据库，我们就以这个为例子。12var mongoose = require(&apos;mongoose&apos;); //引用mongoose模块var db = mongoose.createConnection(&apos;localhost&apos;,&apos;test&apos;); //创建一个数据库连接 打开本机localhost的test数据库时，我们可以监测是否有异常12345db.on(&apos;error&apos;,console.error.bind(console,&apos;连接错误:&apos;));db.once(&apos;open&apos;,function()&#123; //一次打开记录 console.log(&apos;数据库连接成功！&apos;);&#125;); 简单操作成功开启数据库后，就可以执行数据库相应操作，假设以下代码都在回调中处理。 定义一个schema123var PersonSchema = new mongoose.Schema(&#123; name:String //定义一个属性name，类型为String&#125;); 将该Schema发布为Model1234var PersonModel = db.model(&apos;Person&apos;,PersonSchema);//如果该Model已经发布，则可以直接通过名字索引到，如下：//var PersonModel = db.model(&apos;Person&apos;);//如果没有发布，上一段代码将会异常 用Model创建Entity123var personEntity = new PersonModel(&#123;name:&apos;Krouky&apos;&#125;);//打印这个实体的名字看看console.log(personEntity.name); //Krouky 我们甚至可以为此Schema创建方法1234567//为Schema模型追加speak方法 PersonSchema.methos.speak = function()&#123; console.log(&apos;我的名字叫&apos;+this.name); &#125; var PersonModel = db.model(&apos;Person&apos;,PersonSchema); var personEntity = new PersonModel(&#123;name:&apos;Krouky&apos;&#125;); personEntity.speak();//我的名字叫Krouky Entity是具有具体的数据库操作CRUD的1personEntity.save(); //执行完成后，数据库就有该数据了 如果要执行查询，需要依赖Model，当然Entity也是可以做到的1234PersonModel.find(function(err,persons)&#123; //查询到的所有person console.log(persons);&#125;); 注意： 具体的如何配置Schema、Model以及Model和Entity的相关操作，我们会在后面进行 Model和Entity都有能影响数据库的操作，但仍有区别，后面我们也会做解释 一个lib式的实例下面是个很好的例子，基本囊括了mongoose操作mongoDB的常用操作，初学者大可以奉为library。 mongoose官方API http://mongoosejs.com/docs/api.html 123// mongoose 链接var mongoose = require(&apos;mongoose&apos;);var db = mongoose.createConnection(&apos;mongodb://127.0.0.1:27017/NodeJS&apos;); 1234// 链接错误db.on(&apos;error&apos;, function(error) &#123; console.log(error);&#125;); 12345678// Schema 结构var mongooseSchema = new mongoose.Schema(&#123; username : &#123;type : String, default : &apos;匿名用户&apos;&#125;, title : &#123;type : String&#125;, content : &#123;type : String&#125;, time : &#123;type : Date, default: Date.now&#125;, age : &#123;type : Number&#125;&#125;); 1234// 添加 mongoose 实例方法mongooseSchema.methods.findbyusername = function(username, callback) &#123; return this.model(&apos;mongoose&apos;).find(&#123;username: username&#125;, callback);&#125; 1234// 添加 mongoose 静态方法，静态方法在Model层就能使用mongooseSchema.statics.findbytitle = function(title, callback) &#123; return this.model(&apos;mongoose&apos;).find(&#123;title: title&#125;, callback);&#125; 12// modelvar mongooseModel = db.model(&apos;mongoose&apos;, mongooseSchema); 123456789101112// 增加记录 基于 entity 操作var doc = &#123;username : &apos;emtity_demo_username&apos;, title : &apos;emtity_demo_title&apos;, content : &apos;emtity_demo_content&apos;&#125;;var mongooseEntity = new mongooseModel(doc);mongooseEntity.save(function(error) &#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(&apos;saved OK!&apos;); &#125; // 关闭数据库链接 db.close();&#125;); 1234567891011// 增加记录 基于model操作var doc = &#123;username : &apos;model_demo_username&apos;, title : &apos;model_demo_title&apos;, content : &apos;model_demo_content&apos;&#125;;mongooseModel.create(doc, function(error)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(&apos;save ok&apos;); &#125; // 关闭数据库链接 db.close();&#125;); 1234567891011121314// 修改记录mongooseModel.update(conditions, update, options, callback);var conditions = &#123;username : &apos;model_demo_username&apos;&#125;;var update = &#123;$set : &#123;age : 27, title : &apos;model_demo_title_update&apos;&#125;&#125;;var options = &#123;upsert : true&#125;;mongooseModel.update(conditions, update, options, function(error)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(&apos;update ok!&apos;); &#125; //关闭数据库链接 db.close();&#125;); 123456789101112// 查询// 基于实例方法的查询var mongooseEntity = new mongooseModel(&#123;&#125;);mongooseEntity.findbyusername(&apos;model_demo_username&apos;, function(error, result)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(result); &#125; //关闭数据库链接 db.close();&#125;); 12345678910// 基于静态方法的查询mongooseModel.findbytitle(&apos;emtity_demo_title&apos;, function(error, result)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(result); &#125; //关闭数据库链接 db.close();&#125;); 12345678910111213// mongoose findvar criteria = &#123;title : &apos;emtity_demo_title&apos;&#125;; // 查询条件var fields = &#123;title : 1, content : 1, time : 1&#125;; // 待返回的字段var options = &#123;&#125;;mongooseModel.find(criteria, fields, options, function(error, result)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(result); &#125; //关闭数据库链接 db.close();&#125;); 123456789101112// 删除记录var conditions = &#123;username: &apos;emtity_demo_username&apos;&#125;;mongooseModel.remove(conditions, function(error)&#123; if(error) &#123; console.log(error); &#125; else &#123; console.log(&apos;delete ok!&apos;); &#125; //关闭数据库链接 db.close();&#125;); 总结独自摸索一门新的技术，我习惯的思路是螺旋式上升。首先了解改技术的发展历史，追溯它的过去也好展望它的未来，然后和同类型技术进行比较，结合实际的需求，优胜略汰，接着就是 寻找最合适的工具去做开发了。这个过程可以 看一些视频教程（湿货帮你快速入门）、看一些该技术相关的书籍（干货给你系统的思维，提升理解）、逛一些技术相关的博客论坛（半干半湿的东西会给你最前沿的信息）。 在没有一定的开发经验积累之前，着急地提高深度，折腾什么高大上的用法 是不合时宜的（除非你是站在牛人的肩膀上，人家肯一路指导）。自学是个自我领悟的过程，以实践为基础，提升自我为目的。 参考资料： @参考： Mongoose学习参考文档——基础篇@参考： node.js下mongoose简单操作实例","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jafeney.com/tags/mongoDB/"}]},{"title":"NoSQL数据库学习（一）","date":"2016-01-10T03:28:30.000Z","path":"2016/01/10/2016-01-10-nosql/","text":"写在前面还记得若干年前LAMP很火，Linux+Apache+MySQL+PHP这可谓是中小型网站建站的黄金之选。如今峰回路转，大前端时代nodeJS的到来，使得 MEAN（MongoDB+Express+Angular+NodeJS）成为另一个快速建站和大并发优化的不错之选。 什么是NoSQLNoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 RDBMS vs NoSQLRDBMS&gt;高度组织化结构化数据结构化查询语言（SQL） (SQL)数据和关系都存储在单独的表中。数据操纵语言，数据定义语言严格的一致性基础事务 NoSQL&gt;代表着不仅仅是SQL没有声明性查询语言没有预定义的模式键 - 值对存储，列存储，文档存储，图形数据库最终一致性，而非ACID属性非结构化和不可预知的数据CAP定理高性能，高可用性和可伸缩性 CAP定理（CAP theorem）在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点：&gt;一致性(Consistency) (所有节点在同一时间具有相同的数据)可用性(Availability) (保证每个请求不管成功或者失败都有响应)分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：&gt;CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 NoSQL的优点/缺点优点&gt;高可扩展性分布式计算低成本架构的灵活性，半结构化数据没有复杂的关系 缺点&gt;没有标准化有限的查询功能（到目前为止）最终一致是不直观的程序 基本语法MongoDB 创建数据库语法：use DATABASE_NAME （如果数据库不存在，则创建数据库，否则切换到指定数据库）实例： 以下实例我们创建了数据库 runoob12345&gt; use runoobswitched to db runoob&gt; dbrunoob&gt; 如果你想查看所有数据库，可以使用 show dbs 命令：1234&gt; show dbsshow dbslocal 0.078GBtest 0.078GB&gt; 可以看到，我们刚创建的数据库 runoob 并不在数据库的列表中， 要显示它，我们需要向 runoob 数据库插入一些数据。1234567&gt; db.runoob.insert(&#123;&quot;name&quot;:&quot;菜鸟教程&quot;&#125;)WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)&gt; show dbslocal 0.078GBrunoob 0.078GBtest 0.078GB&gt; MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。 MongoDB 删除数据库语法： db.dropDatabase() （删除当前数据库，默认为 test，你可以使用 db 命令查看当前数据库名） MongoDB 插入文档语法： MongoDB 使用 insert() 或 save() 方法向集合中插入文档，语法如下： 1db.COLLECTION_NAME.insert(document) MongoDB 更新文档MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。 update() 方法update() 方法用于更新已存在的文档。语法格式如下：123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明：query : update的查询条件，类似sql update查询内where后面的。update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。writeConcern :可选，抛出异常的级别。 save() 方法save() 方法通过传入的文档来替换已有文档。语法格式如下：123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明：document : 文档数据。writeConcern : 可选，抛出异常的级别。 MongoDB 删除文档语法： remove() 方法的基本语法格式如下所示：1234567db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明：query : （可选）删除的文档的条件。justOne : （可选）如果设为 true 或 1，则只删除一个文档。writeConcern :（可选）抛出异常的级别。 MongoDB 查询文档语法：123456//MongoDB 查询数据的语法格式如下&gt;db.COLLECTION_NAME.find();//find() 方法以非结构化的方式来显示所有文档。//如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：&gt;db.col.find().pretty(); MongoDB 与 RDBMS Where 语句比较 MongoDB AND 条件1&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() MongoDB OR 条件1234567db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() AND 和 OR 联合使用1234567891011121314&gt;db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty()&#123; &quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100&#125; MongoDB 条件操作符条件操作符用于比较两个表达式并从mongoDB集合中获取数据。MongoDB中条件操作符有： (&gt;) 大于 - $gt1db.col.find(&#123;&quot;likes&quot; : &#123;$gt : 100&#125;&#125;) (&lt;) 小于 - $lt1db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;) (&gt;=) 大于等于 - $gte1db.col.find(&#123;likes : &#123;$lt : 150&#125;&#125;) (&lt;= ) 小于等于 - $lte1db.col.find(&#123;likes : &#123;$lte : 150&#125;&#125;) MongoDB 使用 (&lt;) 和 (&gt;) 查询 - $lt 和 $gt1db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;) MongoDB 排序在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。1&gt;db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) MongoDB Limit() 方法如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。1&gt;db.COLLECTION_NAME.find().limit(NUMBER) MongoDB Skip() 方法我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。1&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 参考 《NoSQL 简介》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"mongoDB","slug":"mongoDB","permalink":"http://jafeney.com/tags/mongoDB/"}]},{"title":"深入理解express框架","date":"2016-01-10T03:26:33.000Z","path":"2016/01/10/2016-01-10-express/","text":"写在前面Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。 Express 框架核心特性： 可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML页面。 今天不介绍基本用法，如何用它搭建nodeJS中间层在我前面的文章里有比较详细的介绍，而这次主要是深入研究它的内部实现原理。 底层HTTP服务器学习nodeJS基础的时候我们经常要用到 http 这个核心模块，它以极其简洁JavaScript代码 搭建出本地http服务. 1234567891011121314// 引入所需模块var http = require(&quot;http&quot;);// 建立服务器var app = http.createServer(function(request, response) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Hello world!\\n&quot;);&#125;);// 启动服务器app.listen(1337, &quot;localhost&quot;);console.log(&quot;Server running at http://localhost:1337/&quot;); 解析： 第一行使用 require 函数引入Node内置模块 http 。然后存入名为 http 的变量中。然后我们使用 http.createServer() 将服务器保存至 app 变量。它将一个函数作为参数监听请求。稍后将会详细介绍它。最后我们要做的就是告诉服务器监听来自1337端口的请求，之后输出结果。然后一切完成。 中间件通过中间件，搭建本地服务器的过程变得简单，比如最简单的connect123456789101112131415// 引入所需模块var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);// 建立appvar app = connect();// 添加中间件app.use(function(request, response) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Hello world!\\n&quot;);&#125;);// 启动应用http.createServer(app).listen(1337); express 4.x 已经把connect中间件封装的express模块里。因此我们不需要依赖connect模块：123456var express = require(&apos;express&apos;);var app = express();var server = app.listen(8081, function () &#123; console.log(&quot;Server running at http://localhost:1337/&quot;)&#125;); 什么是中间件一个最基本的中间件结构如下：12345function myFunMiddleware(request, response, next) &#123; // 对request和response作出相应操作 // 操作完毕后返回next()即可转入下個中间件 next();&#125; 当我们启动一个服务器，函数开始从顶部一直往下执行。还是还来个能跑的程序 12345678910111213141516171819202122232425262728293031323334353637var connect = require(&quot;connect&quot;);var http = require(&quot;http&quot;);var app = connect();app.use(connect.logger());// Homepageapp.use(function(request, response, next) &#123; if (request.url == &quot;/&quot;) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Welcome to the homepage!\\n&quot;);// The middleware stops here. &#125; else &#123; next(); &#125;&#125;);// About pageapp.use(function(request, response, next) &#123; if (request.url == &quot;/about&quot;) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Welcome to the about page!\\n&quot;);// The middleware stops here. &#125; else &#123; next(); &#125;&#125;);// 404&apos;d!app.use(function(request, response) &#123; response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;404 error!\\n&quot;);&#125;);http.createServer(app).listen(1337); 是的，这样的过程略显繁琐，因此express把connect封装到了自己模块里，用express实现上面的过程简单了不少（往下看） 。 请求和响应Request 对象 request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常用属性和方法有16项 req.app 当callback为外部文件时，用req.app访问express的实例。 req.baseUrl 获取路由当前安装的URL路径 req.body / req.cookies 获得「请求主体」/ Cookies req.fresh / req.stale 判断请求是否还「新鲜」 req.hostname / req.ip 获取主机名和IP地址 req.originalUrl 获取原始请求URL req.params 获取路由的parameters req.path 获取请求路径 req.protocol 获取协议类型 req.query 获取URL的查询参数串 req.route 获取当前匹配的路由 req.subdomains 获取子域名 req.accpets() 检查请求的Accept头的请求类型 req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages req.get() 获取指定的HTTP请求头 req.is() 判断请求头Content-Type的MIME类型 Response 对象 response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有以下17项。 res.app 同req.app一样 res.append() 追加指定HTTP头 res.set() 在res.append()后将重置之前设置的头 res.cookie(name，value [，option]) 设置Cookie opition domain / expires / httpOnly / maxAge / path / secure / signed res.clearCookie() 清除Cookie res.download() 传送指定路径的文件 res.get() 返回指定的HTTP头 res.json() 传送JSON响应 res.jsonp() 传送JSONP响应 res.location() 只设置响应的Location HTTP头，不设置状态码或者close response res.redirect() 设置响应的Location HTTP头，并且设置状态码302 res.send() 传送HTTP响应 res.sendFile(path [，options] [，fn]) 传送指定路径的文件 -会自动根据文件extension设定Content-Type res.set() 设置HTTP头，传入object可以一次设置多个头 res.status() 设置HTTP状态码 res.type() 设置Content-Type的MIME类型 路由最原始的路由：12345678910111213141516171819202122var http = require(&quot;http&quot;);http.createServer(function(req, res) &#123;// Homepage if(req.url == &quot;/&quot;) &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;); res.end(&quot;Welcome to the homepage!&quot;); &#125;// About page else if (req.url == &quot;/about&quot;) &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;); res.end(&quot;Welcome to the about page!&quot;); &#125;// 404&apos;d! else &#123; res.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); res.end(&quot;404 error! File not found.&quot;); &#125;&#125;).listen(1337, &quot;localhost&quot;); express封装的路由：1234567891011121314151617181920212223242526272829303132333435363738var express = require(&apos;express&apos;);var app = express();// 主页输出 &quot;Hello World&quot;app.get(&apos;/&apos;, function (req, res) &#123; console.log(&quot;主页 GET 请求&quot;); res.send(&apos;Hello GET&apos;);&#125;)// POST 请求app.post(&apos;/&apos;, function (req, res) &#123; console.log(&quot;主页 POST 请求&quot;); res.send(&apos;Hello POST&apos;);&#125;)// /del_user 页面响应app.delete(&apos;/del_user&apos;, function (req, res) &#123; console.log(&quot;/del_user 响应 DELETE 请求&quot;); res.send(&apos;删除页面&apos;);&#125;)// /list_user 页面 GET 请求app.get(&apos;/list_user&apos;, function (req, res) &#123; console.log(&quot;/list_user GET 请求&quot;); res.send(&apos;用户列表页面&apos;);&#125;)// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求app.get(&apos;/ab*cd&apos;, function(req, res) &#123; console.log(&quot;/ab*cd GET 请求&quot;); res.send(&apos;正则匹配&apos;);&#125;)var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)&#125;); 视图express结合前端模板引擎可以在服务端实现视图的渲染，这里还是以 jade模板引擎为例：123456789// 启动Expressvar express = require(&quot;express&quot;);var app = express();// 设置view目录app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);// 设置模板引擎app.set(&quot;view engine&quot;, &quot;jade&quot;); 开头部分的代码和前面基本一样。之后我们指定视图文件所在目录。然后告诉Express我们要使用 Jade作为模板引擎。 接下来 我们建立一个名为 index.jade 的文件并把它放入 views 目录。代码如下：12345doctype 5html body h1 Hello, world! p= message 我们需要从Express中渲染这个视图。代码如下：123app.get(&quot;/&quot;, function(request, response) &#123; response.render(&quot;index&quot;, &#123; message: &quot;I love anime&quot; &#125;); &#125;); Express为 response 对象添加了一个 render 方法。这个方法可以处理很多事情，但最主要的还是加载模板引擎和对应的视图文件，之后渲染成普通的HTML文档，例如这里的 index.jade. 参考资料 @参考 《深入理解 Express.js》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"}]},{"title":"express搭建nodeJS中间层（三）","date":"2016-01-10T03:24:14.000Z","path":"2016/01/10/2016-01-10-express-3/","text":"写在前面之前2篇已经比较详细地介绍用express搭建nodeJS中间层并部署到centOS服务器，用forever管理nodeJS进程，这一系列工作 都是基于 项目已经调试 完毕了。但实际开发过程中会发现 每次修改完 代码后 都需要关闭node进程然后 重启才能生效，特别麻烦，这篇就介绍一个 自动监听并同步的的 node工具——supervisor。 全局安装 supervisor直接用npm安装既可，输入指令 :1$ npm -g install supervisor 这里注意一点的就是，supervisor必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。 如果不想安装到默认的全局,也可以自己修改全局路径到当前路径 :1$ npm config set prefix &quot;路径&quot; 用supervisor启动express项目安装完以后就可以 用 supervisor 来启动 express项目了，进入项目根目录，执行：1$ supervisor ./bin/www 如果你之前已经 用forever 来托管这个进程了，在执行 supervisor之前 应该关闭 这个进程。 关闭所有forever托管的进程：1$ forever stopall 然后再执行supervisor的命令，这样你的项目一旦发生更改（只要不是语法错误），supervisor会帮你自动同步到该进程里来，不需要重新启动。 好了，顺便做个小测试吧，我们先在浏览器打开这个网站。数据已经监听到了： 随意修改一个 nodeJS文件，然后会看到： node服务已经重新启动了，很方便对吧 ^_^ 。 让supervisor监听模板文件的改动 默认情况下，supervisor只能监听 nodeJS的文件，其他的文件改动它是不会捕捉到的。下面我们 通过添加 启动参数 的方式扩展这一功能。 首先 我们明确下 supervisor的几个 options 的用法：123456789101112131415161718192021//要监控的文件夹或js文件，默认为&apos;.&apos;-w|--watch &lt;watchItems&gt;//要忽略监控的文件夹或js文件 -i|--ignore &lt;ignoreItems&gt;//监控文件变化的时间间隔（周期），默认为Node.js内置的时间-p|--poll-interval &lt;milliseconds&gt;//要监控的文件扩展名，默认为&apos;node|js&apos;-e|--extensions &lt;extensions&gt;//要执行的主应用程序，默认为&apos;node&apos;-x|--exec &lt;executable&gt;//开启debug模式（用--debug flag来启动node）--debug//安静模式，不显示DEBUG信息-q|--quiet 好了，看了上面的介绍，大家应该注意到 --extensions &lt;extensions&gt; 参数，对的，我们把 需要添加监听的文件名后缀 添加进去就可以了。我的项目里采用的ArtTemplate模板引擎，所有模板文件的后缀名是 .art ，所以我启动 supervisor的命令是这样的： 1$ supervisor --extensions art ./bin/www 这样 模板文件 你更改后也能生效了，当然如果css文件也要同时添加监听，可以这么写： 1$ supervisor --extensions art,css ./bin/www 运行的效果是这样的： 后话当前 国内 关于express 4.x 搭建nodeJS中间层的 文档和一手资料不多，每当遇到问题时 就需要 去翻墙看看国外网站的或者翻译一些英文的帖子，着实不易啊。希望 我的这些 “战地笔记”能为有需要的人提供参考价值吧 ^ _ ^ @参考 《supervisor模块监控nodejs文件的变化并自动刷新》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"}]},{"title":"express搭建nodeJS中间层（二）","date":"2016-01-10T03:22:39.000Z","path":"2016/01/10/2016-01-10-express-2/","text":"写在前面上一篇写到用express搭建本地环境而且成功实现了路由和模板渲染，这一篇具体讲讲如何把一个原本用artTemplate渲染的前端页面用nodeJS渲染并返回给浏览器。 改造过程 上一篇已经在express里配置好了artTemplate模板引擎，所以这里的改造变得无比简单。 删除不需要的依赖项之前在 &lt;head&gt;&lt;/head&gt;里引入的artTemplate类库存在的目的是在客户端用JavaScript调用template函数，对指定id的模板进行渲染，服务端这个步骤是不需要的，直接删除即可。 接下来再把这个结构删掉，因为服务端是直接把html文件作为模板引入的，不需要在单独声明 script 的类型和模板的id。1&lt;script type=&quot;text/html&quot; id=&quot;xxxx&quot;&gt;&lt;/script&gt; 最后一个依赖是用原本用JavaScript 调取接口获取data，然后用 template() 方法指定模板进行渲染这个过程，我们等下要把它放到服务端来完成，所以客户端里也不需要了。在我的设计模式里，只需要把 fGetData() 这个模块注释掉就行了。1234567891011121314/** * [单例初始化入口] * @return &#123;[type]&#125; [description] */ init:function()&#123; var self=this; /*执行模板渲染模块*/ self.fGetData(); //现在不需要了，把它注释掉吧！ self.eventBind($,self); /*执行图片加载缓冲*/ $(&apos;.lazyload&apos;).lazyload(&#123;effect : &quot;fadeIn&quot;&#125;); &#125; 静态资源迁移我的项目是用gulp自动化管理的，只需要把 builder 、 lib 、html 这三个目录分别 copy到express工程 public目录下的 JavaScripts 、stylesheets ，根目录下的 view 文件夹里（文件位置具体怎么放看你的 个人爱好）。 当然这样迁移好还不够，模板文件里的路径也要改成迁移后的新路径。 注意：因为 之前我们再 app.js 里设置了静态资源的引用路径，所以路由 /index 下 静态资源 是可以直接访问的。比如 就像下面这样就能 引用到这2个 css文件了:123456&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;stylesheets/base.min.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;stylesheets/style.min.css&quot;/&gt;&lt;/head&gt; 服务端渲染我们的数据本来是通过调取Java接口获取到的，所以这里 服务端 要用到 nodeJS的 request 模块，先安装它：1$ npm install request 有了request，我们就能在nodeJS里随意调用 Java写好的数据接口了。 接下里打开路由目录下的index.js 文件，在首页的路由里把模板渲染的工作 完成1234567891011121314151617var express = require(&apos;express&apos;);var request= require(&apos;request&apos;);var router = express.Router();/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123; /*正式数据*/ request(&apos;http://test.webapp.baai.com/hk/index.json&apos;,function(error,response,body)&#123; /*判断请求是否成功*/ if (!error &amp;&amp; response.statusCode == 200) &#123; /*把字符串转换为json*/ var data=JSON.parse(body); /*渲染模板*/ res.render(&apos;index&apos;, data); &#125; &#125;);&#125;); 注意： 返回的数据默认格式是string，如果需要json格式，要用JSON.parse()进行处理，不然就会报错 部署到远程服务器这个过程 需要 懂一点 Linux，先用 文件服务工具 登录到 远程服务器，把 项目资源copy到线上服务器。 接下来就是 安装nodeJS环境了，这个步骤网上教程太多了，不同的系统不一样（不会的自己 百度 吧）。我用的服务器是阿里云的 centOS，本身自带nodeJS环境，所以不用从头安装，不过node的版本比较低，所以我简单升级了一下环境。 1、检查 Node的当前版本，使用命令12$ node -v$ npm -v 2、清除npm cache1$ sudo npm cache clean -f 3、全局安装 Node Binary管理模块“n”1$ npm install n -g 4、升级到最新版本（该步骤可能需要花费一些时间）1$ sudo n stable 5、查看Node的版本，检查升级是否成功12$ node -v $ npm -v Nginx站点与NodeJS站点共存的配置首先是网站入口问题，Nginx使用了80端口，NodeJS使用8080端口。我们利用Nginx的“proxy_pass”将对80端口NodeJS站点的访问导向8080端口，在LuManager中，这个配置十分简单： 1、进入LuManager后台，用“快速建站”建立NodeJS网站，如testnodejs.com网站，这里也可建立多个NodeJS网站，网站域名按如下方式填写即可：1testnodejs.com *.testnodejs.com testnodejs2.com *.testnodejs2.com 使他们指向共同的NodeJS网站群根目录，如nodejs目录。 2、然后为NodeJS网站配置Nginx，修改该NodeJS网站配置，进入选填项，在Nginx扩展设置(location段)**添加如下代码：1proxy_pass http://127.0.0.1:8080; 如此一来，外部对testnodejs.com、testnodejs2.com等NodeJS网站的访问全部转向了8080端口，NodeJS监听8080端口即可。而该NodeJS网站群的根目录即上面设置的nodejs目录，我们可在该目录中再搭设testnodejs.com、testnodejs2.com等虚拟站点。 安装Forever后台管理器我们不可能直接通过node命令来管理远程站点，这样无法保证网站的可持续运行。我们用Forever来解决这个问题，它可以将NodeJS应用以后台守护进程的方式运行，我们还可以将NodeJS应用设成随系统启动而自动运行。首先，全局安装Forever：1$ npm install forever -g 安装 完后我们 就要让 express项目在后台自行运行了： 进入到 你的项目的根目录。原本 express项目的启动命令是 npm start，这里我用forever启动肯定不能这么搞了，我们打开 项目的package.json文件： 1234567891011121314151617&#123; &quot;name&quot;: &quot;node_hk&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;body-parser&quot;: &quot;~1.13.2&quot;, &quot;cookie-parser&quot;: &quot;~1.3.5&quot;, &quot;debug&quot;: &quot;~2.2.0&quot;, &quot;express&quot;: &quot;~4.13.1&quot;, &quot;art-template&quot;: &quot;~3.0.3&quot;, &quot;morgan&quot;: &quot;~1.6.1&quot;, &quot;serve-favicon&quot;: &quot;~2.3.0&quot; &#125;&#125; 注意到 “start”脚本对应的shell指令是 node ./bin/www ,换句话说 npm start 实际上执行的就是这个 shell命令，那么我们很容易想到 项目启动的命令 实际上就是 它了，只是 express 4.x 把这个工作 托管给了 npm。 于是，forever启动项目的命令就是：1$ forever start ./bin/www 好了，执行这个命令后，你的项目就托管给 forever在后台自动运行了，你关闭了 窗口也不会影响 node服务。然后再说说 关闭命令： 先查看当前交给 forever 托管的node进程：1$ forever list 这个命令会列出当前 被 forever托管的 nodeJS进程，如果想关闭那个，把它的id找到，执行：1$ forever stop [id] 如果你懒得找进程，那干脆全部关闭吧，执行： 1$ forever stopall Forever使用介绍子命令actions：123456789101112131415start: 启动守护进程stop: 停止守护进程stopall: 停止所有的forever进程restart: 重启守护进程restartall: 重启所有的foever进程list: 列表显示forever进程config: 列出所有的用户配置项set &lt;key&gt; &lt;val&gt;: 设置用户配置项clear &lt;key&gt;: 清楚用户配置项logs: 列出所有forever进程的日志logs &lt;script|index&gt;: 显示最新的日志columns add &lt;col&gt;: 自定义指标到forever listcolumns rm &lt;col&gt;: 删除forever list的指标columns set&lt;cols&gt;: 设置所有的指标到forever listcleanlogs: 删除所有的forever历史日志 配置参数options：12345678910111213141516171819202122-m MAX: 运行指定脚本的次数-l LOGFILE: 输出日志到LOGFILE-o OUTFILE: 输出控制台信息到OUTFILE-e ERRFILE: 输出控制台错误在ERRFILE-p PATH: 根目录-c COMMAND: 执行命令，默认是node-a, append: 合并日志-f, fifo: 流式日志输出-n, number: 日志打印行数pidFile: pid文件sourceDir: 源代码目录minUptime: 最小spinn更新时间(ms)spinSleepTime: 两次spin间隔时间colors: 控制台输出着色plain: no-colors的别名，控制台输出无色-d, debug: debug模式-v, verbose: 打印详细输出-s, silent: 不打印日志和错误信息-w, watch: 监控文件改变watchDirectory: 监控顶级目录watchIgnore: 通过模式匹配忽略监控-h, help: 命令行帮助信息 @参考 《Nodejs进程管理模块forever详解node.js》 @参考 zensh《阿里云主机Nginx下配置NodeJS、Express和Forever》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"}]},{"title":"express搭建nodeJS中间层（一）","date":"2016-01-10T03:19:15.000Z","path":"2016/01/10/2016-01-10-express-1/","text":"写在前面好了，准备了一周的理论知识和开发方案，nodeJS中间层搭建项目从今天就开始了。作为项目的负责人和初次尝试者，我会把开发的过程中用到的技术、碰到的壁一个个用文章记录下来。 express框架介绍express框架是nodeJS出来不久就诞生的webServer构建框架，目前的版本是 4.x。项目时间紧迫，这次就不从零开始搞了，站在巨人的肩膀上解决问题，可以帮我们节省些底层工作。 @ express API官方网站 http://www.expressjs.com.cn 安装环境如果你还没有安装node，先把它安装好。然后用npm 全局安装express和express-generator。12$ npm install exprss -g --save$ npm install express-generator -g --save 文件部署通过express-generator生成器工具 express 可以快速创建一个应用的骨架：（我的项目名是 node_hk）1$ express node_hk 默认生成的目录是这样的：1234567891011121314151617.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.jade ├── index.jade └── layout.jade 更改依赖包配置因为我的前端项目用的是artTemplate模板引擎，为了很前后端复用，因此node这边也采用这款模板引擎。所以需要把express默认的jade改成了art-template：1234567891011121314151617&#123; &quot;name&quot;: &quot;node_hk&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;body-parser&quot;: &quot;~1.13.2&quot;, &quot;cookie-parser&quot;: &quot;~1.3.5&quot;, &quot;debug&quot;: &quot;~2.2.0&quot;, &quot;express&quot;: &quot;~4.13.1&quot;, &quot;art-template&quot;: &quot;~3.0.3&quot;, &quot;morgan&quot;: &quot;~1.6.1&quot;, &quot;serve-favicon&quot;: &quot;~2.3.0&quot; &#125;&#125; 安装node_modules配置好了 package.json，下面我们就用npm 依次安装它们吧！1$ npm install 启动项目启动这个应用（MacOS 或 Linux 平台）：1$ DEBUG=myapp npm start Windows 平台使用如下命令：1$ set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了（等等 报错了对不对 _ ，别着急，往下看）。 把默认的jade模板引擎改成artTemplate改造app.jsapp.js是express的主要文件，这个文件里包含了指定模板引擎、指定视图文件默认路径的代码。需要将指定模板引擎的代码改为指定用art-template引擎。视图文件默认路径保持不变，因此无需改动。 新的app.js如下（懒得看就直接copy吧）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);/*引用artTemplate模板*/var template=require(&apos;art-template&apos;);var routes = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);var app = express();// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));/*把jade模板引擎改成artTemplate*///app.set(&apos;view engine&apos;, &apos;jade&apos;);template.config(&apos;base&apos;,&apos;&apos;);template.config(&apos;extname&apos;,&apos;.html&apos;);app.engine(&apos;.html&apos;,template.__express);app.set(&apos;view engine&apos;,&apos;html&apos;);// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, &apos;public&apos;, &apos;favicon.ico&apos;)));app.use(logger(&apos;dev&apos;));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.use(&apos;/&apos;, routes);app.use(&apos;/users&apos;, users);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error(&apos;Not Found&apos;); err.status = 404; next(err);&#125;);// error handlers// development error handler// will print stacktraceif (app.get(&apos;env&apos;) === &apos;development&apos;) &#123; app.use(function(err, req, res, next) &#123; res.status(err.status || 500); res.render(&apos;error&apos;, &#123; message: err.message, error: err &#125;); &#125;);&#125;// production error handler// no stacktraces leaked to userapp.use(function(err, req, res, next) &#123; res.status(err.status || 500); res.render(&apos;error&apos;, &#123; message: err.message, error: &#123;&#125; &#125;);&#125;);module.exports = app; 编写artTemplate模板文件在工作区下，进入express文件夹中的views子文件夹，创建index.html，并将如下代码输入index.html，并保存。 注意，views文件夹下会有index.jade等三个后缀是.jade的文件存在，可以忽视它们。因为express默认支持的模板引擎是jade，所以初始化的框架中的模板是以.jade结尾的文件。也可以删除它们。 这里举个简单的 index.html 例子：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;hello express &amp; art-template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Hello express &amp; art-template&lt;/h2&gt; &lt;div id=&apos;main&apos;&gt; &lt;ul&gt; &#123;&#123;each list&#125;&#125; &lt;li&gt;编号：&#123;&#123;$value.id&#125;&#125; &amp;nbsp;&amp;nbsp;姓名：&#123;&#123;$value.name&#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;&#123;/each&#125;&#125; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 渲染模板express默认访问index路由。我们需要在index路由方法中，渲染模板。 进入routes文件夹，打开index.js，增加渲染模板的代码，如下： 12345678910111213141516171819202122232425var express = require(&apos;express&apos;);var router = express.Router();/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123; //数据 var data = &#123; title: &apos;国内要闻&apos;, time: (new Date).toString(), list: [ &#123; id: &apos;1&apos;, name: &apos;张三&apos; &#125;, &#123; id: &apos;2&apos;, name: &apos;李四&apos; &#125; ] &#125;; //渲染模板 res.render(&apos;index&apos;, data);&#125;);module.exports = router; 代码中的res.render(‘index’, data)调用，会调用artTemple模块中的template.express方法，并传入模板文件名、数据。template.express方法是在app.js中注册给express框架的。 在Windows命令行下，进入工作区，执行 node app.js ，服务器就启动了。此时在本地机器上使用浏览器访问http://localhost:3000将会看到Html输出了，服务器端的命令行工具上同时也会显示“New request arrived.”字样。 按Ctl+C退出服务器 @参考 express 官方API http://www.expressjs.com.cn@参考 执着的慢行者 《使用artTemplate模板开发网站（node.js + express环境）》","categories":[{"name":"大前端","slug":"大前端","permalink":"http://jafeney.com/categories/大前端/"}],"tags":[{"name":"express","slug":"express","permalink":"http://jafeney.com/tags/express/"}]}]